\documentclass[twoside,11pt]{book} 

\usepackage{bibentry}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{a4wide} %THIS ONE
\usepackage{color}
\usepackage{ebezier}
\usepackage{graphicx,pstricks}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{framed}
\usepackage[light,all,bottomafter]{draftcopy} 
\usepackage{sectsty} 
\usepackage{index}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{tocloft}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\lstset{language=Python}
 
\makeindex

\renewcommand{\baselinestretch}{1.1}

%\sectionfont{\Large \bf}
%\subsectionfont{\large \bf}

\headheight=16pt
\topskip=0pt

\newenvironment{itemize*}%
{\begin{itemize}%
\setlength{\leftmargin}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{itemize}}

\newenvironment{enumerate*}%
{\begin{enumerate}%
\setlength{\leftmargini}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{enumerate}}

\newcommand{\figsize}{0.55}
\newcommand{\twofigsize}{0.4}

\newenvironment{example}{
\definecolor{shadecolor}{rgb}{0.9,0.9,0.8}
\begin{shaded}
\vspace{0.2cm} \bf \noindent Example:\normalfont  }
{
\end{shaded}
}

\newenvironment{new}{
\definecolor{shadecolor}{rgb}{0.9,1,1}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{cut}{
\definecolor{shadecolor}{rgb}{1.0,0.6,0.6}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{status}{
\definecolor{shadecolor}{rgb}{0.95,0.5,0.85}
\begin{shaded}
\vspace{0.0cm} \bf \noindent To do:\normalfont}{\end{shaded}}

\leftmargin=0pt
\itemindent=0pt

\usepackage{courier}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}

\begin{document}

\title{{\Huge \bf FinancePy}}
\author{Dominic O'Kane}

\maketitle 

\cleardoublepage

\cftsetindents{section}{1em}{3em}
\setcounter{tocdepth}{1}
\tableofcontents

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Introduction}
Stuff about FinancePy
\chapter{..//finutils}
\section{Introduction}
This is a collection of modules used across a wide range of FinancePy functions. Examples include date generation, special mathematical functions.
\newpage
\section{FinCalendar}

\subsubsection{Enumerated Type: FinBusDayConventionTypes}
\begin{itemize}
\item{NONE}
\item{FOLLOWING}
\item{MODIFIED\_FOLLOWING}
\item{PRECEDING}
\item{MODIFIED\_PRECEDING}
\end{itemize}

\subsubsection{Enumerated Type: FinCalendarTypes}
\begin{itemize}
\item{TARGET}
\item{US}
\item{UK}
\item{NONE}
\item{WEEKEND}
\end{itemize}

\subsubsection{Enumerated Type: FinDateGenRuleTypes}
\begin{itemize}
\item{FORWARD}
\item{BACKWARD}
\end{itemize}

\subsection{Class: FinCalendar(object)}
Class to manage designation of payment dates as holidays according to a calendar convention specified by the user. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_type}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, calendarType):
\end{lstlisting}

\subsection{Class Method {\it adjust}}
Adjust a payment date if it falls on a holiday according to the specified business day convention. 

\begin{lstlisting}
    def adjust(self, dt, busDayConventionType ):
\end{lstlisting}

\subsection{Class Method {\it isBusinessDay}}


\begin{lstlisting}
    def isBusinessDay(self, dt):
\end{lstlisting}

\subsection{Class Method {\it easterMonday}}
Get the day in a givenm year that is Easter Monday. This is not easy to compute so we rely on a pre-calculated array. 

\begin{lstlisting}
    def easterMonday(self, y):
\end{lstlisting}

\subsection{Class Method {\it str}}
def str(self):

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinCurve}

\subsection{Class: FinCurve()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_times}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, times, values):
\end{lstlisting}

\subsection{Class Method {\it value}}
get the value (in this context it is a discount factor) by interpolating according to a specified interpolation method. 

\begin{lstlisting}
    def value(self, t):
\end{lstlisting}

\newpage
\section{FinDate}

\subsection{Class: FinDate()}
Date class that is simple to use and includes a number of useful date functions used frequently in Finance. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_m}
\item{self.\_y}
\item{self.\_excelDate}
\item{self.\_d}
\item{self.\_weekday}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 y, # Year (1900-2100)
                 m, # Month (1-12)
                 d):# Day of Month (1-31 depending on month)
\end{lstlisting}

\subsection{Class Method {\it refresh}}
Update internal representation of date as number of days since the 1st Jan 1900. This is same as Excel convention. 

\begin{lstlisting}
    def refresh(self):
\end{lstlisting}

\subsection{Class Method {\it \_\_lt\_\_}}
def \_\_lt\_\_(self, other):

\begin{lstlisting}
    def __lt__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_gt\_\_}}
def \_\_gt\_\_(self, other):

\begin{lstlisting}
    def __gt__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_le\_\_}}
def \_\_le\_\_(self, other):

\begin{lstlisting}
    def __le__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_ge\_\_}}
def \_\_ge\_\_(self, other):

\begin{lstlisting}
    def __ge__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_sub\_\_}}
def \_\_sub\_\_(self, other):

\begin{lstlisting}
    def __sub__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_eq\_\_}}
def \_\_eq\_\_(self, other):

\begin{lstlisting}
    def __eq__(self, other):
\end{lstlisting}

\subsection{Class Method {\it isWeekend}}


\begin{lstlisting}
    def isWeekend(self):
\end{lstlisting}

\subsection{Class Method {\it addDays}}


\begin{lstlisting}
    def addDays(self, numDays):
\end{lstlisting}

\subsection{Class Method {\it addWorkDays}}


\begin{lstlisting}
    def addWorkDays(self, numDays):
\end{lstlisting}

\subsection{Class Method {\it addMonths}}


\begin{lstlisting}
    def addMonths(self, mm):
\end{lstlisting}

\subsection{Class Method {\it nextCDSDate}}


\begin{lstlisting}
    def nextCDSDate(self, mm):
\end{lstlisting}

\subsection{Class Method {\it thirdWednesdayOfMonth}}
For a specific month and year this returns the day number of the 3rd Wednesday by scanning through dates in the third week 

\begin{lstlisting}
    def thirdWednesdayOfMonth(self,m,y):
\end{lstlisting}

\subsection{Class Method {\it nextIMMDate}}
This function returns the next IMM date after the current date This is a 3rd Wednesday of Jun, March, Sep or December 

\begin{lstlisting}
    def nextIMMDate(self):
\end{lstlisting}

\subsection{Class Method {\it datediff}}


\begin{lstlisting}
    def datediff(d1,d2):
\end{lstlisting}

\subsection{Class Method {\it date}}
def date(self):

\begin{lstlisting}
    def date(self):
\end{lstlisting}

\subsection{Class Method {\it \_\_str\_\_}}
def \_\_str\_\_(self):

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\subsection{Function {\it dailyWorkingDaySchedule}}
def dailyWorkingDaySchedule(self,startDate,endDate):

\begin{lstlisting}
def dailyWorkingDaySchedule(self,startDate,endDate):
\end{lstlisting}

\newpage
\section{FinDayCount}

\subsubsection{Enumerated Type: FinDayCountTypes}
\begin{itemize}
\item{THIRTY\_E\_360\_ISDA}
\item{THIRTY\_E\_360\_PLUS\_ISDA}
\item{ACT\_ACT\_ISDA}
\item{ACT\_365\_ISDA}
\item{THIRTY\_360}
\item{THIRTY\_360\_BOND}
\item{THIRTY\_E\_360}
\item{ACT\_360}
\item{ACT\_365\_FIXED}
\item{ACT\_365\_LEAP}
\end{itemize}

\subsection{Class: FinDayCount(object)}
Calculate the fractional day count between two dates according to a specified convention. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_type}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,dccType):
\end{lstlisting}

\subsection{Class Method {\it yearFrac}}
Calculate the year fraction between dates dt1 and dt2 using the specified day count convention. 

\begin{lstlisting}
    def yearFrac(self, dt1, dt2):
\end{lstlisting}

\subsection{Class Method {\it \_\_str\_\_}}
def \_\_str\_\_(self):

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\newpage
\section{FinError}

\subsection{Class: FinError(Exception)}
Simple error class specific to FinPy. Need to decide how to handle FinancePy errors. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_message}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, message):

\begin{lstlisting}
    def __init__(self, message):
\end{lstlisting}

\subsection{Class Method {\it printMessage}}
def printMessage(self):

\begin{lstlisting}
    def printMessage(self):
\end{lstlisting}

\subsection{Function {\it func\_name}}
def func\_name():

\begin{lstlisting}
def func_name():
\end{lstlisting}

\subsection{Function {\it isNotEqual}}
def isNotEqual(x,y,tol=1e-6):

\begin{lstlisting}
def isNotEqual(x,y,tol=1e-6):
\end{lstlisting}

\newpage
\section{FinFrequency}

\subsubsection{Enumerated Type: FinFrequencyTypes}
\begin{itemize}
\item{ANNUAL}
\item{SEMI\_ANNUAL}
\item{QUARTERLY}
\item{MONTHLY}
\end{itemize}

\subsection{Function {\it FinFrequency}}
def FinFrequency(frequencyType):

\begin{lstlisting}
def FinFrequency(frequencyType):
\end{lstlisting}

\newpage
\section{FinGlobalVariables}

\newpage
\section{FinHelperFunctions}

\subsection{Function {\it listdiff}}


\begin{lstlisting}
def listdiff(a,b):
\end{lstlisting}

\subsection{Function {\it dotproduct}}
def dotproduct(xVector,yVector):

\begin{lstlisting}
def dotproduct(xVector,yVector):
\end{lstlisting}

\subsection{Function {\it frange}}
def frange(start, stop, step):

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\newpage
\section{FinInterpolate}

\subsubsection{Enumerated Type: FinInterpMethods}
\begin{itemize}
\item{PIECEWISE\_LINEAR}
\item{PIECEWISE\_LOG\_LINEAR}
\item{FLAT\_FORWARDS}
\end{itemize}

\subsection{Function {\it interpolate}}
Return the interpolated value of y given x and a vector of x and y. The values of x must be monotonic and increasing. The different schemes for interpolation are linear in y (as a function of x), linear in log(y) and piecewise flat in the continuously compounded forward y rate. 

\begin{lstlisting}
def interpolate(xValue,
                xvector,
                yvector,
                method):
\end{lstlisting}

\newpage
\section{FinMath}

\subsection{Function {\it isLeapYear}}


\begin{lstlisting}
def isLeapYear(y):
\end{lstlisting}

\subsection{Function {\it scale}}


\begin{lstlisting}
def scale(x,factor):
\end{lstlisting}

\subsection{Function {\it maximum}}
Determine the maximum of two values a and b. TODO: Add Numba function signature and test speed versus Numpy. 

\begin{lstlisting}
def maximum(a,b):
\end{lstlisting}

\subsection{Function {\it maxaxis}}
Perform a search for the vector of maximum values over an axis of a 2D Numpy Array 

\begin{lstlisting}
def maxaxis(s):
\end{lstlisting}

\subsection{Function {\it minaxis}}
Perform a search for the vector of minimum values over an axis of a 2D Numpy Array 

\begin{lstlisting}
def minaxis(s):
\end{lstlisting}

\subsection{Function {\it covar}}
Calculate the Covariance of two arrays of numbers. TODO: check that this works well for Numpy Arrays and add NUMBA function signature to code. Do test of timings against Numpy. 

\begin{lstlisting}
def covar(a,b):
\end{lstlisting}

\subsection{Function {\it pairGCD}}
Determine the Greatest Common Divisor of two integers using Euclidsalgorithm. TODO - compare this with math.gcd(a,b) for speed. Also examine to see if I should not be declaring inputs as integers for NUMBA. 

\begin{lstlisting}
def pairGCD(v1,v2):
\end{lstlisting}

\subsection{Function {\it nprime}}
Calculate the first derivative of the Cumulative Normal CDF which is simply the PDF of the Normal Distribution 

\begin{lstlisting}
def nprime(x):
\end{lstlisting}

\subsection{Function {\it heaviside}}


\begin{lstlisting}
def heaviside(x):
\end{lstlisting}

\subsection{Function {\it frange}}
def frange(start, stop, step):

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\subsection{Function {\it normpdf}}


\begin{lstlisting}
def normpdf(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_fast}}


\begin{lstlisting}
def normcdf_fast(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_integrate}}
Calculation of Normal Distribution CDF by simple integrationwhich can become exact in the limit of the number of steps tending towards infinity. This function is used for checking as it is slow since the number of integration steps is currently hardcoded to 10,000.

\begin{lstlisting}
def normcdf_integrate(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_slow}}
Calculation of Normal Distribution CDF accurate to 1d-15.This method is faster than integration but slower than other approximations.Reference: J.L. Schonfelder, Math Comp 32(1978), pp 1232-1240. 

\begin{lstlisting}
def normcdf_slow(z):
\end{lstlisting}

\subsection{Function {\it normcdf}}
This is the Normal CDF function which forks to one of three of the implemented approximations. This is based on the choice of the fast flag variable. A value of 1 is the fast routine, 2 is the slow and 3 is the even slower integration scheme. 

\begin{lstlisting}
def normcdf(x, fastFlag):
\end{lstlisting}

\subsection{Function {\it N}}
This is the shortcut to the default Normal CDF function and is currentlyhardcoded to the fastest of the implemented routines. This is the most widely used way to access the Normal CDF. 

\begin{lstlisting}
def N(x):
\end{lstlisting}

\subsection{Function {\it phi3}}
Bivariate Normal CDF function to upper limits $b1$ and $b2$ which uses integration to perform the innermost integral. This may need further refinement to ensure it is optimal as the current range of integration isfrom -7 and the integration steps are dx = 0.001. This may be excessive. 

\begin{lstlisting}
def phi3(b1, b2, b3, r12, r13, r23):
\end{lstlisting}

\subsection{Function {\it norminvcdf}}
This algorithm computes the inverse Normal CDF and is based on the algorithm found at (http:\#home.online.no/~pjacklam/notes/invnorm/)which is by John Herrero (3-Jan-03) 

\begin{lstlisting}
def norminvcdf(p):
\end{lstlisting}

\subsection{Function {\it M}}
def M(a,b,c):

\begin{lstlisting}
def M(a,b,c):
\end{lstlisting}

\subsection{Function {\it phi2}}


\begin{lstlisting}
def phi2( h1, hk, r ):
\end{lstlisting}

\subsection{Function {\it corrMatrixGenerator}}
Utility function to generate a full rank n x n correlation matrix with a flat correlation structure and value rho. 

\begin{lstlisting}
def corrMatrixGenerator(rho,n):
\end{lstlisting}

\newpage
\section{FinRateConverter}

\subsection{Class: FinRateConverter(object)}
class FinRateConverter(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.months}
\item{self.name}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it str}}
def str(self):

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinSchedule}

\subsection{Class: FinSchedule(object)}
A Schedule is a vector of dates generated according to ISDA standard rules which starts on the next date after the start date and runs up to an end date. Dates are adjusted to a provided calendar. The zeroth element is the PCD and the first element is the NCD 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_busDayAdjustType}
\item{self.\_calendarType}
\item{self.\_adjustedDates}
\item{self.\_endDate}
\item{self.\_startDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType = FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generate}}
Generate schedule of dates according to specified date generation rules and also adjust these dates for holidays according to the business day convention and the specified calendar. 

\begin{lstlisting}
    def generate(self):
\end{lstlisting}

\subsection{Class Method {\it print}}
Print out the details of the schedule and the actual dates. This can be used for providing transparency on schedule calculations. 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinStats}

\subsection{Function {\it mean}}


\begin{lstlisting}
def mean(x):
\end{lstlisting}

\subsection{Function {\it stdev}}


\begin{lstlisting}
def stdev(x):
\end{lstlisting}

\subsection{Function {\it stderr}}


\begin{lstlisting}
def stderr(x):
\end{lstlisting}

\subsection{Function {\it var}}


\begin{lstlisting}
def var(x):
\end{lstlisting}

\subsection{Function {\it moment}}


\begin{lstlisting}
def moment(x,m):
\end{lstlisting}

\subsection{Function {\it correlation}}


\begin{lstlisting}
def correlation(x1,x2):
\end{lstlisting}

\newpage
\section{FinTestCases}

\subsubsection{Enumerated Type: FinTestCaseMode}
\begin{itemize}
\item{SAVE\_TEST\_CASES}
\item{ANALYSE\_TEST\_CASES}
\item{DEBUG\_TEST\_CASES}
\end{itemize}

\subsection{Class: FinTestCases()}
Test case framework for FinancePy.- The basic step is that we generate a GOLDEN folder that creates an output file for each testcase which is assumed to be correct. This can be done by running the test cases Python file with the globalTestCaseMode flag set to FinTestCaseMode.SAVE\_TEST\_CASES.- The second step is that we change the value of globalTestCaseMode to FinTestCaseMode.ANALYSE\_TEST\_CASES and then run the test scripts. This time they save a copy of the output to the COMPARE folder. Finally, a function called compareTestCases() is used to compare the new output with the GOLDEN output and states whether anything has changed. - The output of a test case has three forms each with its own method:1) print - this outputs comma separated values 2) header - this must precede any print statement and labels the output columns3) banner - this is any single string line separatorNote that the header TIME is special as it tells the analysis that the value in the corresponding column is a timing and so its value is allowed to change without triggering an error. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_goldenFolder}
\item{self.\_headerFields}
\item{self.\_compareFilename)andself.\_carefulMode}
\item{self.\_moduleName}
\item{self.\_rootFolder}
\item{self.\_foldersExist}
\item{self.\_carefulMode}
\item{self.\_compareFilename}
\item{self.\_verbose}
\item{self.\_goldenFilename}
\item{self.\_goldenFilename)andself.\_carefulMode}
\item{self.\_compareFolder}
\item{self.\_mode}
\item{self.\_headerFields[colNum]}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create the TestCase given the module name and whether we are in GOLDEN or COMPARE mode. 

\begin{lstlisting}
    def __init__(self, moduleName, mode):
\end{lstlisting}

\subsection{Class Method {\it print}}


\begin{lstlisting}
    def print(self,*args):
\end{lstlisting}

\subsection{Class Method {\it banner}}


\begin{lstlisting}
    def banner(self,txt):
\end{lstlisting}

\subsection{Class Method {\it header}}


\begin{lstlisting}
    def header(self,*args):
\end{lstlisting}

\subsection{Class Method {\it compareRows}}


\begin{lstlisting}
    def compareRows(self,goldenRow,compareRow,rowNum):
\end{lstlisting}

\subsection{Class Method {\it compareTestCases}}


\begin{lstlisting}
    def compareTestCases(self):
\end{lstlisting}


\chapter{..//products//equities}
\section{Introduction}
This folder covers a range of equity derivative products. These range from simple Vanilla-style options to more complex payoffs and path-dependent options. 
\newpage
\section{FinAmericanOption}

\subsection{Class: FinAmericanOption()}
Class that performs the valuation of an American style option on a dividend paying stock. Can easily be extended to price American style FX options. The dividend is assumed to be continuous. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\item{self.\_strikePrice}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
             expiryDate,
             strikePrice,
             optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
numSteps = 100):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              numSteps = 100):
\end{lstlisting}

\subsection{Function {\it valueOnce}}


\begin{lstlisting}
def valueOnce(stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              numSteps,
              timeToExpiry,
              optionType,
              strikePrice):
\end{lstlisting}

\newpage
\section{FinAsianOption}

\subsection{Class: FinAsianOption(FinOption)}
class FinAsianOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_optionType}
\item{self.\_strikePrice}
\item{self.\_startAveragingDate}
\item{self.\_expiryDate}
\item{self.\_numObservations}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
numberOfObservations = 0):

\begin{lstlisting}
   def __init__(self,
                 startAveragingDate,
                 expiryDate,
                 strikePrice,
                 optionType,
                 numberOfObservations = 0):
\end{lstlisting}

\subsection{Class Method {\it value}}
accruedAverage = None):

\begin{lstlisting}
   def value(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              valuationMethod,
              accruedAverage = None):
\end{lstlisting}

\subsection{Class Method {\it valueGeometric}}
accruedAverage):

\begin{lstlisting}
   def valueGeometric(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueCurran}}
accruedAverage):

\begin{lstlisting}
   def valueCurran(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMilevskyPosner}}
\#               accruedAverage):

\begin{lstlisting}
#    def valueMilevskyPosner(self,
#               valueDate,
#               stockPrice,
#               dividendYield,
#               volatility,
#               interestRate,
#               accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueTurnbullWakeman}}
accruedAverage):

\begin{lstlisting}
   def valueTurnbullWakeman(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueLevy}}
\#               accruedAverage):

\begin{lstlisting}
#    def valueLevy(self,
#               valueDate,
#               stockPrice,
#               dividendYield,
#               volatility,
#               interestRate,
#               accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
accruedAverage):

\begin{lstlisting}
   def valueMC(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              numPaths,
              seed,
              accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC\_fast}}
accruedAverage):

\begin{lstlisting}
   def valueMC_fast(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              numPaths,
              seed,
              accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC\_fast\_CV}}
accruedAverage):

\begin{lstlisting}
   def valueMC_fast_CV(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              numPaths,
              seed,
              accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_NUMBA}}
accruedAverage):

\begin{lstlisting}
def valueMC_NUMBA(t0,t,tau, K,n, optionType,
      stockPrice,
      dividendYield,
      volatility,
      interestRate,
      numPaths,
      seed,
      accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_fast\_NUMBA}}
accruedAverage):

\begin{lstlisting}
def valueMC_fast_NUMBA(t0, t, tau, K, n, optionType,
      stockPrice,
      dividendYield,
      volatility,
      interestRate,
      numPaths,
      seed,
      accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_fast\_CV\_NUMBA}}
v\_g\_exact):

\begin{lstlisting}
def valueMC_fast_CV_NUMBA(t0, t, tau, K, n, optionType,
      stockPrice,
      dividendYield,
      volatility,
      interestRate,
      numPaths,
      seed,
      accruedAverage, 
      v_g_exact):
\end{lstlisting}

\newpage
\section{FinBarrierOption}

\subsubsection{Enumerated Type: FinBarrierTypes}
\begin{itemize}
\item{DOWN\_AND\_OUT\_CALL}
\item{DOWN\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_CALL}
\item{UP\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_PUT}
\item{UP\_AND\_IN\_PUT}
\item{DOWN\_AND\_OUT\_PUT}
\item{DOWN\_AND\_IN\_PUT}
\end{itemize}

\subsection{Class: FinBarrierOption(FinOption)}
class FinBarrierOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_optionType}
\item{self.\_numObservationsPerYear}
\item{self.\_strikePrice}
\item{self.\_expiryDate}
\item{self.\_barrierLevel}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
barrierLevel, numObservationsPerYear ):

\begin{lstlisting}
    def __init__ (self, expiryDate, strikePrice, optionType, 
                  barrierLevel, numObservationsPerYear ):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):

\begin{lstlisting}
    def value(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
numAnnSteps = 252, numPaths = 10000, seed = 4242 ):

\begin{lstlisting}
    def valueMC(self, valueDate, stockPrice, interestRate, processType, modelParams, 
                numAnnSteps = 252, numPaths = 10000, seed = 4242 ):
\end{lstlisting}

\newpage
\section{FinBasketOption}

\subsection{Class: FinBasketOption(FinOption)}
class FinBasketOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\item{self.\_numAssets}
\item{self.\_strikePrice}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
numAssets ):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate,
                  strikePrice,
                  optionType,
                  numAssets ):
\end{lstlisting}

\subsection{Class Method {\it validate}}
betas):

\begin{lstlisting}
    def validate(self, 
                 stockPrices,
                 dividendYields,
                 volatilities, 
                 betas):
\end{lstlisting}

\subsection{Class Method {\it value}}
betas):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrices,
              interestRate,
              dividendYields,
              volatilities, 
              betas):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed = 4242):

\begin{lstlisting}
    def valueMC(self,
              valueDate,
              stockPrices,
              interestRate,
              dividendYields,
              volatilities,
              betas,
              numPaths = 10000,
              seed = 4242):
\end{lstlisting}

\newpage
\section{FinBinomialTree}

\subsubsection{Enumerated Type: FinTreePayoffTypes}
\begin{itemize}
\item{FWD\_CONTRACT}
\item{VANILLA\_OPTION}
\item{DIGITAL\_OPTION}
\item{POWER\_CONTRACT}
\item{POWER\_OPTION}
\item{LOG\_CONTRACT}
\item{LOG\_OPTION}
\end{itemize}

\subsubsection{Enumerated Type: FinTreeExerciseTypes}
\begin{itemize}
\item{EUROPEAN}
\item{AMERICAN}
\end{itemize}

\subsection{Class: FinBinomialTree()}
class FinBinomialTree():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.m\_optionValues}
\item{self.m\_numSteps}
\item{self.m\_numNodes}
\item{self.m\_stockValues}
\item{self.m\_upProbabilities}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it value}}
payoffParams):

\begin{lstlisting}
    def value(self,
              stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              numSteps,
              valueDate,
              payoff,
              expiryDate,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\subsection{Function {\it validatePayoff}}
def validatePayoff(payoffType,payoffParams):

\begin{lstlisting}
def validatePayoff(payoffType,payoffParams):
\end{lstlisting}

\subsection{Function {\it payoffValue}}
def payoffValue(s,payoffType,payoffParams):

\begin{lstlisting}
def payoffValue(s,payoffType,payoffParams):
\end{lstlisting}

\subsection{Function {\it valueOnce}}
payoffParams):

\begin{lstlisting}
def valueOnce(stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              numSteps,
              timeToExpiry,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\newpage
\section{FinBlack}

\subsection{Class: BlackModel()}
class BlackModel():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it value}}
callOrPut):

\begin{lstlisting}
    def value(forwardRate,
              strikeRate,
              timeToExpiry,
              sigma,
              callOrPut):
\end{lstlisting}

\newpage
\section{FinCompoundOption}

\subsection{Class: FinCompoundOption(FinOption)}
class FinCompoundOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate2}
\item{self.\_optionType2}
\item{self.\_expiryDate1}
\item{self.\_strikePrice2}
\item{self.\_optionType1}
\item{self.\_strikePrice1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
optionType2 ):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate1,
                  expiryDate2,
                  strikePrice1,
                  strikePrice2,
                  optionType1,
                  optionType2 ):
\end{lstlisting}

\subsection{Class Method {\it value}}
volatility):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              volatility):
\end{lstlisting}

\subsection{Class Method {\it valueTree}}
numSteps = 200):

\begin{lstlisting}
    def valueTree(self,
              valueDate,
              stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              numSteps = 200):
\end{lstlisting}

\subsection{Class Method {\it impliedStockPrice}}
volatility):

\begin{lstlisting}
    def impliedStockPrice(self,
              stockPrice,
              expiryDate1,
              expiryDate2,
              strikePrice1, 
              strikePrice2, 
              optionType2,
              interestRate, 
              dividendYield, 
              volatility):
\end{lstlisting}

\subsection{Function {\it f}}
def f(s0, *args):

\begin{lstlisting}
def f(s0, *args):
\end{lstlisting}

\subsection{Function {\it valueOnce}}
numSteps):

\begin{lstlisting}
def valueOnce(stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              t1,
              t2,
              optionType1,
              optionType2,
              k1,
              k2,
              numSteps):
\end{lstlisting}

\newpage
\section{FinDigitalOption}

\subsection{Class: FinDigitalOption(FinOption)}
class FinDigitalOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\item{self.\_strikePrice}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
optionType ):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate,
                  strikePrice,
                  optionType ):
\end{lstlisting}

\subsection{Class Method {\it value}}
interestRate):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed = 4242):

\begin{lstlisting}
    def valueMC(self,
              valueDate,
              stockPrice,
              dividendYield,
              volatility,
              interestRate,
              numPaths = 10000,
              seed = 4242):
\end{lstlisting}

\newpage
\section{FinFixedStrikeLookbackOption}

\subsubsection{Enumerated Type: FinFixedStrikeLookbackOptionTypes}
\begin{itemize}
\item{FIXED\_CALL}
\item{FIXED\_PUT}
\end{itemize}

\subsection{Class: FinFixedStrikeLookbackOption(FinOption)}
class FinFixedStrikeLookbackOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\item{self.\_optionStrike}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
optionStrike):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate,
                  optionType, 
                  optionStrike):
\end{lstlisting}

\subsection{Class Method {\it value}}
stockMinMax):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              volatility, 
              stockMinMax):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
stockMinMax, numPaths = 10000, numStepsPerYear = 252, seed = 4242 ):

\begin{lstlisting}
    def valueMC(self, valueDate, stockPrice, interestRate, dividendYield, volatility, 
                stockMinMax, numPaths = 10000, numStepsPerYear = 252, seed = 4242 ):
\end{lstlisting}

\newpage
\section{FinFloatStrikeLookbackOption}

\subsubsection{Enumerated Type: FinFloatStrikeLookbackOptionTypes}
\begin{itemize}
\item{FLOATING\_CALL}
\item{FLOATING\_PUT}
\end{itemize}

\subsection{Class: FinFloatStrikeLookbackOption(FinOption)}
class FinFloatStrikeLookbackOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
optionType ):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate,
                  optionType ):
\end{lstlisting}

\subsection{Class Method {\it value}}
stockMinMax):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              volatility, 
              stockMinMax):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
stockMinMax, numPaths = 10000, numStepsPerYear = 252, seed = 4242 ):

\begin{lstlisting}
    def valueMC(self, valueDate, stockPrice, interestRate, dividendYield, volatility, 
                stockMinMax, numPaths = 10000, numStepsPerYear = 252, seed = 4242 ):
\end{lstlisting}

\newpage
\section{FinOption}

\subsubsection{Enumerated Type: FinOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\item{AMERICAN\_CALL}
\item{AMERICAN\_PUT}
\item{DIGITAL\_CALL}
\item{DIGITAL\_PUT}
\item{ASIAN\_CALL}
\item{ASIAN\_PUT}
\item{COMPOUND\_CALL}
\item{COMPOUND\_PUT}
\end{itemize}

\subsubsection{Enumerated Type: FinOptionModelTypes}
\begin{itemize}
\item{BLACKSCHOLES}
\item{ANOTHER}
\end{itemize}

\subsection{Class: FinOption(object)}
class FinOption(object):

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it delta}}
def delta(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):

\begin{lstlisting}
    def delta(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):
\end{lstlisting}

\subsection{Class Method {\it gamma}}
def gamma(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):

\begin{lstlisting}
    def gamma(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):
\end{lstlisting}

\subsection{Class Method {\it vega}}
def vega(self, valueDate, stockPrice, interestRate, dividendYield, volatility):

\begin{lstlisting}
    def vega(self, valueDate, stockPrice, interestRate, dividendYield, volatility):
\end{lstlisting}

\subsection{Class Method {\it theta}}
def theta(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):

\begin{lstlisting}
    def theta(self, valueDate, stockPrice, interestRate, dividendYield, volatility ):
\end{lstlisting}

\subsection{Class Method {\it rho}}
def rho(self, valueDate, stockPrice, interestRate, dividendYield, volatility):

\begin{lstlisting}
    def rho(self, valueDate, stockPrice, interestRate, dividendYield, volatility):
\end{lstlisting}

\newpage
\section{FinRainbowOption}

\subsubsection{Enumerated Type: FinRainbowOptionTypes}
\begin{itemize}
\item{CALL\_ON\_MAXIMUM}
\item{PUT\_ON\_MAXIMUM}
\item{CALL\_ON\_MINIMUM}
\item{PUT\_ON\_MINIMUM}
\item{CALL\_ON\_NTH}
\item{PUT\_ON\_NTH}
\end{itemize}

\subsection{Class: FinRainbowOption(FinOption)}
class FinRainbowOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_numAssets}
\item{self.\_payoffParams}
\item{self.\_payoffType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_ }}
numAssets ):

\begin{lstlisting}
    def __init__ (self,
                  expiryDate,
                  payoffType,
                  payoffParams,
                  numAssets ):
\end{lstlisting}

\subsection{Class Method {\it validate}}
betas):

\begin{lstlisting}
    def validate(self, 
                 stockPrices,
                 dividendYields,
                 volatilities, 
                 betas):
\end{lstlisting}

\subsection{Class Method {\it validatePayoff}}
def validatePayoff(self,payoffType,payoffParams,numAssets):

\begin{lstlisting}
    def validatePayoff(self,payoffType,payoffParams,numAssets):
\end{lstlisting}

\subsection{Class Method {\it value}}
dividendYields, volatilities, betas):

\begin{lstlisting}
    def value(self, valueDate, expiryDate, stockPrices, interestRate,
              dividendYields, volatilities, betas):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed = 4242):

\begin{lstlisting}
    def valueMC(self, 
                valueDate,
                expiryDate,
                stockPrices,
                interestRate,
                dividendYields,
                volatilities,
                betas,
                numPaths = 10000,
                seed = 4242):
\end{lstlisting}

\subsection{Function {\it payoffValue}}
def payoffValue(s,payoffTypeValue,payoffParams):

\begin{lstlisting}
def payoffValue(s,payoffTypeValue,payoffParams):
\end{lstlisting}

\subsection{Function {\it valueMCFast}}
seed = 4242):

\begin{lstlisting}
def valueMCFast(t,
          stockPrices,
          interestRate,
          dividendYields,
          volatilities,
          betas,
          numAssets,
          payoffType,
          payoffParams,
          numPaths = 10000,
          seed = 4242):
\end{lstlisting}

\newpage
\section{FinVanillaOption}

\subsection{Class: FinVanillaOption(FinOption)}
class FinVanillaOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\item{self.\_strikePrice}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
modelParams):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType,
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it delta}}
modelParams):

\begin{lstlisting}
    def delta(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType,
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it gamma}}
modelParams):

\begin{lstlisting}
    def gamma(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType,
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it vega}}
modelParams):

\begin{lstlisting}
    def vega(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType,
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it theta}}
modelParams):

\begin{lstlisting}
    def theta(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType,
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it impliedVolatility}}
price):

\begin{lstlisting}
    def impliedVolatility(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              price):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed = 4242):

\begin{lstlisting}
    def valueMC(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              modelType, 
              modelParams,
              numPaths = 10000,
              seed = 4242):
\end{lstlisting}

\subsection{Class Method {\it value\_MC\_OLD}}
seed = 4242):

\begin{lstlisting}
    def value_MC_OLD(self,
              valueDate,
              stockPrice,
              interestRate,
              dividendYield,
              terminalS,
              seed = 4242):
\end{lstlisting}

\subsection{Function {\it f}}
def f(volatility, *args):

\begin{lstlisting}
def f(volatility, *args):
\end{lstlisting}

\subsection{Function {\it fvega}}
def fvega(volatility, *args):

\begin{lstlisting}
def fvega(volatility, *args):
\end{lstlisting}

\newpage
\section{FinVarianceSwap}


\chapter{..//products//credit}
\section{Introduction}
This folder contains a set of credit-related assets ranging from CDS to CDS options, to CDS indices, CDS index options and then to CDS tranches. 
\newpage
\section{FinCDS}

\subsection{Class: FinCDS(object)}
A class which manages Credit Default Swap. It performs schedule generation and the valuation and risk management of CDS. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_adjustedDates[flowNum-1]}
\item{self.\_adjustedDates}
\item{self.\_frequencyType}
\item{self.\_coupon}
\item{self.\_busDayAdjustType}
\item{self.\_accrualFactors}
\item{self.\_adjustedDates[i]}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_flows}
\item{self.\_stepInDate}
\item{self.\_dayCountType}
\item{self.\_longProtection}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
stepInDate - FinDate that is the date protection starts (usually T+1) runningCoupon - Size of coupon on premium leg 

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 runningCoupon,
                 notional = ONE_MILLION,
                 longProtection = True,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generateAdjustedCDSPaymentDates}}


\begin{lstlisting}
    def generateAdjustedCDSPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it calcFlows}}


\begin{lstlisting}
    def calcFlows(self):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self,
              valuationDate,
              issuerCurve,
              contractRecovery = standardRecovery,
              pv01Method = 0,
              prot_method = 0,
              numStepsPerYear = 25):
\end{lstlisting}

\subsection{Class Method {\it cashSettlementAmount}}
numStepsPerYear = 25):

\begin{lstlisting}
    def cashSettlementAmount(self,
                             valuationDate,
                             settlementDate,
                             issuerCurve,
                             contractRecovery = standardRecovery,
                             pv01Method = 0,
                             prot_method = 0,
                             numStepsPerYear = 25):
\end{lstlisting}

\subsection{Class Method {\it cleanPrice}}
numStepsPerYear = 52):

\begin{lstlisting}
    def cleanPrice(self,
                   valuationDate,
                   issuerCurve,
                   contractRecovery = standardRecovery,
                   pv01Method = 0,
                   prot_method = 0,
                   numStepsPerYear = 52):
\end{lstlisting}

\subsection{Class Method {\it riskyPV01\_OLD}}
pv01Method = 0):

\begin{lstlisting}
    def riskyPV01_OLD(self,
                  valuationDate,
                  issuerCurve,
                  pv01Method = 0):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}
def accruedDays(self):

\begin{lstlisting}
    def accruedDays(self):
\end{lstlisting}

\subsection{Class Method {\it accruedInterest}}
Calculate the amount of accrued interest that has accrued from the previous coupon date (PCD) to the stepInDate of the CDS contract. 

\begin{lstlisting}
    def accruedInterest(self):
\end{lstlisting}

\subsection{Class Method {\it protectionLegPV}}
Calculates the protection leg PV of the CDS by calling into the fast NUMBA code that has been defined above. 

\begin{lstlisting}
    def protectionLegPV(self,
                        valuationDate,
                        issuerCurve,
                        contractRecovery = standardRecovery,
                        numStepsPerYear = 25,
                        protMethod = 0):
\end{lstlisting}

\subsection{Class Method {\it riskyPV01}}
pv01Method = 0):

\begin{lstlisting}
    def riskyPV01(self,
                     valuationDate,
                     issuerCurve,
                     pv01Method = 0):
\end{lstlisting}

\subsection{Class Method {\it premiumLegPV}}
pv01Method = 0):

\begin{lstlisting}
    def premiumLegPV(self,
                     valuationDate,
                     issuerCurve,
                     pv01Method = 0):
\end{lstlisting}

\subsection{Class Method {\it parSpread}}
protMethod = 0):

\begin{lstlisting}
    def parSpread(self,
                  valuationDate,
                  issuerCurve,
                  contractRecovery = standardRecovery,
                  numStepsPerYear = 25,
                  pv01Method = 0,
                  protMethod = 0):
\end{lstlisting}

\subsection{Class Method {\it valueFastApprox}}
Implementation of fast valuation of the CDS contract using an accurate approximation that avoids curve building. 

\begin{lstlisting}
    def valueFastApprox(self,
                        valuationDate,
                        flatContinuousInterestRate,
                        flatCDSCurveSpread,
                        curveRecovery = standardRecovery,
                        contractRecovery = standardRecovery):
\end{lstlisting}

\subsection{Class Method {\it print}}
print out details of the CDS contract and all of the calculated cashflows 

\begin{lstlisting}
    def print(self, valuationDate):
\end{lstlisting}

\subsection{Class Method {\it printFlows}}
def printFlows(self, issuerCurve):

\begin{lstlisting}
    def printFlows(self, issuerCurve):
\end{lstlisting}

\subsection{Function {\it riskyPV01\_NUMBA}}
Fast calculation of the risky PV01 of a CDS using NUMBA. The output is anumpy array of the full and clean risky PV01.

\begin{lstlisting}
def riskyPV01_NUMBA(teff, 
                    accrualFactorPCDToNow,
                    paymentTimes,
                    yearFracs,
                    npLiborTimes,
                    npLiborValues,
                    npSurvTimes,
                    npSurvValues,
                    pv01Method):
\end{lstlisting}

\subsection{Function {\it protectionLegPV\_NUMBA}}
Fast calculation of the CDS protection leg PV using NUMBA to speed up the numerical integration over time. 

\begin{lstlisting}
def protectionLegPV_NUMBA(teff,
                          tmat,
                          npLiborTimes,
                          npLiborValues,
                          npSurvTimes,
                          npSurvValues,
                          contractRecovery,
                          numStepsPerYear,
                          protMethod):
\end{lstlisting}

\newpage
\section{FinCDSBasket}

\subsection{Class: FinCDSBasket(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_coupon}
\item{self.\_busDayAdjustType}
\item{self.\_cdsContract}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_stepInDate}
\item{self.\_dayCountType}
\item{self.\_longProtection}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self, 
                 stepInDate,
                 maturityDate, 
                 notional = ONE_MILLION, 
                 coupon = 0.0, 
                 longProtection = True,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueLegs\_MC}}
Value the legs of the default basket using Monte Carlo. The default times are an input so this valuation is not model dependent. 

\begin{lstlisting}
    def valueLegs_MC(self, 
                     valuationDate,
                     nToDefault,
                     defaultTimes, 
                     issuerCurves,
                     liborCurve):
\end{lstlisting}

\subsection{Class Method {\it valueGaussian\_MC}}


\begin{lstlisting}
    def valueGaussian_MC(self, 
                      valuationDate,
                      nToDefault,
                      issuerCurves,
                      correlationMatrix,
                      liborCurve,
                      numTrials,
                      seed):
\end{lstlisting}

\subsection{Class Method {\it valueStudentT\_MC}}


\begin{lstlisting}
    def valueStudentT_MC(self, 
                      valuationDate,
                      nToDefault,
                      issuerCurves,
                      correlationMatrix,
                      degreesOfFreedom,
                      liborCurve,
                      numTrials,
                      seed):
\end{lstlisting}

\subsection{Class Method {\it value1FGaussian\_Homo}}
Value default basket using 1 factor Gaussian copula and analytical approach which is only exact when all recovery rates are the same. 

\begin{lstlisting}
    def value1FGaussian_Homo(self, 
                             valuationDate,
                             nToDefault,
                             issuerCurves, 
                             betaVector, 
                             liborCurve,
                             numPoints = 50):
\end{lstlisting}

\newpage
\section{FinCDSIndexOption}

\subsection{Class: FinCDSIndexOption(object)}
Class to manage the pricing and risk management of an option to enter into a CDS index. Different pricing algorithms are presented. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_cdsContract}
\item{self.\_expiryDate}
\item{self.\_strikeCoupon}
\item{self.\_maturityDate}
\item{self.\_indexCoupon}
\item{self.\_calendarType}
\item{self.\_businessDateAdjustType}
\item{self.\_dayCountType}
\item{self.\_longProtection}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 maturityDate,
                 indexCoupon,
                 strikeCoupon,
                 notional = ONE_MILLION,
                 longProtection = True,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueAdjustedBlack}}
This approach uses two adjustments to Blacks option pricing model to value an option on a CDS index. 

\begin{lstlisting}
    def valueAdjustedBlack(self, 
                           valuationDate, 
                           indexCurve, 
                           indexRecovery,
                           liborCurve,
                           sigma):
\end{lstlisting}

\subsection{Class Method {\it valueAnderson}}
This function values a CDS index option following approach by Anderson (2006). This ensures that the no-arbitrage relationship between the consituent CDS contract and the CDS index is enforced. It models the forward spread as a log-normally distributed quantity and uses the credit triangle to compute the forward RPV01. 

\begin{lstlisting}
    def valueAnderson(self,
                      valuationDate,
                      issuerCurves,
                      indexRecovery,
                      sigma):
\end{lstlisting}

\subsection{Class Method {\it solveForX}}


\begin{lstlisting}
    def solveForX(self,
                   valuationDate,
                   sigma,
                   indexCoupon,
                   indexRecovery,
                   liborCurve,
                   expH):
\end{lstlisting}

\subsection{Class Method {\it calcObjFunc}}


\begin{lstlisting}
    def calcObjFunc(self,
                    x,
                    valuationDate,
                    sigma,
                    indexCoupon,
                    indexRecovery,
                    liborCurve):
\end{lstlisting}

\subsection{Class Method {\it calcIndexPayerOptionPrice}}
Calculates the intrinsic value of the index payer swap and the value of the index payer option which are both returned in an array. 

\begin{lstlisting}
    def calcIndexPayerOptionPrice(self, 
                                  valuationDate,
                                  x,
                                  sigma,
                                  indexCoupon,
                                  strikeValue,
                                  liborCurve,
                                  indexRecovery):
\end{lstlisting}

\newpage
\section{FinCDSIndexPortfolio}

\subsection{Class: FinCDSIndexPortfolio()}
This class manages the calculations associated with an equally weighted portfolio of CDS contracts with the same maturity date. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_businessDateAdjustType}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it intrinsicRPV01}}
Calculation of the risky PV01 of the CDS porfolio by taking the average of the risky PV01s of each contract. 

\begin{lstlisting}
    def intrinsicRPV01(self,
                       valuationDate,
                       stepInDate,
                       maturityDate,
                       issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it intrinsicProtectionLegPV}}
Calculation of the intrinsic protection leg value of the CDS porfolio by taking the average sum the protection legs of each contract. 

\begin{lstlisting}
    def intrinsicProtectionLegPV(self,
                                 valuationDate,
                                 stepInDate,
                                 maturityDate,
                                 issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it intrinsicSpread}}
Calculation of the intrinsic spread of the CDS portfolio as the one which would make the value of the protection legs equal to the value of the premium legs if all premium legs paid the same spread. 

\begin{lstlisting}
    def intrinsicSpread(self, 
                        valuationDate,
                        stepInDate,
                        maturityDate,
                        issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it averageSpread}}


\begin{lstlisting}
    def averageSpread(self, 
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it totalSpread}}
Calculates the total CDS spread of the CDS portfolio. TODO: DO I NEED THIS ? 

\begin{lstlisting}
    def totalSpread(self, 
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it minSpread}}


\begin{lstlisting}
    def minSpread(self, 
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it maxSpread}}


\begin{lstlisting}
    def maxSpread(self, 
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it spreadAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices. This approach uses an iterative scheme but is slow as it has to use aCDS curve bootstrap required when each trial spread adjustment is made.

\begin{lstlisting}
    def spreadAdjustIntrinsic(valuationDate,
                              issuerCurves,
                              indexCoupons,
                              indexUpfronts,
                              indexMaturityDates,
                              indexRecoveryRate,
                              tolerance):
\end{lstlisting}

\subsection{Class Method {\it hazardRateAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices. This approach adjusts the hazard rates and so avoids the slowish CDS curve bootstrap required when a spread adjustment is made.

\begin{lstlisting}
    def hazardRateAdjustIntrinsic(valuationDate, 
                                  issuerCurves,
                                  indexCoupons,
                                  indexUpfronts,
                                  indexMaturityDates,
                                  indexRecoveryRate,
                                  tolerance,
                                  maxIterations = 100):
\end{lstlisting}

\newpage
\section{FinCDSOption}

\subsection{Class: FinCDSOption()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_notional}
\item{self.\_frequencyType}
\item{self.\_expiryDate}
\item{self.\_strikeCoupon}
\item{self.\_businessDateAdjustType}
\item{self.\_calendarType}
\item{self.\_knockoutFlag}
\item{self.\_dayCountType}
\item{self.\_longProtection}
\item{self.\_maturityDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self, 
                 expiryDate,
                 maturityDate,
                 strikeCoupon,
                 notional = ONE_MILLION,
                 longProtection = True,
                 knockoutFlag = True,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the CDS option using Blacks model with an adjustment for any Front End Protection. TODO - Should the CDS be created in the init method ? 

\begin{lstlisting}
    def value(self, 
              valuationDate,
              issuerCurve,
              volatility):
\end{lstlisting}

\subsection{Class Method {\it impliedVolatility}}


\begin{lstlisting}
    def impliedVolatility(self,
              valuationDate,
              issuerCurve,
              optionValue):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(volatility, *args):
\end{lstlisting}

\newpage
\section{FinCDSTranche}

\subsubsection{Enumerated Type: FinLossDistributionBuilder}
\begin{itemize}
\item{RECURSION}
\item{ADJUSTED\_BINOMIAL}
\item{GAUSSIAN}
\item{LHP}
\end{itemize}

\subsection{Class: FinCDSTranche(object)}
class FinCDSTranche(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_coupon}
\item{self.\_busDayAdjustType}
\item{self.\_cdsContract}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_k2}
\item{self.\_k1}
\item{self.\_stepInDate}
\item{self.\_dayCountType}
\item{self.\_longProtection}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self, 
                 stepInDate,
                 maturityDate, 
                 k1, 
                 k2, 
                 notional = ONE_MILLION, 
                 coupon = 0.0, 
                 longProtection = True,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueBC}}
model = FinLossDistributionBuilder.RECURSION ):

\begin{lstlisting}
    def valueBC(self, 
                valuationDate,
                issuerCurves,
                upfront,
                coupon,
                corr1,
                corr2,
                numPoints = 50,
                model = FinLossDistributionBuilder.RECURSION ):
\end{lstlisting}


\chapter{..//products//bonds}
\section{Introduction}
This folder contains a suite of bond-related functionality. It includes a basic fixed coupon bond with all of the associated duration and convexity measures. In addition it includes floating rate bonds and credit risky bonds. There will also be coverage for convertible bonds although this has not been implemented as yet.

\newpage
\section{FinAnnuity}

\subsection{Class: FinAnnuity(object)}
class FinAnnuity(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_frequencyType}
\item{self.\_busDayAdjustType}
\item{self.\_dayCountConventionType}
\item{self.\_yearFractions}
\item{self.\_calendarType}
\item{self.\_flows}
\item{self.\_schedule}
\item{self.\_endDate}
\item{self.\_startDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dayCountConventionType = FinDayCountTypes.ACT\_360):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType = FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD, 
                 dayCountConventionType = FinDayCountTypes.ACT_360):
\end{lstlisting}

\subsection{Class Method {\it generate}}
def generate(self,startDate):

\begin{lstlisting}
    def generate(self,startDate):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinBond}

\subsubsection{Enumerated Type: FinBondAccruedTypes}
\begin{itemize}
\item{THIRTY\_360}
\item{THIRTY\_360\_BOND}
\item{ACT\_360}
\item{ACT\_365}
\item{ACT\_ACT}
\end{itemize}

\subsection{Class: FinBond(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_redemption}
\item{self.\_frequencyType}
\item{self.\_coupon}
\item{self.\_frequency}
\item{self.\_settlementDate}
\item{self.\_accrualType}
\item{self.\_flowDates}
\item{self.\_face}
\item{self.\_maturityDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create FinBond object by providing Maturity Date, Frequency, coupon and the accrual convention type. 

\begin{lstlisting}
    def __init__(self, 
                 maturityDate, 
                 coupon, 
                 frequencyType, 
                 accrualType,
                 face = 100.0,
                 redemption = 1.0):
\end{lstlisting}

\subsection{Class Method {\it calculateFlowDates}}


\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromYield}}


\begin{lstlisting}
    def fullPriceFromYield(self, settlementDate, ytm ):
\end{lstlisting}

\subsection{Class Method {\it dollarDuration}}


\begin{lstlisting}
    def dollarDuration(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement date given its yield to maturity. 

\begin{lstlisting}
    def macauleyDuration(self,settlementDate,ytm):
\end{lstlisting}

\subsection{Class Method {\it modifiedDuration}}
Calculate the modified duration of the bondon a settlement date given its yield to maturity. 

\begin{lstlisting}
    def modifiedDuration(self,settlementDate,ytm):
\end{lstlisting}

\subsection{Class Method {\it convexityFromYield}}


\begin{lstlisting}
    def convexityFromYield(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it cleanPriceFromYield}}


\begin{lstlisting}
    def cleanPriceFromYield(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-value the bonds cashflows. 

\begin{lstlisting}
    def fullPriceFromDiscountCurve( self, settlementDate, discountCurve ):
\end{lstlisting}

\subsection{Class Method {\it currentYield}}
Calculate the current yield of the bond which is the coupon divided by the clean price (not the full price)

\begin{lstlisting}
    def currentYield(self, cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it yieldToMaturity}}
Calculate the bonds yield to maturity by solving the price yield relationship using a one-dimensional root solver. 

\begin{lstlisting}
    def yieldToMaturity(self, settlementDate, cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}


\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it pcd}}


\begin{lstlisting}
    def pcd(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it accruedInterest}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date. 

\begin{lstlisting}
    def accruedInterest(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it initialPeriodFraction}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date. 

\begin{lstlisting}
    def initialPeriodFraction(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it assetSwapSpread}}
Calculate the par asset swap spread of the bond. The discount curve is a Libor quality curve that is passed in. The price is the clean price. TODO - Check how first coupon on floating leg is sized. 

\begin{lstlisting}
    def assetSwapSpread(self, 
                        settlementDate, 
                        cleanPrice, 
                        discountCurve, 
                        swapFloatDayCountConventionType = FinDayCountTypes.ACT_360, 
                        swapFloatFrequencyType = FinFrequencyTypes.SEMI_ANNUAL,
                        swapFloatCalendarType = FinCalendarTypes.WEEKEND,
                        swapFloatBusDayAdjustRuleType = FinBusDayConventionTypes.FOLLOWING,
                        swapFloatDateGenRuleType = FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromOAS}}
Calculate the full price of the bond from its OAS given the bond settlement date, a discount curve and the oas as a number. 

\begin{lstlisting}
    def fullPriceFromOAS(self, 
                         settlementDate, 
                         discountCurve, 
                         oas):
\end{lstlisting}

\subsection{Class Method {\it optionAdjustedSpread}}
Return OAS for bullet bond given settlement date, clean bond price and the discount relative to which the spread is to be computed. 

\begin{lstlisting}
    def optionAdjustedSpread(self, 
                             settlementDate, 
                             cleanPrice, 
                             discountCurve):
\end{lstlisting}

\subsection{Class Method {\it printFlows}}
Print a list of the unadjusted coupon payment dates used in analytic calculations for the bond. 

\begin{lstlisting}
    def printFlows(self,settlementDate):
\end{lstlisting}

\subsection{Class Method {\it priceFromSurvivalCurve}}
Calculate discounted present value of flows assuming default model. This has not been completed. 

\begin{lstlisting}
    def priceFromSurvivalCurve(self, 
                               discountCurve, 
                               survivalCurve, 
                               recoveryRate):
\end{lstlisting}

\subsection{Class Method {\it print}}
Print a list of the unadjusted coupon payment dates used in analytic calculations for the bond. 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(y, *args):
\end{lstlisting}

\subsection{Function {\it g}}


\begin{lstlisting}
def g(oas, *args):
\end{lstlisting}

\newpage
\section{FinBondCallable}

\newpage
\section{FinBondConvertible}

\newpage
\section{FinBondFuture}

\subsection{Class: FinBondFuture(object)}
Class for managing futures contracts on government bonds that follows CME conventions and related analytics. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_lastDeliveryDate}
\item{self.\_contractSize}
\item{self.\_coupon}
\item{self.\_tickerName}
\item{self.\_firstDeliveryDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
coupon):

\begin{lstlisting}
    def __init__(self,
                 tickerName,
                 firstDeliveryDate, 
                 lastDeliveryDate, 
                 contractSize, 
                 coupon):
\end{lstlisting}

\subsection{Class Method {\it conversionFactor}}
Determine the conversion factor for a specific bond using CME convention. To do this we need to know the contract standard coupon and must round the bond maturity (starting its life on the first delivery date) to the nearest 3 month multiple and then calculate the bond clean price.  

\begin{lstlisting}
    def conversionFactor(self, bond):
\end{lstlisting}

\subsection{Class Method {\it principalInvoicePrice}}


\begin{lstlisting}
    def principalInvoicePrice(self,
                              bond,
                              futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it totalInvoiceAmount}}
futuresPrice):

\begin{lstlisting}
    def totalInvoiceAmount(self,
                     settlementDate,
                     bond,
                     futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it cheapestToDeliver}}
Determination of CTD as deliverable bond with lowest cost to buy versus what is received when the bond is delivered. 

\begin{lstlisting}
    def cheapestToDeliver(self, 
                          bonds,
                          bondCleanPrices,
                          futuresPrice):
\end{lstlisting}

\newpage
\section{FinBondOption}

\subsubsection{Enumerated Type: FinBondOptionModel}
\begin{itemize}
\item{HO\_LEE}
\item{HULL\_WHITE}
\end{itemize}

\subsubsection{Enumerated Type: FinBondOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\end{itemize}

\subsection{Class: FinBondOption()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_bond}
\item{self.\_strikePrice}
\item{self.\_bond.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
strikePrice):

\begin{lstlisting}
    def __init__(self,
                 maturityDate, 
                 coupon,
                 frequencyType,
                 accrualType,
                 expiryDate, 
                 strikePrice):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self,
              valueDate,
              discountCurve,
              modelType,
              modelParams,
              optionType):
\end{lstlisting}

\newpage
\section{FinFloatingRateNote}

\subsection{Class: FinFloatingRateNote(object)}
Class for managing floating rate notes that pay a floating index plus a quoted margin.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_redemption}
\item{self.\_quotedMargin}
\item{self.\_frequencyType}
\item{self.\_frequency}
\item{self.\_settlementDate}
\item{self.\_accrualType}
\item{self.\_flowDates}
\item{self.\_face}
\item{self.\_maturityDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create FinFloatingRateNote object. if frequencyType not in FinFrequencyTypes:raise FinError("Invalid Frequency:" + str(frequencyType))returnif accrualType not in FinDayCountTypes:raise FinError("Unknown Bond Accrued Convention type " + str(accrualType))self.\_maturityDate = maturityDateself.\_quotedMargin = quotedMarginself.\_frequencyType = frequencyTypeself.\_accrualType = accrualTypeself.\_flowDates = []self.\_frequency = FinFrequency(frequencyType)self.\_face = faceself.\_redemption = redemptionI do not determine cashflow dates as I do not want to require

\begin{lstlisting}
    def __init__(self, 
                 maturityDate,
                 quotedMargin,
                 frequencyType, 
                 accrualType,
                 face = 100.0, 
                 redemption = 1.0):
\end{lstlisting}

\subsection{Class Method {\it calculateFlowDates}}


\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountMargin}}
Calculate the full price of the bond from its discount margin and \#making assumptions about the future Libor rates. 

\begin{lstlisting}
    def fullPriceFromDiscountMargin(self, 
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm ):
\end{lstlisting}

\subsection{Class Method {\it dollarDuration}}


\begin{lstlisting}
    def dollarDuration(self, 
                       settlementDate, 
                       nextCoupon,
                       futureLibor,
                       dm):
\end{lstlisting}

\subsection{Class Method {\it macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement date given its yield to maturity. 

\begin{lstlisting}
    def macauleyDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm ):
\end{lstlisting}

\subsection{Class Method {\it modifiedDuration}}
Calculate the modified duration of the bondon a settlement date given its yield to maturity. 

\begin{lstlisting}
    def modifiedDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm ):
\end{lstlisting}

\subsection{Class Method {\it convexityFromDiscountMargin}}


\begin{lstlisting}
    def convexityFromDiscountMargin(self, 
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm ):
\end{lstlisting}

\subsection{Class Method {\it cleanPriceFromDiscountMargin}}


\begin{lstlisting}
    def cleanPriceFromDiscountMargin(self, 
                                     settlementDate,
                                     nextCoupon,
                                     futureLibor,
                                     dm ):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-value the bonds cashflows. THIS IS NOT COMPLETE. 

\begin{lstlisting}
    def fullPriceFromDiscountCurve(self, 
                                   settlementDate,
                                   indexCurve,
                                   discountCurve):
\end{lstlisting}

\subsection{Class Method {\it discountMargin}}
Calculate the bonds yield to maturity by solving the price yield relationship using a one-dimensional root solver. 

\begin{lstlisting}
    def discountMargin(self, 
                       settlementDate,
                       nextCoupon, 
                       futureLibor,
                       cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}


\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it pcd}}


\begin{lstlisting}
    def pcd(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it accruedInterest}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date. 

\begin{lstlisting}
    def accruedInterest(self, 
                        settlementDate, 
                        nextCoupon):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(dm, *args):
\end{lstlisting}


\chapter{..//products//libor}
\section{Introduction}
This folder contains a set of Libor-related products. It includes:
- Libor deposits
- Interest rate futures
- Overnight index swaps (OIS)
- Forward Rate Agreements (FRAs)
- Interest Rate swaps
- Caps and Floors on Libor
- Swaptions

\newpage
\section{FinInterestRateFuture}

\subsection{Class: FinInterestRateFuture(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_lastSettlementDate}
\item{self.\_contractSize}
\item{self.\_lastTradingDate}
\item{self.\_endOfInterestRatePeriod}
\item{self.\_dayCountType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 lastTradingDate,
                 dayCountType,
                 contractSize):
\end{lstlisting}

\subsection{Class Method {\it futuresRate}}


\begin{lstlisting}
    def futuresRate(self,
                    settlementDate,
                    futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it convexity}}
Calculation of the convexity adjustment between FRAs and interest rate futures using the Hull-White model as described in technical note. 

\begin{lstlisting}
    def convexity(self, 
                  settlementDate,
                  volatility, 
                  a):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborCapFloor}

\subsubsection{Enumerated Type: FinLiborCapFloorType}
\begin{itemize}
\item{CAP}
\item{FLOOR}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborCapFloorModelTypes}
\begin{itemize}
\item{BLACK}
\item{SHIFTED\_BLACK}
\item{SABR}
\end{itemize}

\subsection{Class: FinLiborCapFloor()}
class FinLiborCapFloor():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_optionType}
\item{self.\_dateGenRuleType}
\item{self.\_notional}
\item{self.\_frequencyType}
\item{self.\_capFloorDates}
\item{self.\_busDayAdjustType}
\item{self.\_strikeRate}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_startDate}
\item{self.\_lastFixing}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType = FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self, 
                 startDate,
                 maturityDate,
                 optionType,
                 strikeRate,
                 lastFixing = None,
                 frequencyType = FinFrequencyTypes.QUARTERLY,
                 dayCountType = FinDayCountTypes.THIRTY_E_360_ISDA,
                 notional = ONE_MILLION, 
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType = FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType = FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
modelParams):

\begin{lstlisting}
    def value(self, 
              valuationDate,
              liborCurve, 
              modelType, 
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it valueCapletFloorlet}}
modelParams):

\begin{lstlisting}
    def valueCapletFloorlet(self,
                            valuationDate,
                            startDate, 
                            endDate, 
                            liborCurve, 
                            modelType, 
                            modelParams):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborDeposit}

\subsection{Class: FinLiborDeposit(object)}
class FinLiborDeposit(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_depositRate}
\item{self.\_settlementDate}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 settlementDate, 
                 maturityDate, 
                 depositRate, 
                 dayCountType,
                 notional = ONE_MILLION, 
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsection{Class Method {\it df}}
Returns the maturity date discount factor that would allow the Libor curve to reprice the contractual market deposit rate. Note that this is a forward discount factor that starts on the settlement date.

\begin{lstlisting}
    def df(self):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self, valueDate, liborCurve ):
\end{lstlisting}

\subsection{Class Method {\it print}}


\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborFRA}

\subsection{Class: FinLiborFRA(object)}
Class for managing LIBOR forward rate agreements. A forward rate agreement is an agreement to exchange a fixed pre-agreed rate for a floating rate linked to LIBOR that is not known until some specified future fixing date. The FRA payment occurs on or soon after this date on the FRA settlement date. Typically the timing gap is two days.A FRA is used to hedge a Libor quality loan or lend of some agreed notional amount. This period starts on the settlement date of the FRA and ends on the maturity date of the FRA. For example a 1x4 FRA relates to a Libor starting in 1 month for a loan period ending in 4 months. Hence it linkes to 3-month Libor rate. The amount received by a payer of fixed rate at settlement is acc(1,2) * (Libor(1,2) - FRA RATE) / (1 + acc(0,1) x Libor(0,1))So the value at time 0 is acc(1,2) * (FWD Libor(1,2) - FRA RATE) x df(0,2)If the base date of the curve is before the value date then we forward adjust this amount to that value date.For simplicity I have assumed that the fixing date and the settlement date are the same date. This should be amended later. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_notional}
\item{self.\_settlementDate}
\item{self.\_payFixedRate}
\item{self.\_calendarType}
\item{self.\_fraRate}
\item{self.\_dayCountType}
\item{self.\_maturityDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 settlementDate, # The date on which the floating rate fixes
                 maturityDate, # The end of the Libor rate period
                 fraRate, # The fixed contractual FRA rate
                 payFixedRate, # True if the FRA rate is being paid
                 dayCountType, # For interest period between the fixing and maturity dates
                 notional = ONE_MILLION, 
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinBusDayConventionTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsection{Class Method {\it value}}
Determine mark to market value of a FRA contract based on the market FRA rate. The same curve is used for calculating the forward Libor and for doing discounting on the expected forward payment. 

\begin{lstlisting}
    def value(self, valueDate, liborCurve):
\end{lstlisting}

\subsection{Class Method {\it maturityDf}}
Determine the maturity date discount factor needed to refit the FRA given the libor curve anbd the contract FRA rate. 

\begin{lstlisting}
    def maturityDf(self, liborCurve):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborProducts}

\subsection{Class: FinLiborSwap(object)}
class FinLiborSwap(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.payFixedFlag}
\item{self.fixedLeg}
\item{self.payFixedLeg}
\item{self.floatLeg}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule="BACKWARD"):

\begin{lstlisting}
    def __init__(self, startDate, endDate,
                 fixedCoupon, fixedFreq, fixedBasis,
                 floatSpread, floatFreq, floatBasis,
                 firstFixing=None,
                 payFixedFlag=True,
                 calendarName="WEEKEND",
                 businessDateAdjust="FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve, indexCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection{Class: FinLiborSwapFixedLeg(object)}
class FinLiborSwapFixedLeg(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.freq}
\item{self.startDate}
\item{self.flows[numFlows-1].amount+}
\item{self.coupon}
\item{self.maturityDate}
\item{self.schedule}
\item{self.basis}
\item{self.flows}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule="BACKWARD"):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 coupon,
                 freq,
                 basis,
                 calendarName="WEEKEND",
                 businessDateAdjust="MODIFIED_FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it generateFlows}}
def generateFlows(self, fixedBasis):

\begin{lstlisting}
    def generateFlows(self, fixedBasis):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection{Class: FinLiborSwapFloatLeg(object)}
class FinLiborSwapFloatLeg(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.freq}
\item{self.startDate}
\item{self.endDate}
\item{self.flows[numFlows-1].amount+}
\item{self.floatSpread}
\item{self.firstFixing}
\item{self.schedule}
\item{self.basis}
\item{self.flows}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 floatSpread,
                 floatFreq,
                 floatBasis,
                 firstFixing,
                 calendarName,
                 businessDateAdjust,
                 dateGenRule):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve, indexCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it generateFlows}}
def generateFlows(self, indexCurve):

\begin{lstlisting}
    def generateFlows(self, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinLiborSwap}

\subsection{Class: FinLiborSwap(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_fixedFlowPVs}
\item{self.\_floatFlowPVs[-1]+}
\item{self.\_adjustedFixedDates}
\item{self.\_fixedYearFracs}
\item{self.\_floatDfs}
\item{self.\_maturityDate}
\item{self.\_dateGenRuleType}
\item{self.\_payFixedFlag}
\item{self.\_fixedDayCountType}
\item{self.\_fixedFlowPVs[-1]+}
\item{self.\_fixedFrequencyType}
\item{self.\_floatFlows[-1]+}
\item{self.\_floatSpread}
\item{self.\_calendarType}
\item{self.\_floatFlows}
\item{self.\_fixedFlows}
\item{self.\_floatYearFracs}
\item{self.\_floatDayCountType}
\item{self.\_startDate}
\item{self.\_floatFlowPVs}
\item{self.\_fixedDfs}
\item{self.\_fixedFlows[-1]+}
\item{self.\_adjustedFloatDates}
\item{self.\_fixedCoupon}
\item{self.\_busDayAdjustType}
\item{self.\_payFixedLeg}
\item{self.\_floatStartIndex}
\item{self.\_fixedStartIndex}
\item{self.\_floatFrequencyType}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 startDate, 
                 maturityDate,
                 fixedCoupon, 
                 fixedFreqType, 
                 fixedDayCountType,
                 notional = ONE_MILLION,
                 floatSpread = 0.0, 
                 floatFreqType = FinFrequencyTypes.QUARTERLY, 
                 floatDayCountType = FinDayCountTypes.THIRTY_360,
                 payFixedFlag=True,
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType = FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the interest rate swap on a value date given a single Libor discount curve. 

\begin{lstlisting}
    def value(self, 
              valuationDate, 
              discountCurve, 
              indexCurve,
              firstFixingRate, 
              principal = 0.0):
\end{lstlisting}

\subsection{Class Method {\it generateFixedLegPaymentDates}}
Generate the fixed leg payment dates all the way back to the start date of the swap which may precede the valuation date

\begin{lstlisting}
    def generateFixedLegPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it generateFloatLegPaymentDates}}
Generate the floating leg payment dates all the way back to the start date of the swap which may precede the valuation date

\begin{lstlisting}
    def generateFloatLegPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it pv01}}


\begin{lstlisting}
    def pv01(self, valuationDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it parCoupon}}


\begin{lstlisting}
    def parCoupon(self, valuationDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it fixedLegValue}}
The swap may have started in the past but we can only value payments that have occurred after the valuation date. 

\begin{lstlisting}
    def fixedLegValue(self, valuationDate, discountCurve, principal = 0.0):
\end{lstlisting}

\subsection{Class Method {\it floatLegValue}}
Value the floating leg with payments from an index curve and discounting based on a supplied discount curve. 

\begin{lstlisting}
    def floatLegValue(self, 
                      valuationDate, 
                      discountCurve, 
                      indexCurve, 
                      firstFixingRate = None,
                      principal = 0.0 ):
\end{lstlisting}

\subsection{Class Method {\it printFixedLeg}}


\begin{lstlisting}
    def printFixedLeg(self, valuationDate):
\end{lstlisting}

\subsection{Class Method {\it printFloatLeg}}


\begin{lstlisting}
    def printFloatLeg(self, valuationDate):
\end{lstlisting}

\newpage
\section{FinLiborSwaption}

\subsubsection{Enumerated Type: FinLiborSwaptionType}
\begin{itemize}
\item{PAYER}
\item{RECEIVER}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborSwaptionModelTypes}
\begin{itemize}
\item{BLACK}
\item{SABR}
\end{itemize}

\subsection{Class: FinLiborSwaption()}
class FinLiborSwaption():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_swapFixedCoupon}
\item{self.\_dateGenRuleType}
\item{self.\_forwardDf}
\item{self.\_swapFixedFrequencyType}
\item{self.\_busDayAdjustType}
\item{self.\_swapNotional}
\item{self.\_swaptionType}
\item{self.\_pv01}
\item{self.\_calendarType}
\item{self.\_exerciseDate}
\item{self.\_fwdSwapRate}
\item{self.\_swapFixedDayCountType}
\item{self.\_maturityDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self, 
                 exerciseDate,
                 swapMaturityDate,
                 swaptionType,
                 swapFixedCoupon,
                 swapFixedFrequencyType,
                 swapFixedDayCountType,
                 swapNotional = ONE_MILLION, 
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType = FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
modelParams):

\begin{lstlisting}
    def value(self, 
              valuationDate,
              liborCurve, 
              modelType, 
              modelParams):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinOIS}

\subsection{Class: FinOIS(object)}
Class for managing overnight index swaps. This is a swap contract in which a fixed payment leg is exchanged for a floating coupon leg. There is no exchange of par. The contract lasts from a start date to a specified maturity date. The fixed coupon is the OIS fixed rate which is set at contract initiation. The floating rate is not known until the end of each payment period. It is calculated at the end of the period as it is based on daily observations of the overnight index rate which are compounded according to a specific convention. Hence the OIS floating rate is determined by the history of the OIS rates. In its simplest form, there is just one fixed rate payment and one floating rate payment at contract maturity. However when the contract becomes longer than one year the floating and fixed payments become periodic.The value of the contract is the NPV of the two coupon streams. Discounting is done on a supplied OIS curve which is itself implied by the term structure of market OIS rates. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dateGenRuleType}
\item{self.\_fixedDayCountType}
\item{self.\_fixedRate}
\item{self.\_busDayAdjustType}
\item{self.\_fixedFrequencyType}
\item{self.\_maturityDate}
\item{self.\_adjustedFixedDates}
\item{self.\_payFixedLeg}
\item{self.\_calendarType}
\item{self.\_floatFlows}
\item{self.\_adjustedFloatDates}
\item{self.\_fixedFlows}
\item{self.\_floatFrequencyType}
\item{self.\_floatDayCountType}
\item{self.\_startDate}
\item{self.\_notional}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 startDate, 
                 maturityDate, 
                 fixedRate,
                 fixedFrequencyType,
                 fixedDayCountType,
                 floatFrequencyType = FinFrequencyTypes.ANNUAL,
                 floatDayCountType = FinDayCountTypes.ACT_360, 
                 payFixedLeg = True, 
                 notional = ONE_MILLION,
                 calendarType = FinCalendarTypes.WEEKEND,
                 busDayAdjustType = FinBusDayConventionTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generatePaymentDates}}
def generatePaymentDates(self, valueDate):

\begin{lstlisting}
    def generatePaymentDates(self, valueDate):
\end{lstlisting}

\subsection{Class Method {\it generateFixedLegFlows}}
def generateFixedLegFlows(self, valueDate):

\begin{lstlisting}
    def generateFixedLegFlows(self, valueDate):
\end{lstlisting}

\subsection{Class Method {\it generateFloatLegFlows}}


\begin{lstlisting}
    def generateFloatLegFlows(self, valueDate, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it rate}}


\begin{lstlisting}
    def rate(self, oisDates, oisFixings):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the interest rate swap on a value date given a single Libor discount curve. 

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it fixedLegValue}}
def fixedLegValue(self, valueDate, discountCurve, principal = 0.0):

\begin{lstlisting}
    def fixedLegValue(self, valueDate, discountCurve, principal = 0.0):
\end{lstlisting}

\subsection{Class Method {\it floatLegValue}}
Value the floating leg with payments from an index curve and discounting based on a supplied discount curve. 

\begin{lstlisting}
    def floatLegValue(self, 
                          valueDate, 
                          discountCurve, 
                          indexCurve, 
                          principal = 0.0 ):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, 
           oisRate, 
           startDate, 
           endDate):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self, valueDate, indexCurve):

\begin{lstlisting}
    def print(self, valueDate, indexCurve):
\end{lstlisting}


\chapter{..//products//fx}
\section{Introduction}
This is where FX derivatives will be found.

\chapter{..//models}
\section{Introduction}
This folder contains a range of models used in the various derivative prices implemented. These include credit models for valuing portfolio credit products such as CDS Tranches, Monte-Carlo based models of stochastics processes used to value equity, FX and interest rate derivatives, and some generic implementations of models such as a tree based Hull White model. Because the models are useful across a range of products, it is better to factor them out of the product/asset class categorisation as it avoids any unnecessary duplication.

\newpage
\section{FinCIRRateModel}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection{Class: FinCIRRateModel()}
class FinCIRRateModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_sigma}
\item{self.\_b}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,a,b,sigma):

\begin{lstlisting}
    def __init__(self,a,b,sigma):
\end{lstlisting}

\subsection{Function {\it meanr}}


\begin{lstlisting}
def meanr(r0,a,b,t):
\end{lstlisting}

\subsection{Function {\it variancer}}


\begin{lstlisting}
def variancer(r0,a,b,sigma,t):
\end{lstlisting}

\subsection{Function {\it zeroPrice}}


\begin{lstlisting}
def zeroPrice(r0,a,b,sigma,t):
\end{lstlisting}

\subsection{Function {\it draw}}


\begin{lstlisting}
def draw(rt,a,b,sigma,dt):
\end{lstlisting}

\subsection{Function {\it ratePath\_MC}}


\begin{lstlisting}
def ratePath_MC(r0,a,b,sigma,t,dt,seed,scheme):
\end{lstlisting}

\subsection{Function {\it zeroPrice\_MC}}


\begin{lstlisting}
def zeroPrice_MC(r0,a,b,sigma,t,dt,numPaths,seed,scheme):
\end{lstlisting}

\newpage
\section{FinGaussianCopula1FModel}

\subsection{Function {\it lossDbnRecursionGCD}}
Full construction of the loss distribution of a portfolio of credits where losses have been calculate as number of units based on the GCD. 

\begin{lstlisting}
def lossDbnRecursionGCD(numCredits, 
                        defaultProbs, 
                        lossUnits,
                        betaVector,
                        numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it homogeneousBasketLossDbn}}
Calculate the loss distribution of a CDS default basket where the portfolio is equally weighted and the losses in the portfolio are homo-geneous i.e. the credits have the same recovery rates. 

\begin{lstlisting}
def homogeneousBasketLossDbn(survivalProbabilities,
                             recoveryRates,
                             betaVector,
                             numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it trSurvProbRecursion}}
Get the tranche survival probability of a portfolio of credits in the one-factor GC model using a full recursion calculation of the loss distribution and survival probabilities to some time horizon. 

\begin{lstlisting}
def trSurvProbRecursion(k1,
                                        k2,
                                        numCredits,
                                        survivalProbabilities,
                                        recoveryRates,
                                        betaVector,
                                        numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it gaussApproxTrancheLoss}}
def gaussApproxTrancheLoss(k1,k2,mu,sigma):

\begin{lstlisting}
def gaussApproxTrancheLoss(k1,k2,mu,sigma):
\end{lstlisting}

\subsection{Function {\it trSurvProbGaussian}}
Get the approximated tranche survival probability of a portfolio of credits in the one-factor GC model using a Gaussian fit of the conditional loss distribution and survival probabilities to some time horizon. Note that the losses in this fit are allowed to be negative. 

\begin{lstlisting}
def trSurvProbGaussian(k1,
                                       k2,
                                       numCredits,
                                       survivalProbabilities,
                                       recoveryRates,
                                       betaVector,
                                       numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it lossDbnHeterogeneousAdjBinomial}}
Get the portfolio loss distribution using the adjusted binomial approximation to the conditional loss distribution. 

\begin{lstlisting}
def lossDbnHeterogeneousAdjBinomial(numCredits, 
                                    defaultProbs, 
                                    lossRatio,
                                    betaVector,
                                    numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it trSurvProbAdjBinomial}}
Get the approximated tranche survival probability of a portfolio ofcredits in the one-factor GC model using the adjusted binomial fit of the conditional loss distribution and survival probabilities to some time horizon. This approach is both fast and highly accurate. 

\begin{lstlisting}
def trSurvProbAdjBinomial(k1, 
                                          k2, 
                                          numCredits,
                                          survivalProbabilities, 
                                          recoveryRates, 
                                          betaVector,
                                          numIntegrationSteps):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaLHPModel}

\subsection{Function {\it trSurvProbLHP}}
Get the approximated tranche survival probability of a portfolio ofcredits in the one-factor GC model using the large portfolio limit which assumes a homogenous portfolio with an infinite number of credits. This approach is very fast but not so as accurate as the adjusted binomial. 

\begin{lstlisting}
def trSurvProbLHP(k1, 
                                  k2, 
                                  numCredits, 
                                  survivalProbabilities, 
                                  recoveryRates, 
                                  beta):
\end{lstlisting}

\subsection{Function {\it portfolioCDF\_LHP}}
def portfolioCDF\_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints):

\begin{lstlisting}
def portfolioCDF_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints):
\end{lstlisting}

\subsection{Function {\it expMinLK}}
def expMinLK(k, p, r, n, beta ):

\begin{lstlisting}
def expMinLK(k, p, r, n, beta ):
\end{lstlisting}

\subsection{Function {\it LHPDensity}}
def LHPDensity(k, p, r, beta):

\begin{lstlisting}
def LHPDensity(k, p, r, beta):
\end{lstlisting}

\subsection{Function {\it LHPAnalyticalDensityBaseCorr}}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta\_dk):

\begin{lstlisting}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta_dk):
\end{lstlisting}

\subsection{Function {\it LHPAnalyticalDensity}}
def LHPAnalyticalDensity(k, p, r, beta ):

\begin{lstlisting}
def LHPAnalyticalDensity(k, p, r, beta ):
\end{lstlisting}

\subsection{Function {\it ExpMinLK}}
def ExpMinLK(k, p, r, n, beta):

\begin{lstlisting}
def ExpMinLK(k, p, r, n, beta):
\end{lstlisting}

\subsection{Function {\it probLGreaterThanK}}
def probLGreaterThanK( K,  P,  R,  beta):

\begin{lstlisting}
def probLGreaterThanK( K,  P,  R,  beta):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaModel}

\subsection{Function {\it defaultTimesGC}}
seed):

\begin{lstlisting}
def defaultTimesGC(issuerCurves, 
                   correlationMatrix, 
                   numTrials, 
                   seed):
\end{lstlisting}

\newpage
\section{FinGBMProcess}

\subsection{Class: FinGBMProcess()}
class FinGBMProcess():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it getPaths}}
def getPaths(self, numPaths, numTimeSteps, t, mu, stockPrice, volatility, seed):    

\begin{lstlisting}
    def getPaths(self, numPaths, numTimeSteps, t, mu, stockPrice, volatility, seed):    
\end{lstlisting}

\subsection{Class Method {\it getPathsAssets}}
t, mus, stockPrices, volatilities, betas, seed):    

\begin{lstlisting}
    def getPathsAssets(self, numAssets, numPaths, numTimeSteps, 
                       t, mus, stockPrices, volatilities, betas, seed):    
\end{lstlisting}

\subsection{Function {\it getPaths}}
seed):

\begin{lstlisting}
def getPaths(numPaths,
             numTimeSteps,
             t,
             mu,
             stockPrice,
             volatility,
             seed):
\end{lstlisting}

\subsection{Function {\it getPathsAssets}}
seed):    

\begin{lstlisting}
def getPathsAssets(numAssets,
                           numPaths,
                           numTimeSteps,
                           t,
                           mus,
                           stockPrices,
                           volatilities,
                           betas,
                           seed):    
\end{lstlisting}

\subsection{Function {\it getAssets}}
seed):    

\begin{lstlisting}
def getAssets(numAssets,
                      numPaths,
                      t,
                      mus,
                      stockPrices,
                      volatilities,
                      betas,
                      seed):    
\end{lstlisting}

\newpage
\section{FinHestonModel}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection{Class: FinHestonModel()}
class FinHestonModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_rho}
\item{self.\_v0}
\item{self.\_sigma}
\item{self.\_kappa}
\item{self.\_theta}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,v0,kappa,theta,sigma,rho):

\begin{lstlisting}
    def __init__(self,v0,kappa,theta,sigma,rho):
\end{lstlisting}

\subsection{Class Method {\it value\_MC}}
scheme = FinHestonNumericalScheme.EULERLOG):

\begin{lstlisting}
    def value_MC(self,
                  valueDate,
                  option,
                  stockPrice,
                  interestRate,
                  dividendYield,
                  numPaths,
                  numStepsPerYear,
                  seed, 
                  scheme = FinHestonNumericalScheme.EULERLOG):
\end{lstlisting}

\subsection{Class Method {\it value\_Lewis}}
dividendYield):

\begin{lstlisting}
    def value_Lewis(self,
                       valueDate,
                       option,
                       stockPrice,
                       interestRate,
                       dividendYield):
\end{lstlisting}

\subsection{Class Method {\it phi}}
def phi(k\_in,):

\begin{lstlisting}
        def phi(k_in,):
\end{lstlisting}

\subsection{Class Method {\it phi\_transform}}
def phi\_transform(x):

\begin{lstlisting}
        def phi_transform(x):
\end{lstlisting}

\subsection{Class Method {\it value\_Lewis\_Rouah}}
dividendYield):

\begin{lstlisting}
    def value_Lewis_Rouah(self,
                           valueDate,
                           option,
                           stockPrice,
                           interestRate,
                           dividendYield):
\end{lstlisting}

\subsection{Class Method {\it f}}
def f(k\_in):

\begin{lstlisting}
        def f(k_in):
\end{lstlisting}

\subsection{Class Method {\it value\_Weber}}
dividendYield):

\begin{lstlisting}
    def value_Weber(self,
                       valueDate,
                       option,
                       stockPrice,
                       interestRate,
                       dividendYield):
\end{lstlisting}

\subsection{Class Method {\it F}}
def F(s,b):

\begin{lstlisting}
        def F(s,b):
\end{lstlisting}

\subsection{Class Method {\it integrand}}
def integrand(u):

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsection{Class Method {\it value\_Gatheral}}
dividendYield):

\begin{lstlisting}
    def value_Gatheral(self,
                       valueDate,
                       option,
                       stockPrice,
                       interestRate,
                       dividendYield):
\end{lstlisting}

\subsection{Class Method {\it F}}
def F(j):

\begin{lstlisting}
        def F(j):
\end{lstlisting}

\subsection{Class Method {\it integrand}}
def integrand(u):

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsection{Function {\it getPaths}}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):

\begin{lstlisting}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):
\end{lstlisting}

\newpage
\section{FinHestonProcess}

\subsubsection{Enumerated Type: FinHestonScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection{Class: FinHestonProcess(FinProcess)}
class FinHestonProcess(FinProcess):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_numTimeSteps}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it getPathsAssets}}
fast = FinFastNumericalApproach.NUMBA):

\begin{lstlisting}
    def getPathsAssets(self, 
                 t,
                 mus,
                 stockPrices,
                 volatilities,
                 betas,
                 seed, 
                 fast = FinFastNumericalApproach.NUMBA):
\end{lstlisting}

\subsection{Function {\it getPaths}}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):

\begin{lstlisting}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):
\end{lstlisting}

\newpage
\section{FinHoLeeRateModel}

\subsection{Class: FinHoLeeModel()}
class FinHoLeeModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_sigma}
\item{self.\_discountCurve}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,discountCurve,sigma):

\begin{lstlisting}
    def __init__(self,discountCurve,sigma):
\end{lstlisting}

\subsection{Class Method {\it P}}
t2): \# forward maturity t2

\begin{lstlisting}
    def P(self,
          r1, # short rate at time t1
          t1, # foward start time t1
          t2): # forward maturity t2
\end{lstlisting}

\newpage
\section{FinHullWhiteRateModel}

\subsection{Class: FinHullWhiteTree()}
class FinHullWhiteTree():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_sigma}
\item{self.\_discountCurve}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
sigma):

\begin{lstlisting}
  def __init__(self,
               discountCurve,
               a,
               sigma):
\end{lstlisting}

\subsection{Class: FinHullWhiteRateModel()}
class FinHullWhiteRateModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_sigma}
\item{self.\_discountCurve}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,discountCurve,
                 a,
                 sigma):
\end{lstlisting}

\subsection{Class Method {\it P}}


\begin{lstlisting}
    def P(self,
          r1, # short rate at time t1
          t1, # forward start time t1
          t2): # forward maturity t2
\end{lstlisting}

\newpage
\section{FinLHPlusModel}

\subsection{Class: LHPlusModel()}
class LHPlusModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_P}
\item{self.\_R}
\item{self.\_beta}
\item{self.\_R0}
\item{self.\_H0}
\item{self.\_beta0}
\item{self.\_H}
\item{self.\_P0}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_( self, P, R, H, beta, P0, R0, H0, beta0):

\begin{lstlisting}
    def __init__( self, P, R, H, beta, P0, R0, H0, beta0):
\end{lstlisting}

\subsection{Class Method {\it probLossGreaterThanK}}
def probLossGreaterThanK( self, K ):

\begin{lstlisting}
    def probLossGreaterThanK( self, K ):
\end{lstlisting}

\subsection{Class Method {\it expMinLKIntegral}}
def expMinLKIntegral(self, K, dK):

\begin{lstlisting}
    def expMinLKIntegral(self, K, dK):
\end{lstlisting}

\subsection{Class Method {\it expMinLK}}
def expMinLK(self, K):

\begin{lstlisting}
    def expMinLK(self, K):
\end{lstlisting}

\subsection{Class Method {\it expMinLK2}}
def expMinLK2(self, K):

\begin{lstlisting}
    def expMinLK2(self, K):
\end{lstlisting}

\subsection{Class Method {\it trancheSurvivalProbability}}
def trancheSurvivalProbability(self, k1, k2):

\begin{lstlisting}
    def trancheSurvivalProbability(self, k1, k2):
\end{lstlisting}

\newpage
\section{FinLossDbnBuilder}

\subsection{Function {\it indepLossDbnHeterogeneousAdjBinomial}}
lossRatio):

\begin{lstlisting}
def indepLossDbnHeterogeneousAdjBinomial(numCredits,
                                         condDefaultProbs,
                                         lossRatio):
\end{lstlisting}

\subsection{Function {\it portfolioGCD}}
def portfolioGCD(actualLosses):

\begin{lstlisting}
def portfolioGCD(actualLosses):
\end{lstlisting}

\subsection{Function {\it indepLossDbnRecursionGCD}}
lossUnits):

\begin{lstlisting}
def indepLossDbnRecursionGCD(numCredits, 
                             condDefaultProbs,
                             lossUnits):
\end{lstlisting}

\newpage
\section{FinMertonModel}

\subsection{Function {\it MertonModelValues}}
riskFreeRate):

\begin{lstlisting}
def MertonModelValues(assetValue, 
                      bondFace, 
                      timeToMaturity, 
                      volatility, 
                      riskFreeRate):
\end{lstlisting}

\newpage
\section{FinProcessSimulator}

\subsubsection{Enumerated Type: FinProcessTypes}
\begin{itemize}
\item{GBM}
\item{CIR}
\item{HESTON}
\item{VASICEK}
\item{CEV}
\item{JUMP\_DIFFUSION}
\end{itemize}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsubsection{Enumerated Type: FinGBMNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinVasicekNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection{Class: FinProcessSimulator()}
class FinProcessSimulator():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it getProcess}}
def getProcess(self, processType, t, modelParams, numAnnSteps,numPaths, seed):

\begin{lstlisting}
    def getProcess(self, processType, t, modelParams, numAnnSteps,numPaths, seed):
\end{lstlisting}

\subsection{Function {\it getHestonPaths}}
def getHestonPaths(numPaths,numAnnSteps,t,drift,s0,v0,kappa,theta,sigma,rho,scheme,seed):

\begin{lstlisting}
def getHestonPaths(numPaths,numAnnSteps,t,drift,s0,v0,kappa,theta,sigma,rho,scheme,seed):
\end{lstlisting}

\subsection{Function {\it getGBMPaths}}
def getGBMPaths(numPaths,numAnnSteps,t,mu,stockPrice,sigma,scheme,seed):

\begin{lstlisting}
def getGBMPaths(numPaths,numAnnSteps,t,mu,stockPrice,sigma,scheme,seed):
\end{lstlisting}

\subsection{Function {\it getVasicekPaths}}
def getVasicekPaths(numPaths,numAnnSteps,t,r0,kappa,theta,sigma,scheme,seed):

\begin{lstlisting}
def getVasicekPaths(numPaths,numAnnSteps,t,r0,kappa,theta,sigma,scheme,seed):
\end{lstlisting}

\subsection{Function {\it getCIRPaths}}
def getCIRPaths(numPaths,numAnnSteps,t,r0,kappa,theta,sigma,scheme,seed):

\begin{lstlisting}
def getCIRPaths(numPaths,numAnnSteps,t,r0,kappa,theta,sigma,scheme,seed):
\end{lstlisting}

\newpage
\section{FinSABRModel}

\subsection{Function {\it blackVolFromSABR}}
def blackVolFromSABR(alpha,beta,rho,nu,f,k,t): 

\begin{lstlisting}
def blackVolFromSABR(alpha,beta,rho,nu,f,k,t): 
\end{lstlisting}

\newpage
\section{FinStudentTCopulaModel}

\subsection{Class: FinStudentTCopulaModel()}
class FinStudentTCopulaModel():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it defaultTimes}}
seed):

\begin{lstlisting}
    def defaultTimes(self, 
                     issuerCurves, 
                     correlationMatrix, 
                     degreesOfFreedom,
                     numTrials, 
                     seed):
\end{lstlisting}

\newpage
\section{FinVasicekRateModel}

\subsection{Class: FinVasicekModel()}
class FinVasicekModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_sigma}
\item{self.\_b}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,a,b,sigma):

\begin{lstlisting}
    def __init__(self,a,b,sigma):
\end{lstlisting}

\subsection{Function {\it meanr}}
def meanr(r0,a,b,t):

\begin{lstlisting}
def meanr(r0,a,b,t):
\end{lstlisting}

\subsection{Function {\it variancer}}
def variancer(a,b,sigma,t):

\begin{lstlisting}
def variancer(a,b,sigma,t):
\end{lstlisting}

\subsection{Function {\it zeroPrice}}
def zeroPrice(r0,a,b,sigma,t):

\begin{lstlisting}
def zeroPrice(r0,a,b,sigma,t):
\end{lstlisting}

\subsection{Function {\it ratePath\_MC}}
def ratePath\_MC(r0,a,b,sigma,t,dt,seed):

\begin{lstlisting}
def ratePath_MC(r0,a,b,sigma,t,dt,seed):
\end{lstlisting}

\subsection{Function {\it zeroPrice\_MC}}
def zeroPrice\_MC(r0,a,b,sigma,t,dt,numPaths,seed):

\begin{lstlisting}
def zeroPrice_MC(r0,a,b,sigma,t,dt,numPaths,seed):
\end{lstlisting}


\chapter{..//portfolio}
\section{Introduction}


\chapter{..//risk}
\section{Introduction}

\newpage
\section{FinPortfolioTailRisk}


\chapter{..//market//curves}
\section{Introduction}
These modules create a family of curve types which inherit from the FinCurve class. They all provide a discount factor function which can be used to present value a future cash flow. 

Included in the classes is a credit risky curve which builds a survival probability curve on top of a risk-free curve They also rely heavily on the FinInterpolate module which provides fast interpolation.

It also includes a number of parametric curves that can be used to fit yield curves such as Nelson-Siegel.
\newpage
\section{FinCDSCurve}

\subsection{Class: FinCDSCurve(FinDiscountCurve)}
Generate a survival probability curve implied by the value of CDS contracts given a Libor curve and an assumed recovery rate. And interpolation scheme for the survival probabilities is also required. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_UseCache}
\item{self.\_cachedDailySurvivalProbs}
\item{self.\_cachedDailySurvivalProbs[i]}
\item{self.\_liborCurve}
\item{self.\_cdsContracts}
\item{self.\_interpolationMethod}
\item{self.\_curveDate}
\item{self.\_times}
\item{self.\_useCache}
\item{self.\_builtOK}
\item{self.\_recoveryRate}
\item{self.m\_CachedTimeLimit}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
interpolationMethod =  FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def __init__(self,
                 curveDate,
                 cdsContracts,
                 liborCurve,
                 recoveryRate = 0.40,
                 useCache = False,
                 interpolationMethod =  FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsection{Class Method {\it validate}}


\begin{lstlisting}
    def validate(self,cdsContracts):
\end{lstlisting}

\subsection{Class Method {\it survivalProbability}}


\begin{lstlisting}
    def survivalProbability(self,dt):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self,t):
\end{lstlisting}

\subsection{Class Method {\it buildCurve}}
def buildCurve(self):

\begin{lstlisting}
    def buildCurve(self):
\end{lstlisting}

\subsection{Class Method {\it buildCachedIssuerCurve}}
def buildCachedIssuerCurve(self):

\begin{lstlisting}
    def buildCachedIssuerCurve(self):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection{Function {\it uniformToDefaultTime}}
def uniformToDefaultTime(u, t, v):

\begin{lstlisting}
def uniformToDefaultTime(u, t, v):
\end{lstlisting}

\subsection{Function {\it f}}
def f(q, *args):

\begin{lstlisting}
def f(q, *args):
\end{lstlisting}

\newpage
\section{FinCurve}

\subsubsection{Enumerated Type: FinCompoundingMethods}
\begin{itemize}
\item{CONTINUOUS}
\item{ANNUAL}
\item{SEMI\_ANNUAL}
\item{QUARTERLY}
\item{MONTHLY}
\item{MONEY\_MARKET}
\end{itemize}

\subsection{Class: FinCurve()}
class FinCurve():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_curveDate}
\item{self.\_times}
\item{self.\_type}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,curveDate, interpolationMethod, type):

\begin{lstlisting}
    def __init__(self,curveDate, interpolationMethod, type):
\end{lstlisting}

\subsection{Class Method {\it df}}
def df(self,t, interpolationMethod = FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def df(self,t, interpolationMethod = FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\newpage
\section{FinDiscountCurve}

\subsection{Class: FinDiscountCurve()}
class FinDiscountCurve():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_curveDate}
\item{self.\_times}
\item{self.\_interpMethod}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
interpMethod):

\begin{lstlisting}
    def __init__(self, 
                 curveDate, 
                 times, 
                 values, 
                 interpMethod):
\end{lstlisting}

\subsection{Class Method {\it df}}
def df(self, time):

\begin{lstlisting}
    def df(self, time):
\end{lstlisting}

\subsection{Class Method {\it survivalProbability}}
def survivalProbability(self, time):

\begin{lstlisting}
    def survivalProbability(self, time):
\end{lstlisting}

\subsection{Class Method {\it zeroContinuous}}


\begin{lstlisting}
    def zeroContinuous(self, maturityDate):
\end{lstlisting}

\subsection{Class Method {\it fwdContinuous}}


\begin{lstlisting}
    def fwdContinuous(self, forwardDate):
\end{lstlisting}

\subsection{Class Method {\it fwdLibor}}
Calculate the Libor forward rate according to the corresponding day count convention. 

\begin{lstlisting}
    def fwdLibor(self, date1, date2, dayCountType):
\end{lstlisting}

\subsection{Class Method {\it print}}


\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinFlatCurve}

\subsection{Class: FinFlatCurve(FinCurve)}
A simple discount curve based on a single zero rate with its own specified compounding method. Hence the curve is assumed to be flat. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_rate}
\item{self.\_curveDate}
\item{self.\_compoundingType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, curveDate, rate, compoundingType):

\begin{lstlisting}
    def __init__(self, curveDate, rate, compoundingType):
\end{lstlisting}

\subsection{Class Method {\it zero}}


\begin{lstlisting}
    def zero(self,t):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self,t):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, time):
\end{lstlisting}

\newpage
\section{FinLiborOneCurve}

\subsection{Class: FinLiborOneCurve(FinDiscountCurve)}
Constructs a discount curve as implied by the prices of Libor deposits, FRAs and interest rate swaps. The curve date is the date on which we are performing the valuation based on the information available on the curve date. Typically it is the date on which an amount of $1 paid has a present value of $1. This class inherits from FinDiscountCurve so has all of the methods that class has. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_interpMethod}
\item{self.\_usedSwaps}
\item{self.\_usedDeposits}
\item{self.\_curveDate}
\item{self.\_times}
\item{self.\_name}
\item{self.\_usedFRAs}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
interpMethod = FinInterpMethods.FLAT\_FORWARDS ):

\begin{lstlisting}
    def __init__(self, 
                 name, 
                 curveDate, 
                 liborDeposits,
                 liborFRAs,
                 liborSwaps,
                 interpMethod = FinInterpMethods.FLAT_FORWARDS ):
\end{lstlisting}

\subsection{Class Method {\it validateInputs}}


\begin{lstlisting}
    def validateInputs(self,
                  liborDeposits,
                  liborFRAs,
                  liborSwaps):
\end{lstlisting}

\subsection{Class Method {\it buildCurve}}


\begin{lstlisting}
    def buildCurve(self,
                  liborDeposits,
                  liborFRAs,
                  liborSwaps):
\end{lstlisting}

\subsection{Function {\it f}}
def f(df, *args):

\begin{lstlisting}
def f(df, *args):
\end{lstlisting}

\newpage
\section{FinNelsonSiegelCurve}

\subsection{Class: FinNelsonSiegelCurve(FinCurve)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_tau}
\item{self.\_beta2}
\item{self.\_beta3}
\item{self.\_beta1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,beta1,beta2,beta3,tau):

\begin{lstlisting}
    def __init__(self,beta1,beta2,beta3,tau):
\end{lstlisting}

\subsection{Class Method {\it zero}}
Calculation of zero rates. This function can return a vector of zero rates given a vector of times. 

\begin{lstlisting}
    def zero(self,t):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
Calculation of forward rates. This function can return a vector of forward rates given a vector of times. 

\begin{lstlisting}
    def fwd(self,t):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self,t):
\end{lstlisting}

\newpage
\section{FinNelsonSiegelSvenssonCurve}

\subsection{Class: FinNelsonSiegelSvenssonCurve(FinCurve)}
Implementation of Nelson-Siegel-Svensson parametrisation of the zero rate curve 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_beta2}
\item{self.\_tau1}
\item{self.\_tau2}
\item{self.\_beta1}
\item{self.\_beta4}
\item{self.\_beta3}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self,beta1,beta2,beta3,beta4,tau1,tau2):

\begin{lstlisting}
    def __init__(self,beta1,beta2,beta3,beta4,tau1,tau2):
\end{lstlisting}

\subsection{Class Method {\it zero}}
Calculation of zero rates. This function can return a vector of zero rates given a vector of times. 

\begin{lstlisting}
    def zero(self,t):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
Calculation of forward rates. This function uses Numpy so can return a vector of forward rates given a Numpy array vector of times. 

\begin{lstlisting}
    def fwd(self,t):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self,t):
\end{lstlisting}

\newpage
\section{FinPieceCurve}

\subsection{Class: FinPieceCurve(FinCurve)}
Curve is made up of a series of sections assumed to each have a constant forward rate. This class needs to be checked carefully. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_times}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,times,values):
\end{lstlisting}

\subsection{Class Method {\it zero}}
def zero(self,t,interpolationMethod=FinInterpMethods.LINEAR):

\begin{lstlisting}
    def zero(self,t,interpolationMethod=FinInterpMethods.LINEAR):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
def fwd(self,t):

\begin{lstlisting}
    def fwd(self,t):
\end{lstlisting}

\subsection{Class Method {\it df}}
interpolationMethod=FinInterpMethods.LINEAR):

\begin{lstlisting}
    def df(self,
           t, 
           freq=0, # This corresponds to continuous compounding
           interpolationMethod=FinInterpMethods.LINEAR):
\end{lstlisting}

\newpage
\section{FinPolynomialCurve}

\subsection{Class: FinPolynomialCurve(FinCurve)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.c3}
\item{self.c1}
\item{self.c2}
\item{self.c0}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,a=0,b=0,c=0,d=0):
\end{lstlisting}

\subsection{Class Method {\it zero}}
def zero(self,t):

\begin{lstlisting}
    def zero(self,t):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
def fwd(self,t):

\begin{lstlisting}
    def fwd(self,t):
\end{lstlisting}

\subsection{Class Method {\it df}}
def df(self,t):

\begin{lstlisting}
    def df(self,t):
\end{lstlisting}


\chapter{..//tests}
\section{Introduction}
This folder contains the logic for performing comparison testing of code to ensure that it does not inadvertantly get broken. 

\newpage
\section{TestFinAmericanOption}

\subsection{Function {\it testFinAmericanOption}}
def testFinAmericanOption():

\begin{lstlisting}
def testFinAmericanOption():
\end{lstlisting}


\newpage
\section{TestFinAnnuity}

\subsection{Function {\it test\_FinAnnuity}}
def test\_FinAnnuity():

\begin{lstlisting}
def test_FinAnnuity():
\end{lstlisting}


\newpage
\section{TestFinAsianOption}

\subsection{Function {\it testConvergence}}
def testConvergence():

\begin{lstlisting}
def testConvergence():
\end{lstlisting}

\subsection{Function {\it testTimeEvolution}}
def testTimeEvolution():

\begin{lstlisting}
def testTimeEvolution():
\end{lstlisting}

\subsection{Function {\it testMCTimings}}
def testMCTimings():

\begin{lstlisting}
def testMCTimings():
\end{lstlisting}


\newpage
\section{TestFinBarrierOption}

\subsection{Function {\it test\_FinBarrierOption}}
def test\_FinBarrierOption():

\begin{lstlisting}
def test_FinBarrierOption():
\end{lstlisting}


\newpage
\section{TestFinBasketOption}

\subsection{Function {\it test\_FinBasketOption}}
def test\_FinBasketOption():

\begin{lstlisting}
def test_FinBasketOption():
\end{lstlisting}


\newpage
\section{TestFinBinomialTree}

\subsection{Function {\it test\_FinBinomialTree}}
def test\_FinBinomialTree():

\begin{lstlisting}
def test_FinBinomialTree():
\end{lstlisting}


\newpage
\section{TestFinBond}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(valuationDate):

\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinBond}}
def test\_FinBond():

\begin{lstlisting}
def test_FinBond():
\end{lstlisting}


\newpage
\section{TestFinBondFutures}

\subsection{Function {\it test\_FinBondFuture}}
def test\_FinBondFuture():

\begin{lstlisting}
def test_FinBondFuture():
\end{lstlisting}


\newpage
\section{TestFinCDS}

\subsection{Function {\it test\_CDSFastApproximation}}
def test\_CDSFastApproximation():

\begin{lstlisting}
def test_CDSFastApproximation():
\end{lstlisting}

\subsection{Function {\it test\_CDSCurveRepricing}}
def test\_CDSCurveRepricing():

\begin{lstlisting}
def test_CDSCurveRepricing():
\end{lstlisting}

\subsection{Function {\it test\_CDSCurveBuildTiming}}
def test\_CDSCurveBuildTiming():

\begin{lstlisting}
def test_CDSCurveBuildTiming():
\end{lstlisting}

\subsection{Function {\it test\_CurveBuild}}
def test\_CurveBuild():

\begin{lstlisting}
def test_CurveBuild():
\end{lstlisting}

\subsection{Function {\it buildFullIssuerCurve}}
def buildFullIssuerCurve(mktSpreadBump,irBump):

\begin{lstlisting}
def buildFullIssuerCurve(mktSpreadBump,irBump):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDS}}
def test\_fullPriceCDS():

\begin{lstlisting}
def test_fullPriceCDS():
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSConvergence}}
def test\_fullPriceCDSConvergence():

\begin{lstlisting}
def test_fullPriceCDSConvergence():
\end{lstlisting}

\subsection{Function {\it test\_CDSDateGeneration}}
def test\_CDSDateGeneration():

\begin{lstlisting}
def test_CDSDateGeneration():
\end{lstlisting}


\newpage
\section{TestFinCDSBasket}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it loadHomogeneousSpreadCurves}}
numCredits):

\begin{lstlisting}
def loadHomogeneousSpreadCurves(valuationDate,
                      liborCurve,
                      cdsSpread3Y,
                      cdsSpread5Y,
                      cdsSpread7Y,
                      cdsSpread10Y,
                      numCredits):
\end{lstlisting}

\subsection{Function {\it loadHeterogeneousSpreadCurves}}
def loadHeterogeneousSpreadCurves(valuationDate,liborCurve):

\begin{lstlisting}
def loadHeterogeneousSpreadCurves(valuationDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_FinCDSBasket}}
def test\_FinCDSBasket():

\begin{lstlisting}
def test_FinCDSBasket():
\end{lstlisting}


\newpage
\section{TestFinCDSCurve}

\subsection{Function {\it test\_FinCDSCurve}}
def test\_FinCDSCurve():

\begin{lstlisting}
def test_FinCDSCurve():
\end{lstlisting}


\newpage
\section{TestFinCDSIndex}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate,liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_valueCDSIndex}}
def test\_valueCDSIndex():

\begin{lstlisting}
def test_valueCDSIndex():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexAdjustHazards}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate,liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_performCDSIndexHazardRateAdjustment}}
def test\_performCDSIndexHazardRateAdjustment():

\begin{lstlisting}
def test_performCDSIndexHazardRateAdjustment():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexAdjustSpreads}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate,liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_CDSIndexAdjustSpreads}}
def test\_CDSIndexAdjustSpreads():

\begin{lstlisting}
def test_CDSIndexAdjustSpreads():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexOption}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildFlatIssuerCurve}}
def buildFlatIssuerCurve(tradeDate,liborCurve,spread, recoveryRate):

\begin{lstlisting}
def buildFlatIssuerCurve(tradeDate,liborCurve,spread, recoveryRate):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSIndexOption}}
def test\_fullPriceCDSIndexOption():

\begin{lstlisting}
def test_fullPriceCDSIndexOption():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexPortfolio}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate,liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_CDSIndexPortfolio}}
def test\_CDSIndexPortfolio():

\begin{lstlisting}
def test_CDSIndexPortfolio():
\end{lstlisting}


\newpage
\section{TestFinCDSOption}

\subsection{Function {\it buildFullIssuerCurve}}
def buildFullIssuerCurve(tradeDate):

\begin{lstlisting}
def buildFullIssuerCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSwaption}}
def test\_fullPriceCDSwaption():

\begin{lstlisting}
def test_fullPriceCDSwaption():
\end{lstlisting}


\newpage
\section{TestFinCDSTranche}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it loadHomogeneousCDSCurves}}
numCredits):

\begin{lstlisting}
def loadHomogeneousCDSCurves(valuationDate,
                      liborCurve,
                      cdsSpread3Y,
                      cdsSpread5Y,
                      cdsSpread7Y,
                      cdsSpread10Y,
                      numCredits):
\end{lstlisting}

\subsection{Function {\it loadHeterogeneousSpreadCurves}}
def loadHeterogeneousSpreadCurves(valuationDate,liborCurve):

\begin{lstlisting}
def loadHeterogeneousSpreadCurves(valuationDate,liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_FinCDSTranche}}
def test\_FinCDSTranche():

\begin{lstlisting}
def test_FinCDSTranche():
\end{lstlisting}


\newpage
\section{TestFinCIRRateModel}

\subsection{Function {\it test\_FinCIRRateModel}}
def test\_FinCIRRateModel():

\begin{lstlisting}
def test_FinCIRRateModel():
\end{lstlisting}


\newpage
\section{TestFinCompoundOption}

\subsection{Function {\it test\_FinCompoundOption}}
def test\_FinCompoundOption():

\begin{lstlisting}
def test_FinCompoundOption():
\end{lstlisting}


\newpage
\section{TestFinDate}

\subsection{Function {\it test\_FinDate}}
def test\_FinDate():

\begin{lstlisting}
def test_FinDate():
\end{lstlisting}


\newpage
\section{TestFinDayCount}

\subsection{Function {\it test\_FinDayCount}}
def test\_FinDayCount():

\begin{lstlisting}
def test_FinDayCount():
\end{lstlisting}


\newpage
\section{TestFinDigitalOption}

\subsection{Function {\it test\_FinDigitalOption}}
def test\_FinDigitalOption():

\begin{lstlisting}
def test_FinDigitalOption():
\end{lstlisting}


\newpage
\section{TestFinDiscountCurve}

\subsection{Function {\it test\_FinDiscountCurve}}
def test\_FinDiscountCurve():

\begin{lstlisting}
def test_FinDiscountCurve():
\end{lstlisting}


\newpage
\section{TestFinFlatCurve}

\subsection{Function {\it test\_FinFlatCurve}}
def test\_FinFlatCurve():

\begin{lstlisting}
def test_FinFlatCurve():
\end{lstlisting}


\newpage
\section{TestFinFloatingRateNote}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(valuationDate):

\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinFloatingRateNote}}
def test\_FinFloatingRateNote():

\begin{lstlisting}
def test_FinFloatingRateNote():
\end{lstlisting}


\newpage
\section{TestFinHestonModel}

\subsection{Function {\it testAnalyticalModels}}
def testAnalyticalModels():

\begin{lstlisting}
def testAnalyticalModels():
\end{lstlisting}

\subsection{Function {\it testMonteCarlo}}
def testMonteCarlo():

\begin{lstlisting}
def testMonteCarlo():
\end{lstlisting}


\newpage
\section{TestFinInterpolate}

\subsection{Function {\it test\_FinInterpolate}}
def test\_FinInterpolate():

\begin{lstlisting}
def test_FinInterpolate():
\end{lstlisting}


\newpage
\section{TestFinLiborCapFloor}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps(valuationDate):

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinLiborCapFloor}}
def test\_FinLiborCapFloor():       

\begin{lstlisting}
def test_FinLiborCapFloor():       
\end{lstlisting}


\newpage
\section{TestFinLiborOneCurve}

\subsection{Function {\it test\_FinLiborDepositsOnly}}


\begin{lstlisting}
def test_FinLiborDepositsOnly():
\end{lstlisting}

\subsection{Function {\it test\_FinLiborFRAsOnly}}


\begin{lstlisting}
def test_FinLiborFRAsOnly():
\end{lstlisting}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps():

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps():
\end{lstlisting}


\newpage
\section{TestFinLiborSwap}

\subsection{Function {\it buildLiborCurve}}


\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_LiborSwap}}
Now perform a valuation after the swap has seasoned but with thesame curve being used for discounting and working out the implied future Libor rates. 

\begin{lstlisting}
def test_LiborSwap(): 
\end{lstlisting}


\newpage
\section{TestFinLiborSwaption}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps(valuationDate):

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinLiborSwaption}}
def test\_FinLiborSwaption():

\begin{lstlisting}
def test_FinLiborSwaption():
\end{lstlisting}


\newpage
\section{TestFinLookbackOption}

\subsection{Function {\it test\_FinLookBackOption}}
def test\_FinLookBackOption():

\begin{lstlisting}
def test_FinLookBackOption():
\end{lstlisting}


\newpage
\section{TestFinLossDbnBuilder}

\subsection{Function {\it test\_FinLossDbnBuilder}}
def test\_FinLossDbnBuilder():

\begin{lstlisting}
def test_FinLossDbnBuilder():
\end{lstlisting}


\newpage
\section{TestFinMath}

\subsection{Function {\it test\_FinMath}}
def test\_FinMath():

\begin{lstlisting}
def test_FinMath():
\end{lstlisting}


\newpage
\section{TestFinNelsonSiegelCurve}

\subsection{Function {\it test\_FinNelsonSiegelCurve}}
def test\_FinNelsonSiegelCurve():

\begin{lstlisting}
def test_FinNelsonSiegelCurve():
\end{lstlisting}


\newpage
\section{TestFinNelsonSiegelSvenssonCurve}

\subsection{Function {\it test\_FinNelsonSiegelSvenssonCurve}}
def test\_FinNelsonSiegelSvenssonCurve():

\begin{lstlisting}
def test_FinNelsonSiegelSvenssonCurve():
\end{lstlisting}


\newpage
\section{TestFinOIS}

\subsection{Function {\it test\_OIS}}
def test\_OIS(): 

\begin{lstlisting}
def test_OIS(): 
\end{lstlisting}


\newpage
\section{TestFinPieceCurve}

\subsection{Function {\it test\_FinPieceCurve}}
\#def test\_FinPieceCurve():

\begin{lstlisting}
#def test_FinPieceCurve():
\end{lstlisting}


\newpage
\section{TestFinPolynomialCurve}

\subsection{Function {\it test\_FinPolynomialCurve}}
def test\_FinPolynomialCurve(): 

\begin{lstlisting}
def test_FinPolynomialCurve(): 
\end{lstlisting}


\newpage
\section{TestFinProcessSimulator}

\subsection{Function {\it test\_FinProcessSimulator}}
def test\_FinProcessSimulator():

\begin{lstlisting}
def test_FinProcessSimulator():
\end{lstlisting}


\newpage
\section{TestFinRainbowOption}

\subsection{Function {\it test\_FinRainbowOption}}
def test\_FinRainbowOption():

\begin{lstlisting}
def test_FinRainbowOption():
\end{lstlisting}


\newpage
\section{TestFinSABRModel}

\subsection{Function {\it test\_SABR}}
def test\_SABR():

\begin{lstlisting}
def test_SABR():
\end{lstlisting}


\newpage
\section{TestFinSchedule}

\subsection{Function {\it test\_FinSchedule}}
def test\_FinSchedule():

\begin{lstlisting}
def test_FinSchedule():
\end{lstlisting}


\newpage
\section{TestFinStats}

\subsection{Function {\it test\_FinStats}}
def test\_FinStats():

\begin{lstlisting}
def test_FinStats():
\end{lstlisting}


\newpage
\section{TestFinVanillaOption}

\subsection{Function {\it test\_FinVanillaOption}}
def test\_FinVanillaOption():

\begin{lstlisting}
def test_FinVanillaOption():
\end{lstlisting}


\newpage
\section{TestFinVasicekRateModel}

\subsection{Function {\it test\_FinVasicekRateModel}}
def test\_FinVasicekRateModel():

\begin{lstlisting}
def test_FinVasicekRateModel():
\end{lstlisting}


\chapter{..//docs}
\section{Introduction}
This folder is where the project documentation is generated. This is done in Latex.
\end{document}
