\documentclass[twoside,11pt]{book} 

\usepackage{bibentry}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{a4wide} %THIS ONE
\usepackage{color}
\usepackage{ebezier}
\usepackage{graphicx,pstricks}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{framed}
\usepackage[light,all,bottomafter]{draftcopy} 
\usepackage{sectsty} 
\usepackage{index}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{tocloft}
\usepackage{wordlike}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\lstset{language=Python}
 
\makeindex

%\usepackage{tocloft}
%\addtolength{\cftsecnumwidth}{16pt}

\renewcommand{\baselinestretch}{1.1}

%\sectionfont{\Large \bf}
%\subsectionfont{\large \bf}

\headheight=16pt
\topskip=0pt

\newenvironment{itemize*}%
{\begin{itemize}%
\setlength{\leftmargin}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{itemize}}

\newenvironment{enumerate*}%
{\begin{enumerate}%
\setlength{\leftmargini}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{enumerate}}

\newcommand{\figsize}{0.55}
\newcommand{\twofigsize}{0.4}

\newenvironment{example}{
\definecolor{shadecolor}{rgb}{0.9,0.9,0.8}
\begin{shaded}
\vspace{0.2cm} \bf \noindent Example:\normalfont  }
{
\end{shaded}
}

\newenvironment{new}{
\definecolor{shadecolor}{rgb}{0.9,1,1}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{cut}{
\definecolor{shadecolor}{rgb}{1.0,0.6,0.6}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{status}{
\definecolor{shadecolor}{rgb}{0.95,0.5,0.85}
\begin{shaded}
\vspace{0.0cm} \bf \noindent To do:\normalfont}{\end{shaded}}

\leftmargin=0pt
\itemindent=0pt

\usepackage{courier}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}

\begin{document}

\title{{\Huge \bf FinancePy}}
\author{Dominic O'Kane}

\maketitle 

\cleardoublepage

\cftsetindents{section}{1em}{3em}
\setcounter{tocdepth}{1}
\tableofcontents

\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Introduction to FinancePy}

\section*{FinancePy}
FinancePy is a library of native Python functions for valuing, selecting and risk-managing financial assets. 

The aim of this library for me has been to provide a comprehensive and accessible Python library for financial calculations that can be used by students to learn about financial derivatives. It can also be used by academics and practitioners to perform the pricing and risk-management of complex financial products, albeit without any warranties. Users should perform their own testing. See the license for the full disclaimer.

I intend that subsequent versions will also include asset selection, portfolio-level risk management, regulatory calculations and market analysis tools.

In general my objectives have been:

\begin{enumerate}
\item{ To make the code as simple as possible so that students and those with a basic Python fluency can understand and check the code.
}
\item{ To keep all the code in Python so users can look through the code to the lowest level. 
}
\item{ To offset the performance impact of (2) by leveraging Numba to make the code as fast as possible without resorting to Cython.
}
\item{ To make the design product-based rather than model-based so someone wanting to price a specific exotic option can easily find that without having to worry too much about the model – just use the default – unless they want to. 
}
\item{ To make the library as complete as possible so a user can find all their required finance-related functionality in one place. This is better for the user as they only have to learn one interface.
}
\item{ To avoid complex designs as I do not want to make it too hard for unskilled Python programmers to use the library.
}
\item{ To have good documentation and easy-to-follow examples.
}
\item{ To make it easy for interested parties to contribute.
}
\end{enumerate}

In many cases the valuations should be close to if not identical to those produced by financial systems such as Bloomberg. However for some products, larger value differences may arise due to differences in date generation and interpolation schemes. Over time I expect to reduce the size of such differences.


\subsubsection*{Dependencies}
FinancePy depends on Numpy and Numba and Scipy.


\subsubsection*{Installation}
FinancePy can be installed via pip as

pip install financepy


\subsubsection*{Changelog}
See the changelog for a detailed history of changes 


\subsubsection*{Contributions}
Contributions are welcome, as long as you don't mind camel case ;-)


\subsubsection*{License}
MIT

\chapter{financepy.finutils}
\section{Introduction}

This is a collection of modules used across a wide range of FinancePy functions. Examples include date generation, special mathematical functions and useful helper functions for performing some repeated action.

\begin{itemize}
\item{ FinDate is a class for handling dates in a financial setting. Special functions are included for computing IMM dates and CDS dates and moving dates forward by tenors.
}
\item{ FinCalendar is a class for determining which dates are not business dates in a specific region or country.
}
\item{ FinDayCount is a class for determining accrued interest in bonds and also accrual factors in ISDA swap-like contracts.
}
\item{ FinError is a class which handles errors in the calculations done within FinancePy
}
\item{ FinFrequency takes in a frequency type and then returns the number of payments per year
}
\item{ FinGlobalVariables holds the value of constants used across the whole of FinancePy
}
\item{ FinHelperFunctions is a set of helpful functions that can be used in a number of places
}
\item{ FinMath is a set of mathematical functions specific to finance which have been optimised for speed using Numba
}
\item{ FinRateConverter converts rates for one compounding frequency to rates for a different frequency
}
\item{ FinSchedule generates a sequence of cashflow payment dates in accordance with financial market standards
}
\item{ FinStatistics calculates a number of statistical variables such as mean, standard deviation and variance
}
\item{ FinTestCases is the code that underlies the test case framework used across FinancePy
}
\end{itemize}


\newpage
\section{FinCalendar}

\subsubsection{Enumerated Type: FinDayAdjustTypes}
\begin{itemize}
\item{NONE}
\item{FOLLOWING}
\item{MODIFIED\_FOLLOWING}
\item{PRECEDING}
\item{MODIFIED\_PRECEDING}
\end{itemize}

\subsubsection{Enumerated Type: FinCalendarTypes}
\begin{itemize}
\item{TARGET}
\item{US}
\item{UK}
\item{WEEKEND}
\item{JAPAN}
\item{NONE}
\end{itemize}

\subsubsection{Enumerated Type: FinDateGenRuleTypes}
\begin{itemize}
\item{FORWARD}
\item{BACKWARD}
\end{itemize}

\subsection*{Class: FinCalendar(object)}
Class to manage designation of payment dates as holidays according to a regional or country-specific calendar convention specified by the user.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_type}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create a calendar based on a specified calendar type.  

\begin{lstlisting}
    def __init__(self, calendarType):
\end{lstlisting}

\subsubsection*{{\bf adjust}}
Adjust a payment date if it falls on a holiday according to the specified business day convention.  

\begin{lstlisting}
    def adjust(self, dt, busDayConventionType):
\end{lstlisting}

\subsubsection*{{\bf isBusinessDay}}
Determines if a date is a business day according to the specified calendar. If it is it returns True, otherwise False.  

\begin{lstlisting}
    def isBusinessDay(self, dt):
\end{lstlisting}

\subsubsection*{{\bf getHolidayList}}
generates a list of holidays in a specific year for the specified calendar. Useful for diagnostics.  

\begin{lstlisting}
    def getHolidayList(self, year):
\end{lstlisting}

\subsubsection*{{\bf easterMonday}}
Get the day in a given year that is Easter Monday. This is not easy to compute so we rely on a pre-calculated array.  

\begin{lstlisting}
    def easterMonday(self, y):
\end{lstlisting}

\subsubsection*{{\bf str}}
def str(self): 

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinDate}

\subsection*{Class: FinDate()}
Date class to manage dates that is simple to use and includes a number of useful date functions used frequently in Finance.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_y}
\item{\_m}
\item{\_d}
\item{\_excelDate}
\item{\_weekday}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create a date given year, month and day of month. The order is not enforced so 4th July 2019 can be created as FinDate(4,7,2019) or as FinDate(2019,7,4) so long as the middle number is the month. The year must be a 4-digit number greater than or equal to 1900.  

\begin{lstlisting}
    def __init__(self, y_or_d, m, d_or_y):
\end{lstlisting}

\subsubsection*{{\bf fromDatetime}}
Construct a FinDate from a datetime as this is often needed if we receive inputs from other Python objects such as Pandas dataframes.  

\begin{lstlisting}
    def fromDatetime(dt):
\end{lstlisting}

\subsubsection*{{\bf refresh}}
Update internal representation of date as number of days since the 1st Jan 1900. This is same as Excel convention.  

\begin{lstlisting}
    def refresh(self):
\end{lstlisting}

\subsubsection*{{\bf \_\_lt\_\_}}
def \_\_lt\_\_(self, other): 

\begin{lstlisting}
    def __lt__(self, other):
\end{lstlisting}

\subsubsection*{{\bf \_\_gt\_\_}}
def \_\_gt\_\_(self, other): 

\begin{lstlisting}
    def __gt__(self, other):
\end{lstlisting}

\subsubsection*{{\bf \_\_le\_\_}}
def \_\_le\_\_(self, other): 

\begin{lstlisting}
    def __le__(self, other):
\end{lstlisting}

\subsubsection*{{\bf \_\_ge\_\_}}
def \_\_ge\_\_(self, other): 

\begin{lstlisting}
    def __ge__(self, other):
\end{lstlisting}

\subsubsection*{{\bf \_\_sub\_\_}}
def \_\_sub\_\_(self, other): 

\begin{lstlisting}
    def __sub__(self, other):
\end{lstlisting}

\subsubsection*{{\bf \_\_eq\_\_}}
def \_\_eq\_\_(self, other): 

\begin{lstlisting}
    def __eq__(self, other):
\end{lstlisting}

\subsubsection*{{\bf isWeekend}}
returns True if the date falls on a weekend.  

\begin{lstlisting}
    def isWeekend(self):
\end{lstlisting}

\subsubsection*{{\bf addDays}}
Returns a new date that is numDays after the FinDate.  

\begin{lstlisting}
    def addDays(self, numDays):
\end{lstlisting}

\subsubsection*{{\bf addWorkDays}}
Returns a new date that is numDays working days after FinDate.  

\begin{lstlisting}
    def addWorkDays(self, numDays):
\end{lstlisting}

\subsubsection*{{\bf addMonths}}
Returns a new date that is mm months after the FinDate.  

\begin{lstlisting}
    def addMonths(self, mm):
\end{lstlisting}

\subsubsection*{{\bf nextCDSDate}}
Returns a CDS date that is mm months after the FinDate. If no argument is supplied then the next CDS date after today is returned. 

\begin{lstlisting}
    def nextCDSDate(self, mm=0):
\end{lstlisting}

\subsubsection*{{\bf thirdWednesdayOfMonth}}
For a specific month and year this returns the day number of the 3rd Wednesday by scanning through dates in the third week.  

\begin{lstlisting}
    def thirdWednesdayOfMonth(self, m, y):
\end{lstlisting}

\subsubsection*{{\bf nextIMMDate}}
This function returns the next IMM date after the current date This is a 3rd Wednesday of Jun, March, Sep or December  

\begin{lstlisting}
    def nextIMMDate(self):
\end{lstlisting}

\subsubsection*{{\bf addTenor}}
Return the date following the FinDate by a period given by the tenor which is a string consisting of a number and a letter, the letter being d, w, m , y for day, week, month or year. This is case independent. For example 10Y means 10 years while 120m also means 10 years.  

\begin{lstlisting}
    def addTenor(self, tenor):
\end{lstlisting}

\subsubsection*{{\bf datediff}}
Calculate the number of dates between two dates.  

\begin{lstlisting}
    def datediff(d1, d2):
\end{lstlisting}

\subsubsection*{{\bf date}}
def date(self): 

\begin{lstlisting}
    def date(self):
\end{lstlisting}

\subsubsection*{{\bf \_\_str\_\_}}
def \_\_str\_\_(self): 

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf dailyWorkingDaySchedule}}
def dailyWorkingDaySchedule(self, startDate, endDate): 

\begin{lstlisting}
def dailyWorkingDaySchedule(self, startDate, endDate):
\end{lstlisting}

\newpage
\section{FinDayCount}

\subsubsection{Enumerated Type: FinDayCountTypes}
\begin{itemize}
\item{THIRTY\_E\_360\_ISDA}
\item{THIRTY\_E\_360\_PLUS\_ISDA}
\item{ACT\_ACT\_ISDA}
\item{ACT\_ACT\_ICMA}
\item{ACT\_365\_ISDA}
\item{THIRTY\_360}
\item{THIRTY\_360\_BOND}
\item{THIRTY\_E\_360}
\item{ACT\_360}
\item{ACT\_365\_FIXED}
\item{ACT\_365\_LEAP}
\end{itemize}

\subsection*{Class: FinDayCount(object)}
Calculate the fractional day count between two dates according to a specified day count convention.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_type}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create Day Count convention by passing in the Day Count Type.  

\begin{lstlisting}
    def __init__(self, dccType):
\end{lstlisting}

\subsubsection*{{\bf yearFrac}}
Calculate the year fraction between dates dt1 and dt2 using the specified day count convention.  

\begin{lstlisting}
    def yearFrac(self, dt1, dt2, dt3=None):
\end{lstlisting}

\subsubsection*{{\bf \_\_str\_\_}}
Returns the calendar type as a string.  

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\newpage
\section{FinError}

\subsection*{Class: FinError(Exception)}
Simple error class specific to FinPy. Need to decide how to handle FinancePy errors. Work in progress.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_message}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinError object by passing a message string.  

\begin{lstlisting}
    def __init__(self, message):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf func\_name}}
def func\_name(): 

\begin{lstlisting}
def func_name():
\end{lstlisting}

\subsubsection*{{\bf isNotEqual}}
def isNotEqual(x, y, tol=1e-6): 

\begin{lstlisting}
def isNotEqual(x, y, tol=1e-6):
\end{lstlisting}

\newpage
\section{FinFrequency}

\subsubsection{Enumerated Type: FinFrequencyTypes}
\begin{itemize}
\item{ANNUAL}
\item{SEMI\_ANNUAL}
\item{QUARTERLY}
\item{MONTHLY}
\end{itemize}

\subsubsection*{{\bf FinFrequency}}
This is a function that takes in a Frequency Type and returns an integer for the number of times a year a payment occurs. 

\begin{lstlisting}
def FinFrequency(frequencyType):
\end{lstlisting}

\newpage
\section{FinGlobalVariables}

\newpage
\section{FinHelperFunctions}

\subsubsection*{{\bf printTree}}
Function that prints a binomial or trinonial tree to screen for the purpose of debugging.  

\begin{lstlisting}
def printTree(array, depth=None):
\end{lstlisting}

\subsubsection*{{\bf inputFrequency}}
Function takes a frequency number and checks if it is valid.  

\begin{lstlisting}
def inputFrequency(f):
\end{lstlisting}

\subsubsection*{{\bf inputTime}}
Validates a time input in relation to a curve. If it is a float then it returns a float as long as it is positive. If it is a FinDate then it converts it to a float. If it is a Numpy array then it returns the array as long as it is all positive.  

\begin{lstlisting}
def inputTime(dt, curve):
\end{lstlisting}

\subsubsection*{{\bf listdiff}}
Calculate a vector of differences between two equal sized vectors.  

\begin{lstlisting}
def listdiff(a, b):
\end{lstlisting}

\subsubsection*{{\bf dotproduct}}
Fast calculation of dot product using Numba.  

\begin{lstlisting}
def dotproduct(xVector, yVector):
\end{lstlisting}

\subsubsection*{{\bf frange}}
def frange(start, stop, step): 

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\subsubsection*{{\bf normaliseWeights}}
Normalise a vector of weights so that they sum up to 1.0.  

\begin{lstlisting}
def normaliseWeights(wtVector):
\end{lstlisting}

\newpage
\section{FinMath}

\subsubsection*{{\bf isLeapYear}}
Test whether year y is a leap year - if so return True, else False  

\begin{lstlisting}
def isLeapYear(y):
\end{lstlisting}

\subsubsection*{{\bf scale}}
Scale all of the elements of an array by the same amount factor.  

\begin{lstlisting}
def scale(x, factor):
\end{lstlisting}

\subsubsection*{{\bf testMonotonicity}}
Check that an array of doubles is monotonic and strictly increasing.  

\begin{lstlisting}
def testMonotonicity(x):
\end{lstlisting}

\subsubsection*{{\bf testRange}}
Check that all of the values of an array fall between a lower and upper bound.  

\begin{lstlisting}
def testRange(x, lower, upper):
\end{lstlisting}

\subsubsection*{{\bf maximum}}
Determine the array in which each element is the maximum of the corresponding element in two equally length arrays a and b.  

\begin{lstlisting}
def maximum(a, b):
\end{lstlisting}

\subsubsection*{{\bf maxaxis}}
Perform a search for the vector of maximum values over an axis of a 2D Numpy Array  

\begin{lstlisting}
def maxaxis(s):
\end{lstlisting}

\subsubsection*{{\bf minaxis}}
Perform a search for the vector of minimum values over an axis of a 2D Numpy Array  

\begin{lstlisting}
def minaxis(s):
\end{lstlisting}

\subsubsection*{{\bf covar}}
Calculate the Covariance of two arrays of numbers. TODO: check that this works well for Numpy Arrays and add NUMBA function signature to code. Do test of timings against Numpy.  

\begin{lstlisting}
def covar(a, b):
\end{lstlisting}

\subsubsection*{{\bf pairGCD}}
Determine the Greatest Common Divisor of two integers using Euclids algorithm. TODO - compare this with math.gcd(a,b) for speed. Also examine to see if I should not be declaring inputs as integers for NUMBA.  

\begin{lstlisting}
def pairGCD(v1, v2):
\end{lstlisting}

\subsubsection*{{\bf nprime}}
Calculate the first derivative of the Cumulative Normal CDF which is simply the PDF of the Normal Distribution  

\begin{lstlisting}
def nprime(x):
\end{lstlisting}

\subsubsection*{{\bf heaviside}}
Calculate the Heaviside function for x  

\begin{lstlisting}
def heaviside(x):
\end{lstlisting}

\subsubsection*{{\bf frange}}
def frange(start, stop, step): 

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\subsubsection*{{\bf normpdf}}
Calculate the probability density function for a Gaussian (Normal) function at value x 

\begin{lstlisting}
def normpdf(x):
\end{lstlisting}

\subsubsection*{{\bf normcdf\_fast}}
Fast Normal CDF function based on XXX  

\begin{lstlisting}
def normcdf_fast(x):
\end{lstlisting}

\subsubsection*{{\bf normcdf\_integrate}}
Calculation of Normal Distribution CDF by simple integration which can become exact in the limit of the number of steps tending towards infinity. This function is used for checking as it is slow since the number of integration steps is currently hardcoded to 10,000. 

\begin{lstlisting}
def normcdf_integrate(x):
\end{lstlisting}

\subsubsection*{{\bf normcdf\_slow}}
Calculation of Normal Distribution CDF accurate to 1d-15. This method is faster than integration but slower than other approximations. Reference: J.L. Schonfelder, Math Comp 32(1978), pp 1232-1240.  

\begin{lstlisting}
def normcdf_slow(z):
\end{lstlisting}

\subsubsection*{{\bf normcdf}}
This is the Normal CDF function which forks to one of three of the implemented approximations. This is based on the choice of the fast flag variable. A value of 1 is the fast routine, 2 is the slow and 3 is the even slower integration scheme.  

\begin{lstlisting}
def normcdf(x, fastFlag):
\end{lstlisting}

\subsubsection*{{\bf N}}
This is the shortcut to the default Normal CDF function and is currently hardcoded to the fastest of the implemented routines. This is the most widely used way to access the Normal CDF.  

\begin{lstlisting}
def N(x):
\end{lstlisting}

\subsubsection*{{\bf phi3}}
Bivariate Normal CDF function to upper limits $b1$ and $b2$ which uses integration to perform the innermost integral. This may need further refinement to ensure it is optimal as the current range of integration is from -7 and the integration steps are dx = 0.001. This may be excessive.  

\begin{lstlisting}
def phi3(b1, b2, b3, r12, r13, r23):
\end{lstlisting}

\subsubsection*{{\bf norminvcdf}}
This algorithm computes the inverse Normal CDF and is based on the algorithm found at (http:\#home.online.no/~pjacklam/notes/invnorm/) which is by John Herrero (3-Jan-03)  

\begin{lstlisting}
def norminvcdf(p):
\end{lstlisting}

\subsubsection*{{\bf M}}
def M(a, b, c): 

\begin{lstlisting}
def M(a, b, c):
\end{lstlisting}

\subsubsection*{{\bf phi2}}
Drezner and Wesolowsky implementation of bi-variate normal  

\begin{lstlisting}
def phi2(h1, hk, r):
\end{lstlisting}

\subsubsection*{{\bf corrMatrixGenerator}}
Utility function to generate a full rank n x n correlation matrix with a flat correlation structure and value rho.  

\begin{lstlisting}
def corrMatrixGenerator(rho, n):
\end{lstlisting}

\newpage
\section{FinRateConverter}

\subsection*{Class: FinRateConverter(object)}
Convert rates between different compounding conventions. This is not used.  

\subsubsection*{Data Members}
\begin{itemize}
\item{name}
\item{months}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self): 

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsubsection*{{\bf str}}
def str(self): 

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinSchedule}

\subsection*{Class: FinSchedule(object)}
A Schedule is a vector of dates generated according to ISDA standard rules which starts on the next date after the start date and runs up to an end date. Dates are adjusted to a provided calendar. The zeroth element is the PCD and the first element is the NCD  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_endDate}
\item{\_frequencyType}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_adjustedDates}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinSchedule object.  

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType=FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf flows}}
Returns a list of the schedule of dates.  

\begin{lstlisting}
    def flows(self):
\end{lstlisting}

\subsubsection*{{\bf generate}}
Generate schedule of dates according to specified date generation rules and also adjust these dates for holidays according to the business day convention and the specified calendar.  

\begin{lstlisting}
    def generate(self):
\end{lstlisting}

\subsubsection*{{\bf print}}
Print out the details of the schedule and the actual dates. This can be used for providing transparency on schedule calculations.  

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinStatistics}

\subsubsection*{{\bf mean}}
Calculate the arithmetic mean of a vector of numbers x.  

\begin{lstlisting}
def mean(x):
\end{lstlisting}

\subsubsection*{{\bf stdev}}
Calculate the standard deviation of a vector of numbers x.  

\begin{lstlisting}
def stdev(x):
\end{lstlisting}

\subsubsection*{{\bf stderr}}
Calculate the standard error estimate of a vector of numbers x.  

\begin{lstlisting}
def stderr(x):
\end{lstlisting}

\subsubsection*{{\bf var}}
Calculate the variance of a vector of numbers x.  

\begin{lstlisting}
def var(x):
\end{lstlisting}

\subsubsection*{{\bf moment}}
Calculate the m-th moment of a vector of numbers x.  

\begin{lstlisting}
def moment(x, m):
\end{lstlisting}

\subsubsection*{{\bf correlation}}
Calculate the correlation between two series x1 and x2.  

\begin{lstlisting}
def correlation(x1, x2):
\end{lstlisting}

\newpage
\section{FinTestCases}

\subsubsection{Enumerated Type: FinTestCaseMode}
\begin{itemize}
\item{SAVE\_TEST\_CASES}
\item{ANALYSE\_TEST\_CASES}
\item{DEBUG\_TEST\_CASES}
\end{itemize}

\subsection*{Class: FinTestCases()}
Test case framework for FinancePy. - The basic step is that we generate a GOLDEN folder that creates an output file for each testcase which is assumed to be correct. This can be done by running the test cases Python file with the globalTestCaseMode flag set to FinTestCaseMode.SAVE\_TEST\_CASES. - The second step is that we change the value of globalTestCaseMode to FinTestCaseMode.ANALYSE\_TEST\_CASES and then run the test scripts. This time they save a copy of the output to the COMPARE folder. Finally, a function called compareTestCases() is used to compare the new output with the GOLDEN output and states whether anything has changed.  - The output of a test case has three forms each with its own method:  1) print - this outputs comma separated values 2) header - this must precede any print statement and labels the output columns 3) banner - this is any single string line separator  Note that the header TIME is special as it tells the analysis that the value in the corresponding column is a timing and so its value is allowed to change without triggering an error. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_carefulMode}
\item{\_verbose}
\item{\_mode}
\item{\_foldersExist}
\item{\_rootFolder}
\item{\_headerFields}
\item{\_goldenFolder}
\item{\_compareFolder}
\item{\_goldenFilename}
\item{\_compareFilename}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create the TestCase given the module name and whether we are in GOLDEN or COMPARE mode.  

\begin{lstlisting}
    def __init__(self, moduleName, mode):
\end{lstlisting}

\subsubsection*{{\bf print}}
Print comma separated output to GOLDEN or COMPARE directory.  

\begin{lstlisting}
    def print(self, *args):
\end{lstlisting}

\subsubsection*{{\bf banner}}
Print a banner on a line to the GOLDEN or COMPARE directory.  

\begin{lstlisting}
    def banner(self, txt):
\end{lstlisting}

\subsubsection*{{\bf header}}
Print a header on a line to the GOLDEN or COMPARE directory.  

\begin{lstlisting}
    def header(self, *args):
\end{lstlisting}

\subsubsection*{{\bf compareRows}}
Compare the contents of two rows in GOLDEN and COMPARE folders. 

\begin{lstlisting}
    def compareRows(self, goldenRow, compareRow, rowNum):
\end{lstlisting}

\subsubsection*{{\bf compareTestCases}}
Compare output of COMPARE mode to GOLDEN output  

\begin{lstlisting}
    def compareTestCases(self):
\end{lstlisting}


\chapter{financepy.products.equities}
\section{Introduction}

This folder covers a range of equity derivative products. These range from simple Vanilla-style options to more complex payoffs and path-dependent options. \newpage
\section{FinAmericanOption}

\subsubsection{Enumerated Type: FinImplementations}
\begin{itemize}
\item{CRR\_TREE}
\item{BARONE\_ADESI\_APPROX}
\end{itemize}

\subsection*{Class: FinAmericanOption()}
Class that performs the valuation of an American style option on a dividend paying stock. Can easily be extended to price American style FX options.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_optionType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsubsection*{{\bf value}}
numStepsPerYear=100): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model,
              numStepsPerYear=100):
\end{lstlisting}

\subsubsection*{{\bf delta}}
model): 

\begin{lstlisting}
    def delta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf gamma}}
model): 

\begin{lstlisting}
    def gamma(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf vega}}
model): 

\begin{lstlisting}
    def vega(self,
             valueDate,
             stockPrice,
             discountCurve,
             dividendYield,
             model):
\end{lstlisting}

\subsubsection*{{\bf theta}}
model): 

\begin{lstlisting}
    def theta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf rho}}
model): 

\begin{lstlisting}
    def rho(self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf crrTreeVal}}
Value an American option using a Binomial Treee  

\begin{lstlisting}
def crrTreeVal(stockPrice,
               riskFreeRate,
               dividendYield,
               volatility,
               numStepsPerYear,
               timeToExpiry,
               optionType,
               strikePrice,
               isEven):
\end{lstlisting}

\newpage
\section{FinAsianOption}

\subsection*{Class: FinAsianOption(FinOption)}
class FinAsianOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startAveragingDate}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_optionType}
\item{\_numObservations}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
numberOfObservations=0): 

\begin{lstlisting}
    def __init__(self,
                 startAveragingDate,
                 expiryDate,
                 strikePrice,
                 optionType,
                 numberOfObservations=0):
\end{lstlisting}

\subsubsection*{{\bf value}}
accruedAverage=None): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model,
              valuationMethod,
              accruedAverage=None):
\end{lstlisting}

\subsubsection*{{\bf valueGeometric}}
accruedAverage): 

\begin{lstlisting}
    def valueGeometric(self,
                       valueDate,
                       stockPrice,
                       discountCurve,
                       dividendYield,
                       model,
                       accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueCurran}}
accruedAverage): 

\begin{lstlisting}
    def valueCurran(self,
                    valueDate,
                    stockPrice,
                    discountCurve,
                    dividendYield,
                    model,
                    accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueTurnbullWakeman}}
accruedAverage): 

\begin{lstlisting}
    def valueTurnbullWakeman(self,
                             valueDate,
                             stockPrice,
                             discountCurve,
                             dividendYield,
                             model,
                             accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
accruedAverage): 

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths,
                seed,
                accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC\_fast}}
accruedAverage): 

\begin{lstlisting}
    def valueMC_fast(self,
                     valueDate,
                     stockPrice,
                     discountCurve,
                     dividendYield,
                     model,
                     numPaths,
                     seed,
                     accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC\_fast\_CV}}
accruedAverage): 

\begin{lstlisting}
    def valueMC_fast_CV(self,
                        valueDate,
                        stockPrice,
                        discountCurve,
                        dividendYield,
                        model,
                        numPaths,
                        seed,
                        accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC\_NUMBA}}
accruedAverage): 

\begin{lstlisting}
def valueMC_NUMBA(t0, t, tau, K, n, optionType,
                  stockPrice,
                  interestRate,
                  dividendYield,
                  volatility,
                  numPaths,
                  seed,
                  accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC\_fast\_NUMBA}}
accruedAverage): 

\begin{lstlisting}
def valueMC_fast_NUMBA(t0, t, tau, K, n, optionType,
                       stockPrice,
                       interestRate,
                       dividendYield,
                       volatility,
                       numPaths,
                       seed,
                       accruedAverage):
\end{lstlisting}

\subsubsection*{{\bf valueMC\_fast\_CV\_NUMBA}}
v\_g\_exact): 

\begin{lstlisting}
def valueMC_fast_CV_NUMBA(t0, t, tau, K, n, optionType,
                          stockPrice,
                          interestRate,
                          dividendYield,
                          volatility,
                          numPaths,
                          seed,
                          accruedAverage,
                          v_g_exact):
\end{lstlisting}

\newpage
\section{FinBarrierOption}

\subsubsection{Enumerated Type: FinBarrierTypes}
\begin{itemize}
\item{DOWN\_AND\_OUT\_CALL}
\item{DOWN\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_CALL}
\item{UP\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_PUT}
\item{UP\_AND\_IN\_PUT}
\item{DOWN\_AND\_OUT\_PUT}
\item{DOWN\_AND\_IN\_PUT}
\end{itemize}

\subsection*{Class: FinBarrierOption(FinOption)}
class FinBarrierOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_barrierLevel}
\item{\_numObservationsPerYear}
\item{\_optionType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
numObservationsPerYear): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType,
                 barrierLevel,
                 numObservationsPerYear):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            processType,
            modelParams,
            numAnnSteps=252,
            numPaths=10000,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinBasketOption}

\subsection*{Class: FinBasketOption(FinOption)}
class FinBasketOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_optionType}
\item{\_numAssets}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
numAssets): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType,
                 numAssets):
\end{lstlisting}

\subsubsection*{{\bf validate}}
betas): 

\begin{lstlisting}
    def validate(self,
                 stockPrices,
                 dividendYields,
                 volatilities,
                 betas):
\end{lstlisting}

\subsubsection*{{\bf value}}
betas): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrices,
              discountCurve,
              dividendYields,
              volatilities,
              betas):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinBinomialTree}

\subsubsection{Enumerated Type: FinTreePayoffTypes}
\begin{itemize}
\item{FWD\_CONTRACT}
\item{VANILLA\_OPTION}
\item{DIGITAL\_OPTION}
\item{POWER\_CONTRACT}
\item{POWER\_OPTION}
\item{LOG\_CONTRACT}
\item{LOG\_OPTION}
\end{itemize}

\subsubsection{Enumerated Type: FinTreeExerciseTypes}
\begin{itemize}
\item{EUROPEAN}
\item{AMERICAN}
\end{itemize}

\subsection*{Class: FinBinomialTree()}
class FinBinomialTree(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{m\_optionValues}
\item{m\_stockValues}
\item{m\_upProbabilities}
\item{m\_numSteps}
\item{m\_numNodes}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self): 

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsubsection*{{\bf value}}
payoffParams): 

\begin{lstlisting}
    def value(self,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              numSteps,
              valueDate,
              payoff,
              expiryDate,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\subsubsection*{{\bf validatePayoff}}
def validatePayoff(payoffType, payoffParams): 

\begin{lstlisting}
def validatePayoff(payoffType, payoffParams):
\end{lstlisting}

\subsubsection*{{\bf payoffValue}}
def payoffValue(s, payoffType, payoffParams): 

\begin{lstlisting}
def payoffValue(s, payoffType, payoffParams):
\end{lstlisting}

\subsubsection*{{\bf valueOnce}}
payoffParams): 

\begin{lstlisting}
def valueOnce(stockPrice,
              r,
              dividendYield,
              volatility,
              numSteps,
              timeToExpiry,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\newpage
\section{FinBlack}

\subsection*{Class: BlackModel()}
class BlackModel(): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsubsection*{{\bf value}}
callOrPut): 

\begin{lstlisting}
    def value(self,
              forwardRate,
              strikeRate,
              timeToExpiry,
              sigma,
              callOrPut):
\end{lstlisting}

\newpage
\section{FinCompoundOption}

\subsection*{Class: FinCompoundOption(FinOption)}
class FinCompoundOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate1}
\item{\_expiryDate2}
\item{\_strikePrice1}
\item{\_strikePrice2}
\item{\_optionType1}
\item{\_optionType2}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType2): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate1,
                 expiryDate2,
                 strikePrice1,
                 strikePrice2,
                 optionType1,
                 optionType2):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf valueTree}}
numSteps=200): 

\begin{lstlisting}
    def valueTree(self,
                  valueDate,
                  stockPrice,
                  discountCurve,
                  dividendYield,
                  model,
                  numSteps=200):
\end{lstlisting}

\subsubsection*{{\bf impliedStockPrice}}
model): 

\begin{lstlisting}
    def impliedStockPrice(self,
                          stockPrice,
                          expiryDate1,
                          expiryDate2,
                          strikePrice1,
                          strikePrice2,
                          optionType2,
                          interestRate,
                          dividendYield,
                          model):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(s0, *args): 

\begin{lstlisting}
def f(s0, *args):
\end{lstlisting}

\subsubsection*{{\bf valueOnce}}
numSteps): 

\begin{lstlisting}
def valueOnce(stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              t1,
              t2,
              optionType1,
              optionType2,
              k1,
              k2,
              numSteps):
\end{lstlisting}

\newpage
\section{FinDigitalOption}

\subsection*{Class: FinDigitalOption(FinOption)}
class FinDigitalOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_optionType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinEquityModelTypes}

\subsection*{Class: FinEquityModel(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self): 

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection*{Class: FinEquityModelBlackScholes(FinEquityModel)}
class FinEquityModelBlackScholes(FinEquityModel): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, volatility): 

\begin{lstlisting}
    def __init__(self, volatility):
\end{lstlisting}

\subsection*{Class: FinEquityModelHeston(FinEquityModel)}
class FinEquityModelHeston(FinEquityModel): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_meanReversion}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, volatility, meanReversion): 

\begin{lstlisting}
    def __init__(self, volatility, meanReversion):
\end{lstlisting}

\newpage
\section{FinFixedLookbackOption}

\subsubsection{Enumerated Type: FinFixedLookbackOptionTypes}
\begin{itemize}
\item{FIXED\_CALL}
\item{FIXED\_PUT}
\end{itemize}

\subsection*{Class: FinFixedLookbackOption(FinOption)}
class FinFixedLookbackOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_optionType}
\item{\_optionStrike}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionStrike): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 optionType,
                 optionStrike):
\end{lstlisting}

\subsubsection*{{\bf value}}
stockMinMax): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              stockMinMax):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            volatility,
            stockMinMax,
            numPaths=10000,
            numStepsPerYear=252,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinFloatLookbackOption}

\subsubsection{Enumerated Type: FinFloatLookbackOptionTypes}
\begin{itemize}
\item{FLOATING\_CALL}
\item{FLOATING\_PUT}
\end{itemize}

\subsection*{Class: FinFloatLookbackOption(FinOption)}
class FinFloatLookbackOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_optionType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 optionType):
\end{lstlisting}

\subsubsection*{{\bf value}}
stockMinMax): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              stockMinMax):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            volatility,
            stockMinMax,
            numPaths=10000,
            numStepsPerYear=252,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinOption}

\subsubsection{Enumerated Type: FinOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\item{AMERICAN\_CALL}
\item{AMERICAN\_PUT}
\item{DIGITAL\_CALL}
\item{DIGITAL\_PUT}
\item{ASIAN\_CALL}
\item{ASIAN\_PUT}
\item{COMPOUND\_CALL}
\item{COMPOUND\_PUT}
\end{itemize}

\subsubsection{Enumerated Type: FinOptionModelTypes}
\begin{itemize}
\item{BLACKSCHOLES}
\item{ANOTHER}
\end{itemize}

\subsection*{Class: FinOption(object)}
class FinOption(object): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsubsection*{{\bf delta}}
model): 

\begin{lstlisting}
    def delta(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf gamma}}
model): 

\begin{lstlisting}
    def gamma(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf vega}}
model): 

\begin{lstlisting}
    def vega(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf theta}}
model): 

\begin{lstlisting}
    def theta(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsubsection*{{\bf rho}}
model): 

\begin{lstlisting}
    def rho(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\newpage
\section{FinRainbowOption}

\subsubsection{Enumerated Type: FinRainbowOptionTypes}
\begin{itemize}
\item{CALL\_ON\_MAXIMUM}
\item{PUT\_ON\_MAXIMUM}
\item{CALL\_ON\_MINIMUM}
\item{PUT\_ON\_MINIMUM}
\item{CALL\_ON\_NTH}
\item{PUT\_ON\_NTH}
\end{itemize}

\subsection*{Class: FinRainbowOption(FinOption)}
class FinRainbowOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_payoffType}
\item{\_payoffParams}
\item{\_numAssets}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
numAssets): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 payoffType,
                 payoffParams,
                 numAssets):
\end{lstlisting}

\subsubsection*{{\bf validate}}
betas): 

\begin{lstlisting}
    def validate(self,
                 stockPrices,
                 dividendYields,
                 volatilities,
                 betas):
\end{lstlisting}

\subsubsection*{{\bf validatePayoff}}
def validatePayoff(self, payoffType, payoffParams, numAssets): 

\begin{lstlisting}
    def validatePayoff(self, payoffType, payoffParams, numAssets):
\end{lstlisting}

\subsubsection*{{\bf value}}
betas): 

\begin{lstlisting}
    def value(self, 
              valueDate, 
              expiryDate, 
              stockPrices, 
              discountCurve,
              dividendYields, 
              volatilities, 
              betas):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                expiryDate,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\subsubsection*{{\bf payoffValue}}
def payoffValue(s, payoffTypeValue, payoffParams): 

\begin{lstlisting}
def payoffValue(s, payoffTypeValue, payoffParams):
\end{lstlisting}

\subsubsection*{{\bf valueMCFast}}
seed=4242): 

\begin{lstlisting}
def valueMCFast(t,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numAssets,
                payoffType,
                payoffParams,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinVanillaOption}

\subsection*{Class: FinVanillaOption(FinOption)}
class FinVanillaOption(FinOption): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_optionType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf xdelta}}
model): 

\begin{lstlisting}
    def xdelta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf xgamma}}
model): 

\begin{lstlisting}
    def xgamma(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf xvega}}
model): 

\begin{lstlisting}
    def xvega(self,
             valueDate,
             stockPrice,
             discountCurve,
             dividendYield,
             model):
\end{lstlisting}

\subsubsection*{{\bf xtheta}}
model): 

\begin{lstlisting}
    def xtheta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsubsection*{{\bf impliedVolatility}}
price): 

\begin{lstlisting}
    def impliedVolatility(self,
                          valueDate,
                          stockPrice,
                          discountCurve,
                          dividendYield,
                          price):
\end{lstlisting}

\subsubsection*{{\bf valueMC}}
seed=4242): 

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\subsubsection*{{\bf value\_MC\_OLD}}
seed=4242): 

\begin{lstlisting}
    def value_MC_OLD(self,
                     valueDate,
                     stockPrice,
                     discountCurve,
                     dividendYield,
                     terminalS,
                     seed=4242):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(volatility, *args): 

\begin{lstlisting}
def f(volatility, *args):
\end{lstlisting}

\subsubsection*{{\bf fvega}}
def fvega(volatility, *args): 

\begin{lstlisting}
def fvega(volatility, *args):
\end{lstlisting}

\newpage
\section{FinVarianceSwap}

\subsection*{Class: FinVarianceSwap(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_maturityDate}
\item{\_strikeVariance}
\item{\_notional}
\item{\_payStrike}
\item{\_numPutOptions}
\item{\_numCallOptions}
\item{\_putStrikes}
\item{\_callStrikes}
\item{\_callWts}
\item{\_putWts}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create variance swap contract.  

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDateOrTenor,
                 strikeVariance,
                 notional=ONE_MILLION,
                 payStrikeFlag=True):
\end{lstlisting}

\subsubsection*{{\bf value}}
Calculate the value of the variance swap based on the realised volatility to the valuation date, the forward looking implied volatility to the maturity date using the libor discount curve.  

\begin{lstlisting}
    def value(self, 
              valuationDate, 
              realisedVar, 
              fairStrikeVar, 
              liborCurve):
\end{lstlisting}

\subsubsection*{{\bf fairStrikeApprox}}
This is an approximation of the fair strike variance by Demeterfi et al. (1999) which assumes that sigma(K) = sigma(F) - b(K-F)/F where F is the forward stock price and sigma(F) is the ATM forward vol.  

\begin{lstlisting}
    def fairStrikeApprox(self,
                         valuationDate,
                         fwdStockPrice,
                         strikes,
                         volatilities):
\end{lstlisting}

\subsubsection*{{\bf fairStrike}}
Calculate the implied variance according to the volatility surface using a static replication methodology with a specially weighted portfolio of put and call options across a range of strikes using the approximate method set out by Demeterfi et al. 1999.  

\begin{lstlisting}
    def fairStrike(self,
                   valuationDate,
                   stockPrice,
                   dividendYield,
                   volatilityCurve,
                   numCallOptions,
                   numPutOptions,
                   strikeSpacing,
                   discountCurve,
                   useForward=True):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(x): return (2.0/tmat)*((x-sstar)/sstar-log(x/sstar)) 

\begin{lstlisting}
        def f(x): return (2.0/tmat)*((x-sstar)/sstar-log(x/sstar))
\end{lstlisting}

\subsubsection*{{\bf realisedVariance}}
Calculate the realised variance according to market standard calculations which can either use log or percentage returns. 

\begin{lstlisting}
    def realisedVariance(self, closePrices, useLogs=True):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}


\chapter{financepy.products.credit}
\section{Introduction}

This folder contains a set of credit-related assets ranging from CDS to CDS options, to CDS indices, CDS index options and then to CDS tranches. They are as follows:
\begin{itemize}
\item{ FinCDS is a credit default swap contract. It includes schedule generation, contract valuation and risk-management functionality.
}
\item{ FinCDSBasket is a credit default basket such as a first-to-default basket. The class includes valuation according to the Gaussian copula.
}
\item{ FinCDSIndexOption is an option on an index of CDS such as CDX or iTraxx. A full valuation model is included.
}
\item{ FinCDSOption is an option on a single CDS. The strike is expressed in spread terms and the option is European style. It is different from an option on a CDS index option. A suitable pricing model is provided which adjusts for the risk that the reference credit defaults before the option expiry date.
}
\item{ FinCDSTranche is a synthetic CDO tranche. This is a financial derivative which takes a loss if the total loss on the portfolio exceeds a lower threshold K1 and which is wiped out if it exceeds a higher threshold K2. The value depends on the default correlation between the assets in the portfolio of credits. This also includes a valuation model based on the Gaussian copula model.
}
\end{itemize}
\newpage
\section{FinCDS}

\subsection*{Class: FinCDS(object)}
A class which manages a Credit Default Swap. It performs schedule generation and the valuation and risk management of CDS.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_stepInDate}
\item{\_maturityDate}
\item{\_coupon}
\item{\_notional}
\item{\_longProtection}
\item{\_dayCountType}
\item{\_dateGenRuleType}
\item{\_calendarType}
\item{\_frequencyType}
\item{\_busDayAdjustType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
stepInDate - FinDate that is the date protection starts (usually T+1) runningCoupon - Size of coupon on premium leg  

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDateOrTenor,
                 runningCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf generateAdjustedCDSPaymentDates}}
Generate CDS payment dates which have been holiday adjusted. 

\begin{lstlisting}
    def generateAdjustedCDSPaymentDates(self):
\end{lstlisting}

\subsubsection*{{\bf calcFlows}}
Calculate cash flow amounts on premium leg.  

\begin{lstlisting}
    def calcFlows(self):
\end{lstlisting}

\subsubsection*{{\bf value}}
Valuation of a CDS contract on a specific valuation date given  an issuer curve and a contract recovery rate. 

\begin{lstlisting}
    def value(self,
              valuationDate,
              issuerCurve,
              contractRecovery=standardRecovery,
              pv01Method=0,
              prot_method=0,
              numStepsPerYear=25):
\end{lstlisting}

\subsubsection*{{\bf creditDV01}}
Calculation of the change in the value of the CDS contract for a  one basis point change in the level of the CDS curve. 

\begin{lstlisting}
    def creditDV01(self,
                   valuationDate,
                   issuerCurve,
                   contractRecovery=standardRecovery,
                   pv01Method=0,
                   prot_method=0,
                   numStepsPerYear=25):
\end{lstlisting}

\subsubsection*{{\bf interestDV01}}
Calculation of the interest DV01 based on a simple bump of  the discount factors and reconstruction of the CDS curve.  

\begin{lstlisting}
    def interestDV01(self,
                     valuationDate,
                     issuerCurve,
                     contractRecovery=standardRecovery,
                     pv01Method=0,
                     prot_method=0,
                     numStepsPerYear=25):
\end{lstlisting}

\subsubsection*{{\bf cashSettlementAmount}}
Value of the contract on the settlement date including accrued interest.  

\begin{lstlisting}
    def cashSettlementAmount(self,
                             valuationDate,
                             settlementDate,
                             issuerCurve,
                             contractRecovery=standardRecovery,
                             pv01Method=0,
                             prot_method=0,
                             numStepsPerYear=25):
\end{lstlisting}

\subsubsection*{{\bf cleanPrice}}
Value of the CDS contract excluding accrued interest.  

\begin{lstlisting}
    def cleanPrice(self,
                   valuationDate,
                   issuerCurve,
                   contractRecovery=standardRecovery,
                   pv01Method=0,
                   prot_method=0,
                   numStepsPerYear=52):
\end{lstlisting}

\subsubsection*{{\bf riskyPV01\_OLD}}
RiskyPV01 of the contract using the OLD method.  

\begin{lstlisting}
    def riskyPV01_OLD(self,
                      valuationDate,
                      issuerCurve,
                      pv01Method=0):
\end{lstlisting}

\subsubsection*{{\bf accruedDays}}
Number of days between the previous coupon and the currrent step  in date.  

\begin{lstlisting}
    def accruedDays(self):
\end{lstlisting}

\subsubsection*{{\bf accruedInterest}}
Calculate the amount of accrued interest that has accrued from the previous coupon date (PCD) to the stepInDate of the CDS contract.  

\begin{lstlisting}
    def accruedInterest(self):
\end{lstlisting}

\subsubsection*{{\bf protectionLegPV}}
Calculates the protection leg PV of the CDS by calling into the fast NUMBA code that has been defined above.  

\begin{lstlisting}
    def protectionLegPV(self,
                        valuationDate,
                        issuerCurve,
                        contractRecovery=standardRecovery,
                        numStepsPerYear=25,
                        protMethod=0):
\end{lstlisting}

\subsubsection*{{\bf riskyPV01}}
The riskyPV01 is the present value of a risky one dollar paid on  the premium leg of a CDS contract.  

\begin{lstlisting}
    def riskyPV01(self,
                  valuationDate,
                  issuerCurve,
                  pv01Method=0):
\end{lstlisting}

\subsubsection*{{\bf premiumLegPV}}
Value of the premium leg of a CDS.  

\begin{lstlisting}
    def premiumLegPV(self,
                     valuationDate,
                     issuerCurve,
                     pv01Method=0):
\end{lstlisting}

\subsubsection*{{\bf parSpread}}
Breakeven CDS coupon that would make the value of the CDS contract  equal to zero.  

\begin{lstlisting}
    def parSpread(self,
                  valuationDate,
                  issuerCurve,
                  contractRecovery=standardRecovery,
                  numStepsPerYear=25,
                  pv01Method=0,
                  protMethod=0):
\end{lstlisting}

\subsubsection*{{\bf valueFastApprox}}
Implementation of fast valuation of the CDS contract using an accurate approximation that avoids curve building.  

\begin{lstlisting}
    def valueFastApprox(self,
                        valuationDate,
                        flatContinuousInterestRate,
                        flatCDSCurveSpread,
                        curveRecovery=standardRecovery,
                        contractRecovery=standardRecovery):
\end{lstlisting}

\subsubsection*{{\bf print}}
print out details of the CDS contract and all of the calculated cashflows  

\begin{lstlisting}
    def print(self, valuationDate):
\end{lstlisting}

\subsubsection*{{\bf printFlows}}
def printFlows(self, issuerCurve): 

\begin{lstlisting}
    def printFlows(self, issuerCurve):
\end{lstlisting}

\subsubsection*{{\bf riskyPV01\_NUMBA}}
Fast calculation of the risky PV01 of a CDS using NUMBA. The output is a numpy array of the full and clean risky PV01. 

\begin{lstlisting}
def riskyPV01_NUMBA(teff,
                    accrualFactorPCDToNow,
                    paymentTimes,
                    yearFracs,
                    npLiborTimes,
                    npLiborValues,
                    npSurvTimes,
                    npSurvValues,
                    pv01Method):
\end{lstlisting}

\subsubsection*{{\bf protectionLegPV\_NUMBA}}
Fast calculation of the CDS protection leg PV using NUMBA to speed up the numerical integration over time.  

\begin{lstlisting}
def protectionLegPV_NUMBA(teff,
                          tmat,
                          npLiborTimes,
                          npLiborValues,
                          npSurvTimes,
                          npSurvValues,
                          contractRecovery,
                          numStepsPerYear,
                          protMethod):
\end{lstlisting}

\newpage
\section{FinCDSBasket}

\subsection*{Class: FinCDSBasket(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_stepInDate}
\item{\_maturityDate}
\item{\_notional}
\item{\_coupon}
\item{\_longProtection}
\item{\_dayCountType}
\item{\_dateGenRuleType}
\item{\_calendarType}
\item{\_frequencyType}
\item{\_busDayAdjustType}
\item{\_cdsContract}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 notional=ONE_MILLION,
                 coupon=0.0,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf valueLegs\_MC}}
Value the legs of the default basket using Monte Carlo. The default times are an input so this valuation is not model dependent.  

\begin{lstlisting}
    def valueLegs_MC(self,
                     valuationDate,
                     nToDefault,
                     defaultTimes,
                     issuerCurves,
                     liborCurve):
\end{lstlisting}

\subsubsection*{{\bf valueGaussian\_MC}}
Value the default basket using a Gaussian copula model. This  depends on the issuer curves and correlation matrix.  

\begin{lstlisting}
    def valueGaussian_MC(self,
                         valuationDate,
                         nToDefault,
                         issuerCurves,
                         correlationMatrix,
                         liborCurve,
                         numTrials,
                         seed):
\end{lstlisting}

\subsubsection*{{\bf valueStudentT\_MC}}
Value the default basket using the Student-T copula.  

\begin{lstlisting}
    def valueStudentT_MC(self,
                         valuationDate,
                         nToDefault,
                         issuerCurves,
                         correlationMatrix,
                         degreesOfFreedom,
                         liborCurve,
                         numTrials,
                         seed):
\end{lstlisting}

\subsubsection*{{\bf value1FGaussian\_Homo}}
Value default basket using 1 factor Gaussian copula and analytical approach which is only exact when all recovery rates are the same.  

\begin{lstlisting}
    def value1FGaussian_Homo(self,
                             valuationDate,
                             nToDefault,
                             issuerCurves,
                             betaVector,
                             liborCurve,
                             numPoints=50):
\end{lstlisting}

\newpage
\section{FinCDSIndexOption}

\subsection*{Class: FinCDSIndexOption(object)}
Class to manage the pricing and risk management of an option to enter into a CDS index. Different pricing algorithms are presented. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_maturityDate}
\item{\_indexCoupon}
\item{\_strikeCoupon}
\item{\_notional}
\item{\_longProtection}
\item{\_dayCountType}
\item{\_dateGenRuleType}
\item{\_calendarType}
\item{\_frequencyType}
\item{\_businessDateAdjustType}
\item{\_cdsContract}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 maturityDate,
                 indexCoupon,
                 strikeCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf valueAdjustedBlack}}
This approach uses two adjustments to Blacks option pricing model to value an option on a CDS index.  

\begin{lstlisting}
    def valueAdjustedBlack(self,
                           valuationDate,
                           indexCurve,
                           indexRecovery,
                           liborCurve,
                           sigma):
\end{lstlisting}

\subsubsection*{{\bf valueAnderson}}
This function values a CDS index option following approach by Anderson (2006). This ensures that the no-arbitrage relationship between the consituent CDS contract and the CDS index is enforced. It models the forward spread as a log-normally distributed quantity and uses the credit triangle to compute the forward RPV01.  

\begin{lstlisting}
    def valueAnderson(self,
                      valuationDate,
                      issuerCurves,
                      indexRecovery,
                      sigma):
\end{lstlisting}

\subsubsection*{{\bf solveForX}}
Function to solve for the arbitrage free  

\begin{lstlisting}
    def solveForX(self,
                  valuationDate,
                  sigma,
                  indexCoupon,
                  indexRecovery,
                  liborCurve,
                  expH):
\end{lstlisting}

\subsubsection*{{\bf calcObjFunc}}
An internal function used in the Anderson valuation.  

\begin{lstlisting}
    def calcObjFunc(self,
                    x,
                    valuationDate,
                    sigma,
                    indexCoupon,
                    indexRecovery,
                    liborCurve):
\end{lstlisting}

\subsubsection*{{\bf calcIndexPayerOptionPrice}}
Calculates the intrinsic value of the index payer swap and the value of the index payer option which are both returned in an array.  

\begin{lstlisting}
    def calcIndexPayerOptionPrice(self,
                                  valuationDate,
                                  x,
                                  sigma,
                                  indexCoupon,
                                  strikeValue,
                                  liborCurve,
                                  indexRecovery):
\end{lstlisting}

\newpage
\section{FinCDSIndexPortfolio}

\subsection*{Class: FinCDSIndexPortfolio()}
This class manages the calculations associated with an equally weighted portfolio of CDS contracts with the same maturity date.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_dayCountType}
\item{\_dateGenRuleType}
\item{\_calendarType}
\item{\_frequencyType}
\item{\_businessDateAdjustType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinCDSIndexPortfolio object. Note that all of the inputs have a default value which reflects the CDS market standard.  

\begin{lstlisting}
    def __init__(self,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf intrinsicRPV01}}
Calculation of the risky PV01 of the CDS porfolio by taking the average of the risky PV01s of each contract.  

\begin{lstlisting}
    def intrinsicRPV01(self,
                       valuationDate,
                       stepInDate,
                       maturityDate,
                       issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf intrinsicProtectionLegPV}}
Calculation of the intrinsic protection leg value of the CDS porfolio by taking the average sum the protection legs of each contract.  

\begin{lstlisting}
    def intrinsicProtectionLegPV(self,
                                 valuationDate,
                                 stepInDate,
                                 maturityDate,
                                 issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf intrinsicSpread}}
Calculation of the intrinsic spread of the CDS portfolio as the one which would make the value of the protection legs equal to the value of the premium legs if all premium legs paid the same spread.  

\begin{lstlisting}
    def intrinsicSpread(self,
                        valuationDate,
                        stepInDate,
                        maturityDate,
                        issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf averageSpread}}
Calculates the average par CDS spread of the CDS portfolio.  

\begin{lstlisting}
    def averageSpread(self,
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf totalSpread}}
Calculates the total CDS spread of the CDS portfolio by summing  over all of the issuers and adding the spread with no weights.  

\begin{lstlisting}
    def totalSpread(self,
                    valuationDate,
                    stepInDate,
                    maturityDate,
                    issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf minSpread}}
Calculates the minimum par CDS spread across all of the issuers in the CDS portfolio.  

\begin{lstlisting}
    def minSpread(self,
                  valuationDate,
                  stepInDate,
                  maturityDate,
                  issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf maxSpread}}
Calculates the maximum par CDS spread across all of the issuers in the CDS portfolio.  

\begin{lstlisting}
    def maxSpread(self,
                  valuationDate,
                  stepInDate,
                  maturityDate,
                  issuerCurves):
\end{lstlisting}

\subsubsection*{{\bf spreadAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices. This approach uses an iterative scheme but is slow as it has to use a CDS curve bootstrap required when each trial spread adjustment is made. 

\begin{lstlisting}
    def spreadAdjustIntrinsic(valuationDate,
                              issuerCurves,
                              indexCoupons,
                              indexUpfronts,
                              indexMaturityDates,
                              indexRecoveryRate,
                              tolerance):
\end{lstlisting}

\subsubsection*{{\bf hazardRateAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices. This approach adjusts the hazard rates and so avoids the slowish CDS curve bootstrap required when a spread adjustment is made. 

\begin{lstlisting}
    def hazardRateAdjustIntrinsic(valuationDate,
                                  issuerCurves,
                                  indexCoupons,
                                  indexUpfronts,
                                  indexMaturityDates,
                                  indexRecoveryRate,
                                  tolerance,
                                  maxIterations=100):
\end{lstlisting}

\newpage
\section{FinCDSOption}

\subsection*{Class: FinCDSOption()}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_maturityDate}
\item{\_strikeCoupon}
\item{\_longProtection}
\item{\_knockoutFlag}
\item{\_notional}
\item{\_frequencyType}
\item{\_dayCountType}
\item{\_calendarType}
\item{\_businessDateAdjustType}
\item{\_dateGenRuleType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 maturityDate,
                 strikeCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 knockoutFlag=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf value}}
Value the CDS option using Blacks model with an adjustment for any Front End Protection. TODO - Should the CDS be created in the init method ?  

\begin{lstlisting}
    def value(self,
              valuationDate,
              issuerCurve,
              volatility):
\end{lstlisting}

\subsubsection*{{\bf impliedVolatility}}
Calculate the implied CDS option volatility from a price.  

\begin{lstlisting}
    def impliedVolatility(self,
                          valuationDate,
                          issuerCurve,
                          optionValue):
\end{lstlisting}

\subsubsection*{{\bf fvol}}
Root searching function in the calculation of the CDS implied volatility.  

\begin{lstlisting}
def fvol(volatility, *args):
\end{lstlisting}

\newpage
\section{FinCDSTranche}

\subsubsection{Enumerated Type: FinLossDistributionBuilder}
\begin{itemize}
\item{RECURSION}
\item{ADJUSTED\_BINOMIAL}
\item{GAUSSIAN}
\item{LHP}
\end{itemize}

\subsection*{Class: FinCDSTranche(object)}
class FinCDSTranche(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_k1}
\item{\_k2}
\item{\_stepInDate}
\item{\_maturityDate}
\item{\_notional}
\item{\_coupon}
\item{\_longProtection}
\item{\_dayCountType}
\item{\_dateGenRuleType}
\item{\_calendarType}
\item{\_frequencyType}
\item{\_busDayAdjustType}
\item{\_cdsContract}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 k1,
                 k2,
                 notional=ONE_MILLION,
                 coupon=0.0,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf valueBC}}
model=FinLossDistributionBuilder.RECURSION): 

\begin{lstlisting}
    def valueBC(self,
                valuationDate,
                issuerCurves,
                upfront,
                coupon,
                corr1,
                corr2,
                numPoints=50,
                model=FinLossDistributionBuilder.RECURSION):
\end{lstlisting}


\chapter{financepy.products.bonds}
\section{Introduction}

This folder contains a suite of bond-related functionality across a set of files and classes. They are as follows:

\begin{itemize}
\item{ FinAnnuity is a stream of cashflows that is generated and can be priced.
}
\item{ FinBond is a basic fixed coupon bond with all of the associated duration and convexity measures. It also includes some common spread measures such as the asset swap spread and the option adjusted spread.
}
\item{ FinBondCallable is a bond that has an embedded call and put option. A number of rate models pricing functions have been included to allow such bonds to be priced and risk-managed.
}
\item{ FinBondFuture is a bond future that has functionality around determination of the conversion factor and calculation of the invoice price and determination of the cheapest to deliver. 
}
\item{ FinBondMarket is a database of country-specific bond market conventions that can be referenced. These include settlement days and accrued interest conventions.
}
\item{ FinBondOption is a bond option class that includes a number of valuation models for pricing both European and American style bond options. Models for European options include a Lognormal Price, Hull-White (HW) and Black-Karasinski (BK). The HW valuation is fast as it uses Jamshidians decomposition trick. American options can also be priced using a HW and BK trinomial tree. The details are abstracted away making it easy to use.
}
\item{ FinConvertibleBond enables the pricing and risk-management of convertible bonds. The model is a binomial tree implementation of Black-Scholes which allows for discrete dividends, embedded puts and calls, and a delayed start of the conversion option.
}
\item{ FinFloatingNote enables the pricing and risk-management of a bond with floating rate coupons. Discount margin calculations are provided.
}
\item{ FinMortgage generates the periodic cashflows for an interest-only and a repayment mortgage. }
\end{itemize}
\newpage
\section{FinAnnuity}

\subsection*{Class: FinAnnuity(object)}
An annuity is a vector of dates and flows generated according to ISDA  standard rules which starts on the next date after the start date  (effective date) and runs up to an end date. Dates are then adjusted  according to a specified calendar.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_endDate}
\item{\_frequencyType}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_dayCountConventionType}
\item{\_schedule}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dayCountConventionType=FinDayCountTypes.ACT\_360): 

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType=FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD,
                 dayCountConventionType=FinDayCountTypes.ACT_360):
\end{lstlisting}

\subsubsection*{{\bf generate}}
def generate(self, startDate): 

\begin{lstlisting}
    def generate(self, startDate):
\end{lstlisting}

\subsubsection*{{\bf dump}}
def dump(self): 

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinBond}

\subsubsection{Enumerated Type: FinYieldConventions}
\begin{itemize}
\item{UK\_DMO}
\item{US\_STREET}
\item{US\_TREASURY}
\end{itemize}

\subsection*{Class: FinBond(object)}
Class for fixed coupon bonds and performing related analytics. These are bullet bonds which means they have regular coupon payments of a known size that are paid on known dates plus a payment of par at maturity. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_maturityDate}
\item{\_coupon}
\item{\_frequencyType}
\item{\_accrualType}
\item{\_frequency}
\item{\_face}
\item{\_settlementDate}
\item{\_accrued}
\item{\_accruedDays}
\item{\_alpha}
\item{\_flowDates}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinBond object by providing Maturity Date, Frequency, coupon and the accrual convention type.  

\begin{lstlisting}
    def __init__(self,
                 maturityDate,
                 coupon,
                 frequencyType,
                 accrualType,
                 face=100.0):
\end{lstlisting}

\subsubsection*{{\bf calculateFlowDates}}
Determine the bond cashflow payment dates.  

\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf fullPriceFromYield}}
Calculate the full price of bond from its yield to maturity. This function is vectorised with respect to the yield input.  

\begin{lstlisting}
    def fullPriceFromYield(self, settlementDate, y,
                           convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf dollarDuration}}
Calculate the risk or dP/dy of the bond by bumping.  

\begin{lstlisting}
    def dollarDuration(self, settlementDate, ytm,
                       convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement date given its yield to maturity.  

\begin{lstlisting}
    def macauleyDuration(self, settlementDate, ytm,
                         convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf modifiedDuration}}
Calculate the modified duration of the bondon a settlement date given its yield to maturity.  

\begin{lstlisting}
    def modifiedDuration(self, settlementDate, ytm,
                         convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf convexityFromYield}}
Calculate the bond convexity from the yield to maturity. This function is vectorised with respect to the yield input.  

\begin{lstlisting}
    def convexityFromYield(self, settlementDate, ytm,
                           convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf cleanPriceFromYield}}
Calculate the bond clean price from the yield to maturity. This function is vectorised with respect to the yield input.  

\begin{lstlisting}
    def cleanPriceFromYield(self, settlementDate, ytm,
                            convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsubsection*{{\bf cleanPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-value the bonds cashflows.  

\begin{lstlisting}
    def cleanPriceFromDiscountCurve(self, settlementDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-value the bonds cashflows.  

\begin{lstlisting}
    def fullPriceFromDiscountCurve(self, settlementDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf currentYield}}
Calculate the current yield of the bond which is the coupon divided by the clean price (not the full price) 

\begin{lstlisting}
    def currentYield(self, cleanPrice):
\end{lstlisting}

\subsubsection*{{\bf yieldToMaturity}}
Calculate the bonds yield to maturity by solving the price yield relationship using a one-dimensional root solver.  

\begin{lstlisting}
    def yieldToMaturity(self,
                        settlementDate,
                        cleanPrice,
                        convention=FinYieldConventions.US_TREASURY):
\end{lstlisting}

\subsubsection*{{\bf \_accruedInterest}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date.  

\begin{lstlisting}
    def _accruedInterest(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf assetSwapSpread}}
Calculate the par asset swap spread of the bond. The discount curve is a Libor curve that is passed in. This function is vectorised with respect to the clean price.  

\begin{lstlisting}
    def assetSwapSpread(
            self,
            settlementDate,
            cleanPrice,
            discountCurve,
            swapFloatDayCountConventionType=FinDayCountTypes.ACT_360,
            swapFloatFrequencyType=FinFrequencyTypes.SEMI_ANNUAL,
            swapFloatCalendarType=FinCalendarTypes.WEEKEND,
            swapFloatBusDayAdjustRuleType=FinDayAdjustTypes.FOLLOWING,
            swapFloatDateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf fullPriceFromOAS}}
Calculate the full price of the bond from its OAS given the bond settlement date, a discount curve and the oas as a number.  

\begin{lstlisting}
    def fullPriceFromOAS(self,
                         settlementDate,
                         discountCurve,
                         oas):
\end{lstlisting}

\subsubsection*{{\bf optionAdjustedSpread}}
Return OAS for bullet bond given settlement date, clean bond price and the discount relative to which the spread is to be computed.  

\begin{lstlisting}
    def optionAdjustedSpread(self,
                             settlementDate,
                             cleanPrice,
                             discountCurve):
\end{lstlisting}

\subsubsection*{{\bf printFlows}}
Print a list of the unadjusted coupon payment dates used in analytic calculations for the bond.  

\begin{lstlisting}
    def printFlows(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf priceFromSurvivalCurve}}
Calculate discounted present value of flows assuming default model. This has not been completed.  

\begin{lstlisting}
    def priceFromSurvivalCurve(self,
                               discountCurve,
                               survivalCurve,
                               recoveryRate):
\end{lstlisting}

\subsubsection*{{\bf print}}
Print a list of the unadjusted coupon payment dates used in analytic calculations for the bond.  

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf f}}
Function used to do root search in price to yield calculation.  

\begin{lstlisting}
def f(y, *args):
\end{lstlisting}

\subsubsection*{{\bf g}}
Function used to do root search in price to OAS calculation.  

\begin{lstlisting}
def g(oas, *args):
\end{lstlisting}

\newpage
\section{FinBondCallable}

\newpage
\section{FinBondFuture}

\subsection*{Class: FinBondFuture(object)}
Class for managing futures contracts on government bonds that follows CME conventions and related analytics.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_tickerName}
\item{\_firstDeliveryDate}
\item{\_lastDeliveryDate}
\item{\_contractSize}
\item{\_coupon}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
coupon): 

\begin{lstlisting}
    def __init__(self,
                 tickerName,
                 firstDeliveryDate,
                 lastDeliveryDate,
                 contractSize,
                 coupon):
\end{lstlisting}

\subsubsection*{{\bf conversionFactor}}
Determine the conversion factor for a specific bond using CME convention. To do this we need to know the contract standard coupon and must round the bond maturity (starting its life on the first delivery date) to the nearest 3 month multiple and then calculate the bond clean price.  

\begin{lstlisting}
    def conversionFactor(self, bond):
\end{lstlisting}

\subsubsection*{{\bf principalInvoicePrice}}


\begin{lstlisting}
    def principalInvoicePrice(self,
                              bond,
                              futuresPrice):
\end{lstlisting}

\subsubsection*{{\bf totalInvoiceAmount}}
futuresPrice): 

\begin{lstlisting}
    def totalInvoiceAmount(self,
                           settlementDate,
                           bond,
                           futuresPrice):
\end{lstlisting}

\subsubsection*{{\bf cheapestToDeliver}}
Determination of CTD as deliverable bond with lowest cost to buy versus what is received when the bond is delivered.  

\begin{lstlisting}
    def cheapestToDeliver(self,
                          bonds,
                          bondCleanPrices,
                          futuresPrice):
\end{lstlisting}

\subsubsection*{{\bf deliveryGainLoss}}
Determination of what is received when the bond is delivered.  

\begin{lstlisting}
    def deliveryGainLoss(self,
                         bond,
                         bondCleanPrice,
                         futuresPrice):
\end{lstlisting}

\newpage
\section{FinBondMarket}

\subsubsection{Enumerated Type: FinBondMarkets}
\begin{itemize}
\item{AUSTRIA}
\item{BELGIUM}
\item{CYPRUS}
\item{ESTONIA}
\item{FINLAND}
\item{FRANCE}
\item{GERMANY}
\item{GREECE}
\item{IRELAND}
\item{ITALY}
\item{LATVIA}
\item{LITHUANIA}
\item{LUXEMBOURG}
\item{MALTA}
\item{NETHERLANDS}
\item{PORTUGAL}
\item{SLOVAKIA}
\item{SLOVENIA}
\item{SPAIN}
\item{ESM}
\item{EFSF}
\item{BULGARIA}
\item{CROATIA}
\item{CZECH\_REPUBLIC}
\item{DENMARK}
\item{HUNGARY}
\item{POLAND}
\item{ROMANIA}
\item{SWEDEN}
\item{JAPAN}
\item{SWITZERLAND}
\item{UNITED\_KINGDOM}
\item{UNITED\_STATES}
\end{itemize}

\subsubsection*{{\bf getTreasuryBondMarketConventions}}
Returns the day count convention for accrued interest, the frequency and the number of days from trade date to settlement date.  This is for Treasury markets. And for secondary bond markets.  

\begin{lstlisting}
def getTreasuryBondMarketConventions(country):
\end{lstlisting}

\newpage
\section{FinBondOption}

\subsubsection{Enumerated Type: FinBondModelTypes}
\begin{itemize}
\item{BLACK}
\item{HO\_LEE}
\item{HULL\_WHITE}
\item{BLACK\_KARASINSKI}
\end{itemize}

\subsubsection{Enumerated Type: FinBondOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\item{AMERICAN\_CALL}
\item{AMERICAN\_PUT}
\end{itemize}

\subsection*{Class: FinBondOption()}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_expiryDate}
\item{\_strikePrice}
\item{\_bond}
\item{\_optionType}
\item{\_face}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
optionType): 

\begin{lstlisting}
    def __init__(self,
                 bond,
                 expiryDate,
                 strikePrice,
                 face,
                 optionType):
\end{lstlisting}

\subsubsection*{{\bf value}}
Value the bond option using the specified model.  

\begin{lstlisting}
    def value(self,
              valueDate,
              discountCurve,
              model):
\end{lstlisting}

\newpage
\section{FinConvertibleBond}

\subsection*{Class: FinConvertibleBond(object)}
Class for convertible bonds. These bonds embed rights to call and put the bond in return for equity. Until then they are bullet bonds which means they have regular coupon payments of a known size that are paid on known dates plus a payment of par at maturity. As the options are price based, the decision to convert to equity depends on the stock price, the credit quality of the issuer and the level of interest rates. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_maturityDate}
\item{\_coupon}
\item{\_accrualType}
\item{\_frequency}
\item{\_frequencyType}
\item{\_callDates}
\item{\_callPrices}
\item{\_putDates}
\item{\_putPrices}
\item{\_startConvertDate}
\item{\_conversionRatio}
\item{\_face}
\item{\_settlementDate}
\item{\_flowDates}
\item{\_accrued}
\item{\_alpha}
\item{\_accruedDays}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinBond object by providing Maturity Date, Frequency, coupon and the accrual convention type.  

\begin{lstlisting}
    def __init__(self,
                 maturityDate,  # bond maturity date
                 coupon,  # annual coupon
                 frequencyType,  # coupon frequency type
                 startConvertDate,  # date after which conversion is possible
                 conversionRatio,  # number of shares per face of notional
                 callDates,  # list of call dates
                 callPrices,  # list of call prices
                 putDates,  # list of put dates
                 putPrices,  # list of put prices
                 accrualType,  # day count type for accrued interest
                 face=100.0  # face amount
                 ):
\end{lstlisting}

\subsubsection*{{\bf calculateFlowDates}}
Determine the bond cashflow payment dates.  

\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf value}}
 A binomial tree valuation model for a convertible bond that captures the embedded equity option due to the existence of a conversion option which can be invoked after a specific date.  The model allows the user to enter a schedule of dividend payment dates but the size of the payments must be in yield terms i.e. a known percentage of currently unknown future stock price is paid. Not a fixed amount. A fixed yield. Following this payment the stock is assumed to drop by the size of the dividend payment.  The model also captures the stock dependent credit risk of the cash flows in which the bond price can default at any time with a hazard rate implied by the credit spread and an associated recovery rate. This is the model proposed by Hull (OFODS 6th edition,.page 522).  The model captures both the issuers call schedule which is assumed to apply on a list of dates provided by the user, along with a call price. It also captures the embedded owners put schedule of prices.  

\begin{lstlisting}
    def value(self,
              settlementDate,
              stockPrice,
              stockVolatility,
              dividendDates,
              dividendYields,
              discountCurve,
              creditSpread,
              recoveryRate = 0.40,
              numStepsPerYear = 100):
\end{lstlisting}

\subsubsection*{{\bf accruedDays}}
Calculate number days from previous coupon date to settlement. 

\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf \_accruedInterest}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date.  

\begin{lstlisting}
    def _accruedInterest(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf currentYield}}
Calculate the current yield of the bond which is the coupon divided by the clean price (not the full price) 

\begin{lstlisting}
    def currentYield(self, cleanPrice):
\end{lstlisting}

\subsubsection*{{\bf print}}
Print a list of the unadjusted coupon payment dates used in analytic calculations for the bond.  

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf valueConvertible}}
numStepsPerYear): 

\begin{lstlisting}
def valueConvertible(tmat,
                     face,
                     couponTimes,
                     couponFlows,
                     callTimes,
                     callPrices,
                     putTimes,
                     putPrices,
                     convRatio,
                     startConvertTime,
                     # Market inputs
                     stockPrice,
                     dfTimes,
                     dfValues,
                     dividendTimes,
                     dividendYields,
                     stockVolatility,
                     creditSpread,
                     recRate,
                     # Tree details
                     numStepsPerYear):
\end{lstlisting}

\subsubsection*{{\bf printTree}}
def printTree(array): 

\begin{lstlisting}
def printTree(array):
\end{lstlisting}

\newpage
\section{FinFloatingRateNote}

\subsection*{Class: FinFloatingRateNote(object)}
Class for managing floating rate notes that pay a floating index plus a quoted margin. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_maturityDate}
\item{\_quotedMargin}
\item{\_frequencyType}
\item{\_accrualType}
\item{\_frequency}
\item{\_face}
\item{\_redemption}
\item{\_settlementDate}
\item{\_flowDates}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinFloatingRateNote object.  

\begin{lstlisting}
    def __init__(self,
                 maturityDate,
                 quotedMargin,
                 frequencyType,
                 accrualType,
                 face=100.0,
                 redemption=1.0):
\end{lstlisting}

\subsubsection*{{\bf calculateFlowDates}}
Determine the bond cashflow payment dates.  

\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf fullPriceFromDiscountMargin}}
Calculate the full price of the bond from its discount margin and \# making assumptions about the future Libor rates.  

\begin{lstlisting}
    def fullPriceFromDiscountMargin(self,
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm):
\end{lstlisting}

\subsubsection*{{\bf dollarDuration}}
Calculate the risk or dP/dy of the bond by bumping.  

\begin{lstlisting}
    def dollarDuration(self,
                       settlementDate,
                       nextCoupon,
                       futureLibor,
                       dm):
\end{lstlisting}

\subsubsection*{{\bf macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement date given its yield to maturity.  

\begin{lstlisting}
    def macauleyDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm):
\end{lstlisting}

\subsubsection*{{\bf modifiedDuration}}
Calculate the modified duration of the bondon a settlement date given its yield to maturity.  

\begin{lstlisting}
    def modifiedDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm):
\end{lstlisting}

\subsubsection*{{\bf convexityFromDiscountMargin}}
Calculate the bond convexity from the yield to maturity.  

\begin{lstlisting}
    def convexityFromDiscountMargin(self,
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm):
\end{lstlisting}

\subsubsection*{{\bf cleanPriceFromDiscountMargin}}
Calculate the bond clean price from the yield.  

\begin{lstlisting}
    def cleanPriceFromDiscountMargin(self,
                                     settlementDate,
                                     nextCoupon,
                                     futureLibor,
                                     dm):
\end{lstlisting}

\subsubsection*{{\bf fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-value the bonds cashflows. THIS IS NOT COMPLETE.  

\begin{lstlisting}
    def fullPriceFromDiscountCurve(self,
                                   settlementDate,
                                   indexCurve,
                                   discountCurve):
\end{lstlisting}

\subsubsection*{{\bf discountMargin}}
Calculate the bonds yield to maturity by solving the price yield relationship using a one-dimensional root solver.  

\begin{lstlisting}
    def discountMargin(self,
                       settlementDate,
                       nextCoupon,
                       futureLibor,
                       cleanPrice):
\end{lstlisting}

\subsubsection*{{\bf accruedDays}}
Calculate number of days from previous coupon date to settlement. 

\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf pcd}}
Determine the previous coupon date before the settlement date.  

\begin{lstlisting}
    def pcd(self, settlementDate):
\end{lstlisting}

\subsubsection*{{\bf accruedInterest}}
Calculate the amount of coupon that has accrued between the previous coupon date and the settlement date.  

\begin{lstlisting}
    def accruedInterest(self,
                        settlementDate,
                        nextCoupon):
\end{lstlisting}

\subsubsection*{{\bf f}}
Function used to do solve root search in discount margin calculation.  

\begin{lstlisting}
def f(dm, *args):
\end{lstlisting}

\newpage
\section{FinMortgage}

\subsubsection{Enumerated Type: FinMortgageType}
\begin{itemize}
\item{REPAYMENT}
\item{INTEREST\_ONLY}
\end{itemize}

\subsection*{Class: FinMortgage(object)}
A mortgage is a vector of dates and flows generated in order to repay a fixed amount given a known interest rate. Payments are all the same amount but with a varying mixture of interest and repayment of principal.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_endDate}
\item{\_principal}
\item{\_frequencyType}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_dayCountConventionType}
\item{\_schedule}
\item{\_mortgageType}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dayCountConventionType=FinDayCountTypes.ACT\_360): 

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 principal,
                 frequencyType=FinFrequencyTypes.MONTHLY,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD,
                 dayCountConventionType=FinDayCountTypes.ACT_360):
\end{lstlisting}

\subsubsection*{{\bf repaymentAmount}}
def repaymentAmount(self, zeroRate): 

\begin{lstlisting}
    def repaymentAmount(self, zeroRate):
\end{lstlisting}

\subsubsection*{{\bf generateFlows}}
def generateFlows(self, zeroRate, mortgageType): 

\begin{lstlisting}
    def generateFlows(self, zeroRate, mortgageType):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}


\chapter{financepy.products.libor}
\section{Introduction}

This folder contains a set of Libor-related products. More recently with the demise of Libor these are known as Ibor products. It includes:

\begin{itemize}
\item{ FinInterestRateFuture is a class to handle interest rate futures contracts. This is an exchange-traded contract to receive or pay Libor on a specified future date. It can be used to build the Liboir term structure. 
}
\item{ FinLiborCapFloor is a contract to buy a sequence of calls or puts on Libor over a period at a strike agreed today.
}
\item{ FinLiborDeposit is the basic Libor instrument in which a party borrows an amount for a specified term and rate unsecured.
}
\item{ FinLiborFRA is a class to manage Forward Rate Agreements (FRAs) in which one party agrees to lock in a forward Libor rate.
}
\item{ FinLiborSwap is a contract to exchange fixed rate coupons for floating Libor rates. This class has functionality to value the swap contract and to calculate its risk.
}
\item{ FinLiborSwaption is a contract to buy or sell an option on a swap. The model includes code that prices a payer or receiver swaption.
}
\item{ FinOIS is a contract to exchange the daily compounded Overnight index swap rate for a fixed rate agreed at contract initiation.
}
\end{itemize}
\newpage
\section{FinInterestRateFuture}

\subsection*{Class: FinInterestRateFuture(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_lastTradingDate}
\item{\_dayCountType}
\item{\_contractSize}
\item{\_lastSettlementDate}
\item{\_endOfInterestRatePeriod}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create an interest rate futures contract. 

\begin{lstlisting}
    def __init__(self,
                 lastTradingDate,
                 dayCountType,
                 contractSize):
\end{lstlisting}

\subsubsection*{{\bf futuresRate}}
Calculate implied futures rate from the futures price. 

\begin{lstlisting}
    def futuresRate(self,
                    settlementDate,
                    futuresPrice):
\end{lstlisting}

\subsubsection*{{\bf convexity}}
Calculation of the convexity adjustment between FRAs and interest rate futures using the Hull-White model as described in technical note.  

\begin{lstlisting}
    def convexity(self,
                  settlementDate,
                  volatility,
                  a):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborCapFloor}

\subsubsection{Enumerated Type: FinLiborCapFloorType}
\begin{itemize}
\item{CAP}
\item{FLOOR}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborCapFloorModelTypes}
\begin{itemize}
\item{BLACK}
\item{SHIFTED\_BLACK}
\item{SABR}
\end{itemize}

\subsection*{Class: FinLiborCapFloor()}
class FinLiborCapFloor(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_maturityDate}
\item{\_optionType}
\item{\_strikeRate}
\item{\_lastFixing}
\item{\_frequencyType}
\item{\_dayCountType}
\item{\_notional}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_capFloorDates}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 optionType,
                 strikeRate,
                 lastFixing=None,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.THIRTY_E_360_ISDA,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(self,
              valuationDate,
              liborCurve,
              model):
\end{lstlisting}

\subsubsection*{{\bf valueCapletFloorlet}}
model): 

\begin{lstlisting}
    def valueCapletFloorlet(self,
                            valuationDate,
                            startDate,
                            endDate,
                            liborCurve,
                            model):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborDeposit}

\subsection*{Class: FinLiborDeposit(object)}
class FinLiborDeposit(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_calendarType}
\item{\_settlementDate}
\item{\_dayCountType}
\item{\_depositRate}
\item{\_notional}
\item{\_maturityDate}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create a Libor deposit object.  

\begin{lstlisting}
    def __init__(self,
                 settlementDate,
                 maturityDateOrTenor,
                 depositRate,
                 dayCountType,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsubsection*{{\bf maturityDf}}
Returns the maturity date discount factor that would allow the Libor curve to reprice the contractual market deposit rate. Note that this is a forward discount factor that starts on settlement date. 

\begin{lstlisting}
    def maturityDf(self):
\end{lstlisting}

\subsubsection*{{\bf value}}
Determine the value of the Deposit given a Libor curve.  

\begin{lstlisting}
    def value(self, valueDate, liborCurve):
\end{lstlisting}

\subsubsection*{{\bf print}}
Print the contractual details of the Libor deposit.  

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborFRA}

\subsection*{Class: FinLiborFRA(object)}
Class for managing LIBOR forward rate agreements. A forward rate agreement is an agreement to exchange a fixed pre-agreed rate for a floating rate linked to LIBOR that is not known until some specified future fixing date. The FRA payment occurs on or soon after this date on the FRA settlement date. Typically the timing gap is two days.  A FRA is used to hedge a Libor quality loan or lend of some agreed notional amount. This period starts on the settlement date of the FRA and ends on the maturity date of the FRA. For example a 1x4 FRA relates to a Libor starting in 1 month for a loan period ending in 4 months. Hence it linkes to 3-month Libor rate.  The amount received by a payer of fixed rate at settlement is  acc(1,2) * (Libor(1,2) - FRA RATE) / (1 + acc(0,1) x Libor(0,1))  So the value at time 0 is  acc(1,2) * (FWD Libor(1,2) - FRA RATE) x df(0,2)  If the base date of the curve is before the value date then we forward adjust this amount to that value date.  For simplicity I have assumed that the fixing date and the settlement date are the same date. This should be amended later.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_calendarType}
\item{\_settlementDate}
\item{\_maturityDate}
\item{\_fraRate}
\item{\_payFixedRate}
\item{\_dayCountType}
\item{\_notional}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FRA object.  

\begin{lstlisting}
    def __init__(self,
                 settlementDate,  # The date on which the floating rate fixes
                 maturityDateOrTenor,  # The end of the Libor rate period
                 fraRate,  # The fixed contractual FRA rate
                 payFixedRate,  # True if the FRA rate is being paid
                 dayCountType,  # For interest period
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsubsection*{{\bf value}}
Determine mark to market value of a FRA contract based on the market FRA rate. The same curve is used for calculating the forward Libor and for doing discounting on the expected forward payment.  

\begin{lstlisting}
    def value(self, valueDate, liborCurve):
\end{lstlisting}

\subsubsection*{{\bf maturityDf}}
Determine the maturity date discount factor needed to refit the FRA given the libor curve anbd the contract FRA rate.  

\begin{lstlisting}
    def maturityDf(self, liborCurve):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborModelTypes}

\subsection*{Class: FinLiborModel(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self): 

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection*{Class: FinLiborModelBlack(FinLiborModel)}
class FinLiborModelBlack(FinLiborModel): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, volatility): 

\begin{lstlisting}
    def __init__(self, volatility):
\end{lstlisting}

\subsection*{Class: FinLiborModelShiftedBlack(FinLiborModel)}
class FinLiborModelShiftedBlack(FinLiborModel): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_volatility}
\item{\_shift}
\item{\_implementation}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, volatility, shift): 

\begin{lstlisting}
    def __init__(self, volatility, shift):
\end{lstlisting}

\subsection*{Class: FinLiborModelSABR(FinLiborModel)}
class FinLiborModelSABR(FinLiborModel): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_alpha}
\item{\_beta}
\item{\_rho}
\item{\_nu}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, alpha, beta, rho, nu): 

\begin{lstlisting}
    def __init__(self, alpha, beta, rho, nu):
\end{lstlisting}

\newpage
\section{FinLiborProducts}

\subsection*{Class: FinLiborSwap(object)}
class FinLiborSwap(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{payFixedLeg}
\item{fixedLeg}
\item{floatLeg}
\item{payFixedFlag}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRule="BACKWARD"): 

\begin{lstlisting}
    def __init__(self, startDate, endDate,
                 fixedCoupon, fixedFreq, fixedBasis,
                 floatSpread, floatFreq, floatBasis,
                 firstFixing=None,
                 payFixedFlag=True,
                 calendarName="WEEKEND",
                 businessDateAdjust="FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsubsection*{{\bf value}}
def value(self, valueDate, discountCurve, indexCurve): 

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsubsection*{{\bf dump}}
def dump(self): 

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection*{Class: FinLiborSwapFixedLeg(object)}
class FinLiborSwapFixedLeg(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{startDate}
\item{maturityDate}
\item{coupon}
\item{freq}
\item{basis}
\item{schedule}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRule="BACKWARD"): 

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 coupon,
                 freq,
                 basis,
                 calendarName="WEEKEND",
                 businessDateAdjust="MODIFIED_FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsubsection*{{\bf value}}
def value(self, valueDate, discountCurve): 

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf generateFlows}}
def generateFlows(self, fixedBasis): 

\begin{lstlisting}
    def generateFlows(self, fixedBasis):
\end{lstlisting}

\subsubsection*{{\bf dump}}
def dump(self): 

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection*{Class: FinLiborSwapFloatLeg(object)}
class FinLiborSwapFloatLeg(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{startDate}
\item{endDate}
\item{floatSpread}
\item{freq}
\item{basis}
\item{firstFixing}
\item{schedule}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRule): 

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 floatSpread,
                 floatFreq,
                 floatBasis,
                 firstFixing,
                 calendarName,
                 businessDateAdjust,
                 dateGenRule):
\end{lstlisting}

\subsubsection*{{\bf value}}
def value(self, valueDate, discountCurve, indexCurve): 

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsubsection*{{\bf generateFlows}}
def generateFlows(self, indexCurve): 

\begin{lstlisting}
    def generateFlows(self, indexCurve):
\end{lstlisting}

\subsubsection*{{\bf dump}}
def dump(self): 

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinLiborSwap}

\subsection*{Class: FinLiborSwap(object)}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_maturityDate}
\item{\_payFixedLeg}
\item{\_notional}
\item{\_startDate}
\item{\_fixedCoupon}
\item{\_floatSpread}
\item{\_fixedFrequencyType}
\item{\_floatFrequencyType}
\item{\_fixedDayCountType}
\item{\_floatDayCountType}
\item{\_payFixedFlag}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_adjustedFixedDates}
\item{\_adjustedFloatDates}
\item{\_fixedStartIndex}
\item{\_floatStartIndex}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create an interest rate swap contract.  

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDateOrTenor,
                 fixedCoupon,
                 fixedFreqType,
                 fixedDayCountType,
                 notional=ONE_MILLION,
                 floatSpread=0.0,
                 floatFreqType=FinFrequencyTypes.QUARTERLY,
                 floatDayCountType=FinDayCountTypes.THIRTY_360,
                 payFixedFlag=True,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf value}}
Value the interest rate swap on a value date given a single Libor discount curve.  

\begin{lstlisting}
    def value(self,
              valuationDate,
              discountCurve,
              indexCurve,
              firstFixingRate,
              principal=0.0):
\end{lstlisting}

\subsubsection*{{\bf generateFixedLegPaymentDates}}
Generate the fixed leg payment dates all the way back to the start date of the swap which may precede the valuation date 

\begin{lstlisting}
    def generateFixedLegPaymentDates(self):
\end{lstlisting}

\subsubsection*{{\bf generateFloatLegPaymentDates}}
Generate the floating leg payment dates all the way back to the start date of the swap which may precede the valuation date 

\begin{lstlisting}
    def generateFloatLegPaymentDates(self):
\end{lstlisting}

\subsubsection*{{\bf pv01}}
Calculate the value of 1 basis point coupon on the fixed leg.  

\begin{lstlisting}
    def pv01(self, valuationDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf parCoupon}}
Calculate the fixed leg coupon that makes the swap worth zero.  If the valuation date is before the swap payments start then this  is the forward swap rate as it starts in the future. The swap rate  is then a forward swap rate and so we use a forward discount  factor. If the swap fixed leg has begun then we have a spot  starting swap.  

\begin{lstlisting}
    def parCoupon(self, valuationDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf fixedLegValue}}
The swap may have started in the past but we can only value payments that have occurred after the valuation date.  

\begin{lstlisting}
    def fixedLegValue(self, valuationDate, discountCurve, principal=0.0):
\end{lstlisting}

\subsubsection*{{\bf floatLegValue}}
Value the floating leg with payments from an index curve and discounting based on a supplied discount curve.  

\begin{lstlisting}
    def floatLegValue(self,
                      valuationDate,
                      discountCurve,
                      indexCurve,
                      firstFixingRate=None,
                      principal=0.0):
\end{lstlisting}

\subsubsection*{{\bf printFixedLeg}}
Prints the fixed leg amounts.  

\begin{lstlisting}
    def printFixedLeg(self, valuationDate):
\end{lstlisting}

\subsubsection*{{\bf printFloatLeg}}
Prints the floating leg amounts.  

\begin{lstlisting}
    def printFloatLeg(self, valuationDate):
\end{lstlisting}

\newpage
\section{FinLiborSwaption}

\subsubsection{Enumerated Type: FinLiborSwaptionType}
\begin{itemize}
\item{PAYER}
\item{RECEIVER}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborSwaptionModelTypes}
\begin{itemize}
\item{BLACK}
\item{SABR}
\end{itemize}

\subsection*{Class: FinLiborSwaption()}
class FinLiborSwaption(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_exerciseDate}
\item{\_maturityDate}
\item{\_swaptionType}
\item{\_swapFixedCoupon}
\item{\_swapFixedFrequencyType}
\item{\_swapFixedDayCountType}
\item{\_swapNotional}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_pv01}
\item{\_fwdSwapRate}
\item{\_forwardDf}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD): 

\begin{lstlisting}
    def __init__(self,
                 exerciseDate,
                 swapMaturityDate,
                 swaptionType,
                 swapFixedCoupon,
                 swapFixedFrequencyType,
                 swapFixedDayCountType,
                 swapNotional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf value}}
model): 

\begin{lstlisting}
    def value(self,
              valuationDate,
              liborCurve,
              model):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinOIS}

\subsection*{Class: FinOIS(object)}
Class for managing overnight index swaps. This is a swap contract in which a fixed payment leg is exchanged for a floating coupon leg. There is no exchange of par.  The contract lasts from a start date to a specified maturity date. The fixed coupon is the OIS fixed rate which is set at contract initiation.  The floating rate is not known until the end of each payment period. It is calculated at the end of the period as it is based on daily observations of the overnight index rate which are compounded according to a specific convention. Hence the OIS floating rate is determined by the history of the OIS rates.  In its simplest form, there is just one fixed rate payment and one floating rate payment at contract maturity. However when the contract becomes longer than one year the floating and fixed payments become periodic.  The value of the contract is the NPV of the two coupon streams. Discounting is done on a supplied OIS curve which is itself implied by the term structure of market OIS rates.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_startDate}
\item{\_maturityDate}
\item{\_payFixedLeg}
\item{\_notional}
\item{\_fixedRate}
\item{\_fixedFrequencyType}
\item{\_floatFrequencyType}
\item{\_fixedDayCountType}
\item{\_floatDayCountType}
\item{\_calendarType}
\item{\_busDayAdjustType}
\item{\_dateGenRuleType}
\item{\_adjustedFixedDates}
\item{\_adjustedFloatDates}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create OIS object.  

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 fixedRate,
                 fixedFrequencyType,
                 fixedDayCountType,
                 floatFrequencyType=FinFrequencyTypes.ANNUAL,
                 floatDayCountType=FinDayCountTypes.ACT_360,
                 payFixedLeg=True,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsubsection*{{\bf generatePaymentDates}}
def generatePaymentDates(self, valueDate): 

\begin{lstlisting}
    def generatePaymentDates(self, valueDate):
\end{lstlisting}

\subsubsection*{{\bf generateFixedLegFlows}}
def generateFixedLegFlows(self, valueDate): 

\begin{lstlisting}
    def generateFixedLegFlows(self, valueDate):
\end{lstlisting}

\subsubsection*{{\bf generateFloatLegFlows}}
Generate the payment amounts on floating leg implied by index curve  

\begin{lstlisting}
    def generateFloatLegFlows(self, valueDate, indexCurve):
\end{lstlisting}

\subsubsection*{{\bf rate}}
Calculate the OIS rate implied rate from the history of fixings.  

\begin{lstlisting}
    def rate(self, oisDates, oisFixings):
\end{lstlisting}

\subsubsection*{{\bf value}}
Value the interest rate swap on a value date given a single Libor discount curve.  

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsubsection*{{\bf fixedLegValue}}
def fixedLegValue(self, valueDate, discountCurve, principal=0.0): 

\begin{lstlisting}
    def fixedLegValue(self, valueDate, discountCurve, principal=0.0):
\end{lstlisting}

\subsubsection*{{\bf floatLegValue}}
Value the floating leg with payments from an index curve and discounting based on a supplied discount curve.  

\begin{lstlisting}
    def floatLegValue(self,
                      valueDate,
                      discountCurve,
                      indexCurve,
                      principal=0.0):
\end{lstlisting}

\subsubsection*{{\bf df}}
Calculate the OIS rate implied discount factor.  

\begin{lstlisting}
    def df(self,
           oisRate,
           startDate,
           endDate):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self, valueDate, indexCurve): 

\begin{lstlisting}
    def print(self, valueDate, indexCurve):
\end{lstlisting}


\chapter{financepy.products.fx}
\section{Introduction}

This is where FX derivatives will be found.
\chapter{financepy.models}
\section{Introduction}

This folder contains a range of models used in the various derivative pricing models implemented in the product folder. These include credit models for valuing portfolio credit products such as CDS Tranches, Monte-Carlo based models of stochastics processes used to value equity, FX and interest rate derivatives, and some generic implementations of models such as a tree-based Hull White model. Because the models are useful across a range of products, it is better to factor them out of the product/asset class categorisation as it avoids any unnecessary duplication. In addition we seek to make the interface to these models rely only on fast types such as floats and integers and Numpy arrays.


\section*{Equity Models}
\begin{itemize}
\item{ FinHestonModel 
}
\item{ FinHestonModelProcess
}
\item{ FinProcessSimulator
}
\end{itemize}


\section*{Interest Rate Models}

\subsubsection*{Equilibrium Rate Models}
There are two main short rate models.
\begin{itemize}
\item{ FinCIRRateModel is a short rate model where the randomness component is proportional to the square root of the short rate. This model implementation is not arbitrage-free across the term structure.
}
\item{ FinVasicekRateModel is a short rate model that assumes mean-reversion and normal volatility. It has a closed form solution for bond prices. It does not have the flexibility to fit a term structure of interest rates. For that you need to use the more flexible Hull-White model.
}
\end{itemize}

\subsubsection*{Arbitrage Free Rate Models}
There are three arbitrage-free rate models:
\begin{itemize}
\item{ FinBlackKaraskinskiRateModel is a short rate model in which the log of the short rate follows a mean-reverting normal process. It refits the interest rate term structure. It is implemented as a trinomial tree and allows valuation of European and American-style rate-based options.
}
\item{ FinHullWhiteRateModel is a short rate model in which the short rate follows a mean-reverting normal process. It fits the interest rate term structure. It is implemented as a trinomial tree and allows valuation of European and American-style rate-based options. It also implements Jamshidian's decomposition of the bond option for European options.
}
\item{ FinSABR Model is a stochastic volatility model for forward interest rates that has a closed form approximate solution for the implied volatility. It is widely used for pricing European style interest rate options, specifically caps and floors and also swaptions.
}
\end{itemize}


\section*{Credit Models}
\begin{itemize}
\item{ FinGaussianCopula1FModel is a Gaussian copula one-factor model. This class includes functions that calculate the portfolio loss distribution. This is numerical but deterministic.
}
\item{ FinGaussianCopulaLHPModel is a Gaussian copula one-factor model in the limit that the number of credits tends to infinity. This is an asymptotic analytical solution.
}
\item{ FinGaussianCopulaModel is a Gaussian copula model which is multifactor model. It has a Monte-Carlo implementation.
}
\item{ FinLossDbnBuilder calculates the loss distribution.
}
\item{ FinMertonCreditModel is a model of the firm as proposed by Merton (1974).
}
\end{itemize}


\section*{FX Models}
\newpage
\section{FinBlackKarasinskiRateModel}

\subsection*{Class: FinBlackKarasinskiRateModel()}
class FinBlackKarasinskiRateModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_a}
\item{\_sigma}
\item{\_Q}
\item{\_rt}
\item{\_treeTimes}
\item{\_pu}
\item{\_pm}
\item{\_pd}
\item{\_discountCurve}
\item{\_dfTimes}
\item{\_dfValues}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Constructs the Black Karasinski rate model. The speed of mean reversion a and volatility are passed in. The short rate process is given by d(log(r)) = (theta(t) - a*log(r)) * dt  + sigma * dW  

\begin{lstlisting}
    def __init__(self, a, sigma):
\end{lstlisting}

\subsubsection*{{\bf bondOption}}
Option that can be exercised at any time over the exercise period. Due to non-analytical bond price we need to extend tree out to bond maturity and take into account cash flows through time.  

\begin{lstlisting}
    def bondOption(self, texp, strikePrice,
                   face, couponTimes, couponFlows, americanExercise):
\end{lstlisting}

\subsubsection*{{\bf buildTree}}
def buildTree(self, tmat, numTimeSteps, dfTimes, dfValues): 

\begin{lstlisting}
    def buildTree(self, tmat, numTimeSteps, dfTimes, dfValues):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(alpha, nm, Q, P, dX, dt, N): 

\begin{lstlisting}
def f(alpha, nm, Q, P, dX, dt, N):
\end{lstlisting}

\subsubsection*{{\bf fprime}}
def fprime(alpha, nm, Q, P, dX, dt, N): 

\begin{lstlisting}
def fprime(alpha, nm, Q, P, dX, dt, N):
\end{lstlisting}

\subsubsection*{{\bf searchRoot}}
def searchRoot(x0, nm, Q, P, dX, dt, N): 

\begin{lstlisting}
def searchRoot(x0, nm, Q, P, dX, dt, N):
\end{lstlisting}

\subsubsection*{{\bf searchRootDeriv}}
def searchRootDeriv(x0, nm, Q, P, dX, dt, N): 

\begin{lstlisting}
def searchRootDeriv(x0, nm, Q, P, dX, dt, N):
\end{lstlisting}

\subsubsection*{{\bf bondOptionFast}}
Option that can be exercised at any time over the exercise period. Due to non-analytical bond price we need to extend tree out to bond maturity and take into account cash flows through time.  

\begin{lstlisting}
def bondOptionFast(texp, tmat, strikePrice,  face, couponTimes, couponFlows,
                   americanExercise, _dfTimes, _dfValues,
                   _treeTimes, _Q, _pu, _pm, _pd, _rt, _dt, _a):
\end{lstlisting}

\subsubsection*{{\bf buildTreeFast}}
def buildTreeFast(a, sigma, treeTimes, numTimeSteps, discountFactors): 

\begin{lstlisting}
def buildTreeFast(a, sigma, treeTimes, numTimeSteps, discountFactors):
\end{lstlisting}

\newpage
\section{FinCIRRateModel}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection*{Class: FinCIRRateModel()}
class FinCIRRateModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_a}
\item{\_b}
\item{\_sigma}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, a, b, sigma): 

\begin{lstlisting}
    def __init__(self, a, b, sigma):
\end{lstlisting}

\subsubsection*{{\bf meanr}}
Mean value of a CIR process after time t  

\begin{lstlisting}
def meanr(r0, a, b, t):
\end{lstlisting}

\subsubsection*{{\bf variancer}}
Variance of a CIR process after time t  

\begin{lstlisting}
def variancer(r0, a, b, sigma, t):
\end{lstlisting}

\subsubsection*{{\bf zeroPrice}}
Price of a zero coupon bond in CIR model.  

\begin{lstlisting}
def zeroPrice(r0, a, b, sigma, t):
\end{lstlisting}

\subsubsection*{{\bf draw}}
Draw a next rate from the CIR model in Monte Carlo.  

\begin{lstlisting}
def draw(rt, a, b, sigma, dt):
\end{lstlisting}

\subsubsection*{{\bf ratePath\_MC}}
Generate a path of CIR rates using a number of numerical schemes.  

\begin{lstlisting}
def ratePath_MC(r0, a, b, sigma, t, dt, seed, scheme):
\end{lstlisting}

\subsubsection*{{\bf zeroPrice\_MC}}


\begin{lstlisting}
def zeroPrice_MC(r0, a, b, sigma, t, dt, numPaths, seed, scheme):
\end{lstlisting}

\newpage
\section{FinGaussianCopula1FModel}

\subsubsection*{{\bf lossDbnRecursionGCD}}
Full construction of the loss distribution of a portfolio of credits where losses have been calculate as number of units based on the GCD.  

\begin{lstlisting}
def lossDbnRecursionGCD(numCredits,
                        defaultProbs,
                        lossUnits,
                        betaVector,
                        numIntegrationSteps):
\end{lstlisting}

\subsubsection*{{\bf homogeneousBasketLossDbn}}
Calculate the loss distribution of a CDS default basket where the portfolio is equally weighted and the losses in the portfolio are homo- geneous i.e. the credits have the same recovery rates.  

\begin{lstlisting}
def homogeneousBasketLossDbn(survivalProbabilities,
                             recoveryRates,
                             betaVector,
                             numIntegrationSteps):
\end{lstlisting}

\subsubsection*{{\bf trSurvProbRecursion}}
Get the tranche survival probability of a portfolio of credits in the one-factor GC model using a full recursion calculation of the loss distribution and survival probabilities to some time horizon.  

\begin{lstlisting}
def trSurvProbRecursion(k1,
                        k2,
                        numCredits,
                        survivalProbabilities,
                        recoveryRates,
                        betaVector,
                        numIntegrationSteps):
\end{lstlisting}

\subsubsection*{{\bf gaussApproxTrancheLoss}}
def gaussApproxTrancheLoss(k1, k2, mu, sigma): 

\begin{lstlisting}
def gaussApproxTrancheLoss(k1, k2, mu, sigma):
\end{lstlisting}

\subsubsection*{{\bf trSurvProbGaussian}}
Get the approximated tranche survival probability of a portfolio of credits in the one-factor GC model using a Gaussian fit of the conditional loss distribution and survival probabilities to some time horizon. Note that the losses in this fit are allowed to be negative.  

\begin{lstlisting}
def trSurvProbGaussian(k1,
                       k2,
                       numCredits,
                       survivalProbabilities,
                       recoveryRates,
                       betaVector,
                       numIntegrationSteps):
\end{lstlisting}

\subsubsection*{{\bf lossDbnHeterogeneousAdjBinomial}}
Get the portfolio loss distribution using the adjusted binomial approximation to the conditional loss distribution.  

\begin{lstlisting}
def lossDbnHeterogeneousAdjBinomial(numCredits,
                                    defaultProbs,
                                    lossRatio,
                                    betaVector,
                                    numIntegrationSteps):
\end{lstlisting}

\subsubsection*{{\bf trSurvProbAdjBinomial}}
Get the approximated tranche survival probability of a portfolio of credits in the one-factor GC model using the adjusted binomial fit of the conditional loss distribution and survival probabilities to some time horizon. This approach is both fast and highly accurate.  

\begin{lstlisting}
def trSurvProbAdjBinomial(k1,
                          k2,
                          numCredits,
                          survivalProbabilities,
                          recoveryRates,
                          betaVector,
                          numIntegrationSteps):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaLHPModel}

\subsubsection*{{\bf trSurvProbLHP}}
Get the approximated tranche survival probability of a portfolio of credits in the one-factor GC model using the large portfolio limit which assumes a homogenous portfolio with an infinite number of credits. This approach is very fast but not so as accurate as the adjusted binomial.  

\begin{lstlisting}
def trSurvProbLHP(k1,
                  k2,
                  numCredits,
                  survivalProbabilities,
                  recoveryRates,
                  beta):
\end{lstlisting}

\subsubsection*{{\bf portfolioCDF\_LHP}}
def portfolioCDF\_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints): 

\begin{lstlisting}
def portfolioCDF_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints):
\end{lstlisting}

\subsubsection*{{\bf expMinLK}}
def expMinLK(k, p, r, n, beta): 

\begin{lstlisting}
def expMinLK(k, p, r, n, beta):
\end{lstlisting}

\subsubsection*{{\bf LHPDensity}}
def LHPDensity(k, p, r, beta): 

\begin{lstlisting}
def LHPDensity(k, p, r, beta):
\end{lstlisting}

\subsubsection*{{\bf LHPAnalyticalDensityBaseCorr}}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta\_dk): 

\begin{lstlisting}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta_dk):
\end{lstlisting}

\subsubsection*{{\bf LHPAnalyticalDensity}}
def LHPAnalyticalDensity(k, p, r, beta): 

\begin{lstlisting}
def LHPAnalyticalDensity(k, p, r, beta):
\end{lstlisting}

\subsubsection*{{\bf ExpMinLK}}
def ExpMinLK(k, p, r, n, beta): 

\begin{lstlisting}
def ExpMinLK(k, p, r, n, beta):
\end{lstlisting}

\subsubsection*{{\bf probLGreaterThanK}}
def probLGreaterThanK(K, P, R, beta): 

\begin{lstlisting}
def probLGreaterThanK(K, P, R, beta):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaModel}

\subsubsection*{{\bf defaultTimesGC}}
seed): 

\begin{lstlisting}
def defaultTimesGC(issuerCurves,
                   correlationMatrix,
                   numTrials,
                   seed):
\end{lstlisting}

\newpage
\section{FinGBMProcess}

\subsection*{Class: FinGBMProcess()}
class FinGBMProcess(): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsubsection*{{\bf getPaths}}
seed): 

\begin{lstlisting}
    def getPaths(
            self,
            numPaths,
            numTimeSteps,
            t,
            mu,
            stockPrice,
            volatility,
            seed):
\end{lstlisting}

\subsubsection*{{\bf getPathsAssets}}
t, mus, stockPrices, volatilities, betas, seed): 

\begin{lstlisting}
    def getPathsAssets(self, numAssets, numPaths, numTimeSteps,
                       t, mus, stockPrices, volatilities, betas, seed):
\end{lstlisting}

\subsubsection*{{\bf getPaths}}
seed): 

\begin{lstlisting}
def getPaths(numPaths,
             numTimeSteps,
             t,
             mu,
             stockPrice,
             volatility,
             seed):
\end{lstlisting}

\subsubsection*{{\bf getPathsAssets}}
seed): 

\begin{lstlisting}
def getPathsAssets(numAssets,
                   numPaths,
                   numTimeSteps,
                   t,
                   mus,
                   stockPrices,
                   volatilities,
                   betas,
                   seed):
\end{lstlisting}

\subsubsection*{{\bf getAssets}}
seed): 

\begin{lstlisting}
def getAssets(numAssets,
              numPaths,
              t,
              mus,
              stockPrices,
              volatilities,
              betas,
              seed):
\end{lstlisting}

\newpage
\section{FinHestonModel}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection*{Class: FinHestonModel()}
class FinHestonModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_v0}
\item{\_kappa}
\item{\_theta}
\item{\_sigma}
\item{\_rho}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, v0, kappa, theta, sigma, rho): 

\begin{lstlisting}
    def __init__(self, v0, kappa, theta, sigma, rho):
\end{lstlisting}

\subsubsection*{{\bf value\_MC}}
scheme=FinHestonNumericalScheme.EULERLOG): 

\begin{lstlisting}
    def value_MC(self,
                 valueDate,
                 option,
                 stockPrice,
                 interestRate,
                 dividendYield,
                 numPaths,
                 numStepsPerYear,
                 seed,
                 scheme=FinHestonNumericalScheme.EULERLOG):
\end{lstlisting}

\subsubsection*{{\bf value\_Lewis}}
dividendYield): 

\begin{lstlisting}
    def value_Lewis(self,
                    valueDate,
                    option,
                    stockPrice,
                    interestRate,
                    dividendYield):
\end{lstlisting}

\subsubsection*{{\bf phi}}
def phi(k\_in,): 

\begin{lstlisting}
        def phi(k_in,):
\end{lstlisting}

\subsubsection*{{\bf phi\_transform}}
def phi\_transform(x): 

\begin{lstlisting}
        def phi_transform(x):
\end{lstlisting}

\subsubsection*{{\bf integrand}}
def integrand(k): return 2.0 * np.real(np.exp(-1j * \ 

\begin{lstlisting}
            def integrand(k): return 2.0 * np.real(np.exp(-1j * \
\end{lstlisting}

\subsubsection*{{\bf value\_Lewis\_Rouah}}
dividendYield): 

\begin{lstlisting}
    def value_Lewis_Rouah(self,
                          valueDate,
                          option,
                          stockPrice,
                          interestRate,
                          dividendYield):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(k\_in): 

\begin{lstlisting}
        def f(k_in):
\end{lstlisting}

\subsubsection*{{\bf value\_Weber}}
dividendYield): 

\begin{lstlisting}
    def value_Weber(self,
                    valueDate,
                    option,
                    stockPrice,
                    interestRate,
                    dividendYield):
\end{lstlisting}

\subsubsection*{{\bf F}}
def F(s, b): 

\begin{lstlisting}
        def F(s, b):
\end{lstlisting}

\subsubsection*{{\bf integrand}}
def integrand(u): 

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsubsection*{{\bf value\_Gatheral}}
dividendYield): 

\begin{lstlisting}
    def value_Gatheral(self,
                       valueDate,
                       option,
                       stockPrice,
                       interestRate,
                       dividendYield):
\end{lstlisting}

\subsubsection*{{\bf F}}
def F(j): 

\begin{lstlisting}
        def F(j):
\end{lstlisting}

\subsubsection*{{\bf integrand}}
def integrand(u): 

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsubsection*{{\bf getPaths}}
scheme): 

\begin{lstlisting}
def getPaths(
        s0,
        r,
        q,
        v0,
        kappa,
        theta,
        sigma,
        rho,
        t,
        dt,
        numPaths,
        seed,
        scheme):
\end{lstlisting}

\newpage
\section{FinHestonProcess}

\subsubsection{Enumerated Type: FinHestonScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection*{Class: FinHestonProcess(FinProcess)}
class FinHestonProcess(FinProcess): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_numTimeSteps}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf getPathsAssets}}
fast = FinFastNumericalApproach.NUMBA): 

\begin{lstlisting}
    def getPathsAssets(self, 
                 t,
                 mus,
                 stockPrices,
                 volatilities,
                 betas,
                 seed, 
                 fast = FinFastNumericalApproach.NUMBA):
\end{lstlisting}

\subsubsection*{{\bf getPaths}}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme): 

\begin{lstlisting}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):
\end{lstlisting}

\newpage
\section{FinHoLeeRateModel}

\subsection*{Class: FinHoLeeModel()}
class FinHoLeeModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_discountCurve}
\item{\_sigma}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, discountCurve, sigma): 

\begin{lstlisting}
    def __init__(self, discountCurve, sigma):
\end{lstlisting}

\subsubsection*{{\bf P}}
t2):  \# forward maturity t2 

\begin{lstlisting}
    def P(self,
          r1,  # short rate at time t1
          t1,  # foward start time t1
          t2):  # forward maturity t2
\end{lstlisting}

\newpage
\section{FinHullWhiteRateModel}

\subsection*{Class: FinHullWhiteRateModel()}
class FinHullWhiteRateModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_a}
\item{\_sigma}
\item{\_Q}
\item{\_r}
\item{\_treeTimes}
\item{\_pu}
\item{\_pm}
\item{\_pd}
\item{\_discountCurve}
\item{\_treeBuilt}
\item{\_bondValues}
\item{\_callOptionValues}
\item{\_putOptionValues}
\item{\_dfTimes}
\item{\_dfValues}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Constructs the Hull-White rate model. The speed of mean reversion a and volatility are passed in. The short rate process is given by dr = (theta(t) - ar) * dt  + sigma * dW  

\begin{lstlisting}
    def __init__(self, a, sigma):
\end{lstlisting}

\subsubsection*{{\bf optionOnZeroCouponBond}}
Price an option on a zero coupon bond using analytical solution of Hull-White model. User provides bond face and option strike and expiry date and maturity date.  

\begin{lstlisting}
    def optionOnZeroCouponBond(self, texp, tmat, strikePrice, face,
                               dfTimes, dfValues):
\end{lstlisting}

\subsubsection*{{\bf europeanBondOption\_Jamshidian}}
Valuation of a European bond option using the Jamshidian deconstruction of the bond into a strip of zero coupon bonds with the short rate that would make the bond option be at the money forward.  

\begin{lstlisting}
    def europeanBondOption_Jamshidian(self, texp, strikePrice, face, cpnTimes,
                              cpnAmounts, dfTimes, dfValues):
\end{lstlisting}

\subsubsection*{{\bf europeanBondOption\_Tree}}
Price an option on a coupon-paying bond using tree to generate short rates at the expiry date and then to analytical solution of zero coupon bond in HW model to calculate the corresponding bond price. User provides bond object and option details.  

\begin{lstlisting}
    def europeanBondOption_Tree(self, texp, strikePrice, face, cpnTimes,
                                cpnAmounts):
\end{lstlisting}

\subsubsection*{{\bf optionOnZeroCouponBond\_Tree}}
Price an option on a zero coupon bond using a HW trinomial tree. The discount curve was already supplied to the tree build.  

\begin{lstlisting}
    def optionOnZeroCouponBond_Tree(self, texp, tmat, strikePrice, face):
\end{lstlisting}

\subsubsection*{{\bf americanBondOption\_Tree}}


\begin{lstlisting}
    def americanBondOption_Tree(self, texp, strikePrice, face,
                        couponTimes, couponAmounts, americanExercise):
\end{lstlisting}

\subsubsection*{{\bf americanBondOption\_Tree\_OLD}}


\begin{lstlisting}
    def americanBondOption_Tree_OLD(self, texp, strikePrice, face,
                        couponTimes, couponAmounts, americanExercise):
\end{lstlisting}

\subsubsection*{{\bf df\_Tree}}
Discount factor as seen from now to time tmat as long as the time is on the tree grid.  

\begin{lstlisting}
    def df_Tree(self, tmat):
\end{lstlisting}

\subsubsection*{{\bf buildTree}}
def buildTree(self, treeMat, numTimeSteps, dfTimes, dfValues): 

\begin{lstlisting}
    def buildTree(self, treeMat, numTimeSteps, dfTimes, dfValues):
\end{lstlisting}

\subsubsection*{{\bf accruedInterpolator}}
Fast calulation of accrued interest using an Actual/Actual type of convention. This does not calculate according to other conventions.  

\begin{lstlisting}
def accruedInterpolator(tset, couponTimes, couponAmounts):
\end{lstlisting}

\subsubsection*{{\bf P\_Fast}}
Forward discount factor as seen at some time t which may be in the future for payment at time T where Rt is the delta-period short rate seen at time t and pt is the discount factor to time t, ptd is the one period discount factor to time t+dt and pT is the discount factor from now until the payment of the 1 dollar of the discount factor.  

\begin{lstlisting}
def P_Fast(t, T, Rt, delta, pt, ptd, pT, _sigma, _a):
\end{lstlisting}

\subsubsection*{{\bf buildTree\_Fast}}
Fast tree construction using Numba.  

\begin{lstlisting}
def buildTree_Fast(a, sigma, treeTimes, numTimeSteps, discountFactors):
\end{lstlisting}

\subsubsection*{{\bf americanBondOption\_Tree\_Fast}}


\begin{lstlisting}
def americanBondOption_Tree_Fast(texp, strikePrice, face,
                    couponTimes, couponAmounts, americanExercise,
                    _sigma, _a, _Q, _pu, _pm, _pd, _rt, _dt, _treeTimes,
                    _dfTimes, _dfValues):
\end{lstlisting}

\subsubsection*{{\bf fwdFullBondPrice}}
Price a coupon bearing bond on the option expiry date and return the difference from a strike price. This is used in a root search to find the future expiry time short rate that makes the bond price equal to the option strike price. It is a key step in the Jamshidian bond decomposition approach. The strike is a clean price.  

\begin{lstlisting}
def fwdFullBondPrice(rt, *args):
\end{lstlisting}

\newpage
\section{FinLHPlusModel}

\subsection*{Class: LHPlusModel()}
Large Homogenous Portfolio model with extra asset. Used for approximating full Gaussian copula.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_P}
\item{\_R}
\item{\_H}
\item{\_beta}
\item{\_P0}
\item{\_R0}
\item{\_H0}
\item{\_beta0}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, P, R, H, beta, P0, R0, H0, beta0): 

\begin{lstlisting}
    def __init__(self, P, R, H, beta, P0, R0, H0, beta0):
\end{lstlisting}

\subsubsection*{{\bf probLossGreaterThanK}}
Returns P(L>K) where L is the portfolio loss given by model.  

\begin{lstlisting}
    def probLossGreaterThanK(self, K):
\end{lstlisting}

\subsubsection*{{\bf expMinLKIntegral}}
def expMinLKIntegral(self, K, dK): 

\begin{lstlisting}
    def expMinLKIntegral(self, K, dK):
\end{lstlisting}

\subsubsection*{{\bf expMinLK}}
def expMinLK(self, K): 

\begin{lstlisting}
    def expMinLK(self, K):
\end{lstlisting}

\subsubsection*{{\bf expMinLK2}}
def expMinLK2(self, K): 

\begin{lstlisting}
    def expMinLK2(self, K):
\end{lstlisting}

\subsubsection*{{\bf trancheSurvivalProbability}}
def trancheSurvivalProbability(self, k1, k2): 

\begin{lstlisting}
    def trancheSurvivalProbability(self, k1, k2):
\end{lstlisting}

\newpage
\section{FinLossDbnBuilder}

\subsubsection*{{\bf indepLossDbnHeterogeneousAdjBinomial}}
lossRatio): 

\begin{lstlisting}
def indepLossDbnHeterogeneousAdjBinomial(numCredits,
                                         condProbs,
                                         lossRatio):
\end{lstlisting}

\subsubsection*{{\bf portfolioGCD}}
def portfolioGCD(actualLosses): 

\begin{lstlisting}
def portfolioGCD(actualLosses):
\end{lstlisting}

\subsubsection*{{\bf indepLossDbnRecursionGCD}}
lossUnits): 

\begin{lstlisting}
def indepLossDbnRecursionGCD(numCredits,
                             condDefaultProbs,
                             lossUnits):
\end{lstlisting}

\newpage
\section{FinMertonCreditModel}

\subsubsection*{{\bf mertonCreditModelValues}}
volatility): 

\begin{lstlisting}
def mertonCreditModelValues(assetValue,
                            bondFace,
                            timeToMaturity,
                            riskFreeRate,
                            assetGrowthRate,
                            volatility):
\end{lstlisting}

\newpage
\section{FinProcessSimulator}

\subsubsection{Enumerated Type: FinProcessTypes}
\begin{itemize}
\item{GBM}
\item{CIR}
\item{HESTON}
\item{VASICEK}
\item{CEV}
\item{JUMP\_DIFFUSION}
\end{itemize}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsubsection{Enumerated Type: FinGBMNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinVasicekNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection*{Class: FinProcessSimulator()}
class FinProcessSimulator(): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self): 

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsubsection*{{\bf getProcess}}
seed): 

\begin{lstlisting}
    def getProcess(
            self,
            processType,
            t,
            modelParams,
            numAnnSteps,
            numPaths,
            seed):
\end{lstlisting}

\subsubsection*{{\bf getHestonPaths}}
seed): 

\begin{lstlisting}
def getHestonPaths(
        numPaths,
        numAnnSteps,
        t,
        drift,
        s0,
        v0,
        kappa,
        theta,
        sigma,
        rho,
        scheme,
        seed):
\end{lstlisting}

\subsubsection*{{\bf getGBMPaths}}
def getGBMPaths(numPaths, numAnnSteps, t, mu, stockPrice, sigma, scheme, seed): 

\begin{lstlisting}
def getGBMPaths(numPaths, numAnnSteps, t, mu, stockPrice, sigma, scheme, seed):
\end{lstlisting}

\subsubsection*{{\bf getVasicekPaths}}
seed): 

\begin{lstlisting}
def getVasicekPaths(
        numPaths,
        numAnnSteps,
        t,
        r0,
        kappa,
        theta,
        sigma,
        scheme,
        seed):
\end{lstlisting}

\subsubsection*{{\bf getCIRPaths}}
seed): 

\begin{lstlisting}
def getCIRPaths(
        numPaths,
        numAnnSteps,
        t,
        r0,
        kappa,
        theta,
        sigma,
        scheme,
        seed):
\end{lstlisting}

\newpage
\section{FinSABRModel}

\subsubsection*{{\bf blackVolFromSABR}}
def blackVolFromSABR(alpha, beta, rho, nu, f, k, t): 

\begin{lstlisting}
def blackVolFromSABR(alpha, beta, rho, nu, f, k, t):
\end{lstlisting}

\newpage
\section{FinStudentTCopulaModel}

\subsection*{Class: FinStudentTCopulaModel()}
class FinStudentTCopulaModel(): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsubsection*{{\bf defaultTimes}}
seed): 

\begin{lstlisting}
    def defaultTimes(self,
                     issuerCurves,
                     correlationMatrix,
                     degreesOfFreedom,
                     numTrials,
                     seed):
\end{lstlisting}

\newpage
\section{FinVasicekRateModel}

\subsection*{Class: FinVasicekModel()}
class FinVasicekModel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_a}
\item{\_b}
\item{\_sigma}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, a, b, sigma): 

\begin{lstlisting}
    def __init__(self, a, b, sigma):
\end{lstlisting}

\subsubsection*{{\bf meanr}}
def meanr(r0, a, b, t): 

\begin{lstlisting}
def meanr(r0, a, b, t):
\end{lstlisting}

\subsubsection*{{\bf variancer}}
def variancer(a, b, sigma, t): 

\begin{lstlisting}
def variancer(a, b, sigma, t):
\end{lstlisting}

\subsubsection*{{\bf zeroPrice}}
def zeroPrice(r0, a, b, sigma, t): 

\begin{lstlisting}
def zeroPrice(r0, a, b, sigma, t):
\end{lstlisting}

\subsubsection*{{\bf ratePath\_MC}}
def ratePath\_MC(r0, a, b, sigma, t, dt, seed): 

\begin{lstlisting}
def ratePath_MC(r0, a, b, sigma, t, dt, seed):
\end{lstlisting}

\subsubsection*{{\bf zeroPrice\_MC}}
def zeroPrice\_MC(r0, a, b, sigma, t, dt, numPaths, seed): 

\begin{lstlisting}
def zeroPrice_MC(r0, a, b, sigma, t, dt, numPaths, seed):
\end{lstlisting}


\chapter{financepy.portfolio}
\section{Introduction}

This is a class for portfolio asset selection using mean-varianceand other measures.

\begin{itemize}
\item{ FinBondPortfolio
}
\item{ FinMeanVariancePortfolio
}
\end{itemize}
\newpage
\section{FinBondPortfolio}

\subsection*{Class: FinBondPortfolio(object)}
Class for fixed coupon bonds and performing related analytics. These are bullet bonds which means they have regular coupon payments of a known size that are paid on known dates plus a payment of par at maturity. 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_numBonds}
\item{\_settlementDate}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create FinBondPortfolio object with a list of bond objects.  

\begin{lstlisting}
    def __init__(self, settlementDate, bondList):
\end{lstlisting}

\newpage
\section{FinMeanVariancePortfolio}


\chapter{financepy.risk}
\section{Introduction}

This folder contains all functionality relating to the calculation of portfolio risk measures.
\begin{itemize}
\item{ FinPortfolioCreditDefaultMode
}
\item{ FinPortfolioRiskMetrics
}
\end{itemize}
\newpage
\section{FinPortfolioCreditDefaultMode}

\subsection*{Class: FinPortfolioCreditDefaultMode(object)}
class FinPortfolioCreditDefaultMode(object): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_numCredits}
\item{\_weights}
\item{\_hazardRates}
\item{\_recoveryRates}
\item{\_betaValues}
\item{\_support}
\item{\_lossDbn}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
weights): 

\begin{lstlisting}
    def __init__(self,
                 weights):
\end{lstlisting}

\subsubsection*{{\bf lossDistribution}}
numPoints): 

\begin{lstlisting}
    def lossDistribution(self,
                         tmat,
                         hazardRates,
                         recoveryRates,
                         betaValues,
                         numPoints):
\end{lstlisting}

\newpage
\section{FinPortfolioRiskMetrics}

\subsubsection*{{\bf expectedLoss}}
lossProbabilityVector): 

\begin{lstlisting}
def expectedLoss(lossSizeVector,
                 lossProbabilityVector):
\end{lstlisting}

\subsubsection*{{\bf valueAtRisk}}
confidenceLevel): 

\begin{lstlisting}
def valueAtRisk(lossSizeVector,
                lossProbabilityVector,
                confidenceLevel):
\end{lstlisting}

\subsubsection*{{\bf expectedShortfall}}
confidenceLevel): 

\begin{lstlisting}
def expectedShortfall(lossSizeVector,
                      lossProbabilityVector,
                      confidenceLevel):
\end{lstlisting}


\chapter{financepy.market.curves}
\section{Introduction}


\section*{Curves}

\subsection*{Overview}
These modules create a family of curve types related to the term structures of interest rates. There are two basic types of curve:

\begin{enumerate}
\item{ Best fit yield curves fitting to bond prices which are used for interpolation. A range of curve shapes from polynomials to B-Splines is available.
}
\item{ Discount curves that can be used to present value a future cash flow. These differ from best fits curves in that they exactly refit the prices of bonds or CDS. The different discount curves are created by calibrating to different instruments. They also differ in terms of the term structure shapes they can have. Different shapes have different impacts in terms of locality on risk management performed using these different curves. There is often a trade-off between smoothness and locality.
}
\end{enumerate}


\subsection*{Best Fit Bond Curves}
The first category are FinBondYieldCurves.


\subsubsection*{FinBondYieldCurve}
This module describes a curve that is fitted to bond yields calculated from bond market prices supplied by the user. The curve is not guaranteed to fit all of the bond prices exactly and a least squares approach is used. A number of fitting forms are provided which consist of 

\begin{itemize}
\item{ Polynomial 
}
\item{ Nelson-Siegel
}
\item{ Nelson-Siegal-Svensson
}
\item{ Cubic B-Splines
}
\end{itemize}

This fitted curve cannot be used for pricing as yields assume a flat term structure. It can be used for fitting and interpolating yields off a nicely constructed yield curve interpolation curve.


\subsubsection*{FinCurveFitMethod}
This module sets out a range of curve forms that can be fitted to the bond yields. These includes a number of parametric curves that can be used to fit yield curves. These include:
\begin{itemize}
\item{ Polynomials of any degree 
}
\item{ Nelson-Siegel functional form. 
}
\item{ Nelson-Siegel-Svensson functional form.
}
\item{ B-Splines
}
\end{itemize}


\subsubsection*{FinNelsonSiegelCurve}
Implementation of the Nelson-Siegel and the Nelson-Siegel-Svensson curves.


\subsection*{Discount Curves}
These are curves that can be used to discount cashflows.


\subsubsection*{FinDiscountCurve}
This is a class that holds a Numpy array of times and discount factor values that represents a discount curve. It also requires a specific interpolation scheme. A function is also provided to return a survival probability so that this class can also be used to handle term structures of survival probabilities.


\subsubsection*{FinBondZeroCurve}
This is a discount curve that is extracted by bootstrapping a zero rate curve such that it exactly reprices the set of bonds provided. The internal representation of the curve are discount factors on each of the bond maturity dates. Between these dates, discount factors are interpolated according to a specified scheme - see below.


\subsubsection*{FinLiborCurve}
This is a discount curve that is extracted by bootstrapping a set of Libor deposits, Libor FRAs and Libor swap prices. The internal representation of the curve are discount factors on each of the deposit, FRA and swap maturity dates. Between these dates, discount factors are interpolated according to a specified scheme - see below.


\subsubsection*{FinCDSCurve}
This is a curve that has been calibrated to fit the market term structure of CDS contracts given a recovery rate assumption and a FinLiborCurve discount curve. It also contains a LiborCurve object for discounting. It has methods for fitting the curve and also for extracting survival probabilities.


\subsubsection*{FinInterpolate}
This module contains the interpolation function used throughout the discount curves when a discount factor needs to be interpolated. There are three interpolation methods:

\begin{enumerate}
\item{ PIECEWISE LINEAR - This assumes that a discount factor at a time between two other known discount factors is obtained by linear interpolation. This approach does not guarantee any smoothness but is local. It does not guarantee positive forwards (assuming positive zero rates).
}
\item{ PIECEWISE LOG LINEAR - This assumes that the log of the discount factor is interpolated linearly. The log of a discount factor to time T is T x R(T) where R(T) is the zero rate. So this is not linear interpolation of R(T) but of T x R(T).
}
\item{ FLAT FORWARDS - This interpolation assumes that the forward rate is constant between discount factor points. It is not smooth but is highly local and also ensures positive forward rates if the zero rates are positive.
}
\end{enumerate}
\newpage
\section{FinBondYieldCurve}

\subsection*{Class: FinBondYieldCurve()}
Class to do fitting of the yield curve and to enable interpolation of  yields. Because yields assume a flat term structure for each bond, this  class does not allow discounting to be done and so does not inherit from  FinDiscountCurve. It should only be used for visualisation and simple  interpolation but not for full term-structure-consistent pricing.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_settlementDate}
\item{\_bonds}
\item{\_ylds}
\item{\_curveFit}
\item{\_yearsToMaturity}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Fit the curve to a set of bond yields using the type of curve  specified. Bounds can be provided if you wish to enforce lower and  upper limits on the respective model parameters.  

\begin{lstlisting}
    def __init__(self, settlementDate, bonds, ylds, curveFit):
\end{lstlisting}

\subsubsection*{{\bf interpolatedYield}}
def interpolatedYield(self, maturityDate): 

\begin{lstlisting}
    def interpolatedYield(self, maturityDate):
\end{lstlisting}

\subsubsection*{{\bf plot}}
Display yield curve.  

\begin{lstlisting}
    def plot(self, title):
\end{lstlisting}

\newpage
\section{FinBondYieldCurveModel}

\subsection*{Class: FinCurveFitMethod()}
class FinCurveFitMethod(): 

\subsubsection*{Data Members}
No data members found.

\subsection*{Functions}

\subsection*{Class: FinCurveFitPolynomial()}
class FinCurveFitPolynomial(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_power}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, power=3): 

\begin{lstlisting}
    def __init__(self, power=3):
\end{lstlisting}

\subsubsection*{{\bf \_interpolatedYield}}
def \_interpolatedYield(self, t): 

\begin{lstlisting}
    def _interpolatedYield(self, t):
\end{lstlisting}

\subsection*{Class: FinCurveFitNelsonSiegel()}
class FinCurveFitNelsonSiegel(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_beta1}
\item{\_beta2}
\item{\_beta3}
\item{\_tau}
\item{\_bounds}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Fairly permissive bounds. Only tau1 is 1-100  

\begin{lstlisting}
    def __init__(self, tau=None, bounds=[(-1, -1, -1, 0.5), (1, 1, 1, 100)]):
\end{lstlisting}

\subsubsection*{{\bf \_interpolatedYield}}
def \_interpolatedYield(self, t, beta1=None, beta2=None, beta3=None, tau=None): 

\begin{lstlisting}
    def _interpolatedYield(self, t, beta1=None, beta2=None, beta3=None, tau=None):
\end{lstlisting}

\subsection*{Class: FinCurveFitNelsonSiegelSvensson()}
class FinCurveFitNelsonSiegelSvensson(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_beta1}
\item{\_beta2}
\item{\_beta3}
\item{\_beta4}
\item{\_tau1}
\item{\_tau2}
\item{\_bounds}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
I impose some bounds to help ensure a sensible result if the user does not provide any bounds. Especially for tau2.  

\begin{lstlisting}
    def __init__(self, tau1=None, 
                 tau2=None, 
                 bounds = [(0, -1, -1, -1, 0, 1), (1, 1, 1, 1, 10, 100)]):
\end{lstlisting}

\subsubsection*{{\bf \_interpolatedYield}}
beta4=None, tau1=None, tau2=None): 

\begin{lstlisting}
    def _interpolatedYield(self, t, beta1=None, beta2=None, beta3=None,
                           beta4=None, tau1=None, tau2=None):
\end{lstlisting}

\subsection*{Class: FinCurveFitBSpline()}
class FinCurveFitBSpline(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_parentType}
\item{\_power}
\item{\_knots}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, power=3, knots=[1, 3, 5, 10]): 

\begin{lstlisting}
    def __init__(self, power=3, knots=[1, 3, 5, 10]):
\end{lstlisting}

\subsubsection*{{\bf \_interpolatedYield}}
def \_interpolatedYield(self, t): 

\begin{lstlisting}
    def _interpolatedYield(self, t):
\end{lstlisting}

\newpage
\section{FinBondZeroCurve}

\subsection*{Class: FinBondZeroCurve()}


\subsubsection*{Data Members}
\begin{itemize}
\item{\_settlementDate}
\item{\_curveDate}
\item{\_bonds}
\item{\_cleanPrices}
\item{\_discountCurve}
\item{\_interpMethod}
\item{\_yearsToMaturity}
\item{\_times}
\item{\_values}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Fit a discount curve to a set of bond yields using the type of  curve specified.  

\begin{lstlisting}
    def __init__(self, settlementDate, bonds, cleanPrices,
                 interpMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf bootstrapZeroRates}}
def bootstrapZeroRates(self): 

\begin{lstlisting}
    def bootstrapZeroRates(self):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Calculate the zero rate to maturity date.  

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf df}}
def df(self, dt): 

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsubsection*{{\bf survProb}}
def survProb(self, dt): 

\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Calculate the continuous forward rate at the forward date.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwdRate}}
Calculate the forward rate according to the specified day count convention.  

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsubsection*{{\bf plot}}
Display yield curve.  

\begin{lstlisting}
    def plot(self, title):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(df, *args): 

\begin{lstlisting}
def f(df, *args):
\end{lstlisting}

\newpage
\section{FinCDSCurve}

\subsection*{Class: FinCDSCurve()}
Generate a survival probability curve implied by the value of CDS contracts given a Libor curve and an assumed recovery rate. A scheme for the interpolation of the survival probabilities is also required.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_curveDate}
\item{\_cdsContracts}
\item{\_recoveryRate}
\item{\_liborCurve}
\item{\_interpolationMethod}
\item{\_builtOK}
\item{\_times}
\item{\_values}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def __init__(self,
                 curveDate,
                 cdsContracts,
                 liborCurve,
                 recoveryRate=0.40,
                 useCache=False,
                 interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf validate}}
Ensure that contracts are in increasinbg maturity.  

\begin{lstlisting}
    def validate(self, cdsContracts):
\end{lstlisting}

\subsubsection*{{\bf survProb}}
Extract the survival probability to date dt.  

\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsubsection*{{\bf df}}
Extract the discount factor from the underlying Libor curve.  

\begin{lstlisting}
    def df(self, t):
\end{lstlisting}

\subsubsection*{{\bf buildCurve}}
def buildCurve(self): 

\begin{lstlisting}
    def buildCurve(self):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Calculate the instantaneous forward rate at the forward date.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwdRate}}
Calculate the forward rate according to the specified day count convention.  

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Calculate the zero rate to maturity date.  

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsubsection*{{\bf uniformToDefaultTime}}
def uniformToDefaultTime(u, t, v): 

\begin{lstlisting}
def uniformToDefaultTime(u, t, v):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(q, *args): 

\begin{lstlisting}
def f(q, *args):
\end{lstlisting}

\newpage
\section{FinCurve}

\subsubsection*{{\bf inputFrequency}}
def inputFrequency(f): 

\begin{lstlisting}
def inputFrequency(f):
\end{lstlisting}

\subsubsection*{{\bf inputTime}}
def inputTime(dt, curve): 

\begin{lstlisting}
def inputTime(dt, curve):
\end{lstlisting}

\newpage
\section{FinDiscountCurve}

\subsection*{Class: FinDiscountCurve()}
class FinDiscountCurve(): 

\subsubsection*{Data Members}
\begin{itemize}
\item{\_curveDate}
\item{\_times}
\item{\_values}
\item{\_interpMethod}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
interpMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def __init__(self, curveDate, times, values,
                 interpMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Calculate the zero rate to maturity date.  

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf df}}
def df(self, dt): 

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsubsection*{{\bf survProb}}
def survProb(self, dt): 

\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Calculate the continuous forward rate at the forward date.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf bump}}
Calculate the continuous forward rate at the forward date.  

\begin{lstlisting}
    def bump(self, bumpSize):
\end{lstlisting}

\subsubsection*{{\bf fwdRate}}
Calculate the forward rate according to the specified day count convention.  

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinFlatCurve}

\subsection*{Class: FinFlatCurve(FinDiscountCurve)}
A trivally simple curve based on a single zero rate with its own specified compounding method. Hence the curve is assumed to be flat.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_curveDate}
\item{\_rate}
\item{\_cmpdFreq}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create a FinFlatCurve which requires a curve date.  

\begin{lstlisting}
    def __init__(self, curveDate, rate, compoundingFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Return the zero rate which is simply the curve rate.  

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq):
\end{lstlisting}

\subsubsection*{{\bf bump}}
Calculate the continuous forward rate at the forward date.  

\begin{lstlisting}
    def bump(self, bumpSize):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Return the fwd rate which is simply the zero rate.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf df}}
Return the discount factor based on the compounding approach.  

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwdRate}}
Calculate the forward rate according to the specified day count convention.  

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\newpage
\section{FinInterpolate}

\subsubsection{Enumerated Type: FinInterpMethods}
\begin{itemize}
\item{LINEAR\_ZERO\_RATES}
\item{FLAT\_FORWARDS}
\item{LINEAR\_FORWARDS}
\end{itemize}

\subsubsection*{{\bf interpolate}}
method): 

\begin{lstlisting}
def interpolate(x,
                times,
                dfs,
                method):
\end{lstlisting}

\subsubsection*{{\bf uinterpolate}}
Return the interpolated value of y given x and a vector of x and y. The values of x must be monotonic and increasing. The different schemes for interpolation are linear in y (as a function of x), linear in log(y) and piecewise flat in the continuously compounded forward y rate.  

\begin{lstlisting}
def uinterpolate(t,
                 times,
                 dfs,
                 method):
\end{lstlisting}

\subsubsection*{{\bf vinterpolate}}
Return the interpolated values of y given x and a vector of x and y. The values of x must be monotonic and increasing. The different schemes for interpolation are linear in y (as a function of x), linear in log(y) and piecewise flat in the continuously compounded forward y rate.  

\begin{lstlisting}
def vinterpolate(xValues,
                 xvector,
                 dfs,
                 method):
\end{lstlisting}

\newpage
\section{FinLiborCurve}

\subsection*{Class: FinLiborCurve(FinDiscountCurve)}
Constructs a discount curve as implied by the prices of Libor  deposits, FRAs and IRS. The curve date is the date on which we are performing the valuation based on the information available on the curve date. Typically it is the date on which an amount of $1 paid has a present value of $1.  This class inherits from FinDiscountCurve so has all of the methods that class has.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_name}
\item{\_curveDate}
\item{\_interpMethod}
\item{\_usedDeposits}
\item{\_usedFRAs}
\item{\_usedSwaps}
\item{\_times}
\item{\_values}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
interpMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def __init__(self,
                 name,
                 curveDate,
                 liborDeposits,
                 liborFRAs,
                 liborSwaps,
                 interpMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf validateInputs}}
Construct the discount curve using a bootstrap approach.  

\begin{lstlisting}
    def validateInputs(self,
                       liborDeposits,
                       liborFRAs,
                       liborSwaps):
\end{lstlisting}

\subsubsection*{{\bf buildCurve}}
Construct the discount curve using a bootstrap approach.  

\begin{lstlisting}
    def buildCurve(self):
\end{lstlisting}

\subsubsection*{{\bf f}}
def f(df, *args): 

\begin{lstlisting}
def f(df, *args):
\end{lstlisting}

\newpage
\section{FinNelsonSiegelCurve}

\subsection*{Class: FinNelsonSiegelCurve()}
Implementation of Nelson-Siegel parametrisation of a rate curve.  The default is a continuously compounded rate but you can override  this by providing a corresponding compounding frequency.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_curveDate}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Creation of a Nelson-Siegel curve. Parameters are provided as a  list or vector of 4 values for beta1, beta2, beta3 and tau.  

\begin{lstlisting}
    def __init__(self, curveDate, params, cmpdFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Calculation of zero rates with specified frequency. This  function can return a vector of zero rates given a vector of  times so must use Numpy functions.  

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Calculation of forward rates. This function can return a vector of instantaneous forward rates given a vector of times.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf df}}
Discount factor for Nelson-Siegel curve parametrisation.  

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection*{Class: FinNelsonSiegelSvenssonCurve()}
Implementation of Nelson-Siegel-Svensson parametrisation of the zero rate curve  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_beta1}
\item{\_beta2}
\item{\_beta3}
\item{\_beta4}
\item{\_tau1}
\item{\_tau2}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
def \_\_init\_\_(self, beta1, beta2, beta3, beta4, tau1, tau2): 

\begin{lstlisting}
    def __init__(self, beta1, beta2, beta3, beta4, tau1, tau2):
\end{lstlisting}

\subsubsection*{{\bf zero}}
Calculation of zero rates. This function can return a vector of zero rates given a vector of times.  

\begin{lstlisting}
    def zero(self, t):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Calculation of forward rates. This function uses Numpy so can return a vector of forward rates given a Numpy array vector of times.  

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsubsection*{{\bf df}}
Discount factor for Nelson-Siegel-Svensson curve  parametrisation.  

\begin{lstlisting}
    def df(self, t):
\end{lstlisting}

\newpage
\section{FinPiecewiseFlatCurve}

\subsection*{Class: FinPiecewiseCurve()}
Curve is made up of a series of zero rates assumed to each have a  piecewise flat constant shape OR a piecewise linear shape.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_times}
\item{\_zeroRates}
\item{\_cmpdFreq}
\item{\_interpMethod}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Curve is a vector of increasing times and zero rates.  

\begin{lstlisting}
    def __init__(self,
                 curveDate,
                 times,
                 zeroRates,
                 compoundingFreq=-1,
                 interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
def zeroRate(self, t, compoundingFreq): 

\begin{lstlisting}
    def zeroRate(self, t, compoundingFreq):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
def fwd(self, t): 

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsubsection*{{\bf df}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def df(self,
           t,
           freq=0,  # This corresponds to continuous compounding
           interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\newpage
\section{FinPiecewiseLinearCurve}

\subsection*{Class: FinPiecewiseLinearCurve()}
Curve is made up of a series of sections assumed to each have a constant forward rate. This class needs to be checked carefully.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_times}
\item{\_values}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Curve is defined by a vector of increasing times and zero rates.  

\begin{lstlisting}
    def __init__(self, curveDate, times, values):
\end{lstlisting}

\subsubsection*{{\bf zero}}
def zero(self, t, interpolationMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def zero(self, t, interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
def fwd(self, t): 

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsubsection*{{\bf df}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS): 

\begin{lstlisting}
    def df(self,
           t,
           freq=0,  # This corresponds to continuous compounding
           interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\newpage
\section{FinPolynomialCurve}

\subsection*{Class: FinPolynomialCurve()}
Curve with zero rate of specified frequency parametrised  as a cubic polynomial.  

\subsubsection*{Data Members}
\begin{itemize}
\item{\_curveDate}
\item{\_coefficients}
\item{\_power}
\end{itemize}

\subsection*{Functions}

\subsubsection*{{\bf \_\_init\_\_}}
Create cubic curve from coefficients  

\begin{lstlisting}
    def __init__(self, curveDate, coefficients,
                 compoundingType=-1):
\end{lstlisting}

\subsubsection*{{\bf zeroRate}}
Zero rate from polynomial zero curve.  

\begin{lstlisting}
    def zeroRate(self, dt):
\end{lstlisting}

\subsubsection*{{\bf df}}
Discount factor from polynomial zero curve. 

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwd}}
Continuously compounded forward rate.  

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsubsection*{{\bf fwdRate}}
Calculate the forward rate according to the specified day count convention.  

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsubsection*{{\bf print}}
def print(self): 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\end{document}
