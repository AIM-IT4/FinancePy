\documentclass[twoside,11pt]{book} 

\usepackage{bibentry}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{a4wide} %THIS ONE
\usepackage{color}
\usepackage{ebezier}
\usepackage{graphicx,pstricks}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{framed}
\usepackage[light,all,bottomafter]{draftcopy} 
\usepackage{sectsty} 
\usepackage{index}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{tocloft}
\usepackage{wordlike}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\lstset{language=Python}
 
\makeindex

\renewcommand{\baselinestretch}{1.1}

%\sectionfont{\Large \bf}
%\subsectionfont{\large \bf}

\headheight=16pt
\topskip=0pt

\newenvironment{itemize*}%
{\begin{itemize}%
\setlength{\leftmargin}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{itemize}}

\newenvironment{enumerate*}%
{\begin{enumerate}%
\setlength{\leftmargini}{0pt}
\setlength{\itemindent}{0pt}%
\setlength{\itemsep}{2pt}%
\setlength{\parskip}{2pt}}%
{\end{enumerate}}

\newcommand{\figsize}{0.55}
\newcommand{\twofigsize}{0.4}

\newenvironment{example}{
\definecolor{shadecolor}{rgb}{0.9,0.9,0.8}
\begin{shaded}
\vspace{0.2cm} \bf \noindent Example:\normalfont  }
{
\end{shaded}
}

\newenvironment{new}{
\definecolor{shadecolor}{rgb}{0.9,1,1}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{cut}{
\definecolor{shadecolor}{rgb}{1.0,0.6,0.6}
\begin{shaded}
\vspace{0.0cm} \noindent }
{
\end{shaded}
\black 
}

\newenvironment{status}{
\definecolor{shadecolor}{rgb}{0.95,0.5,0.85}
\begin{shaded}
\vspace{0.0cm} \bf \noindent To do:\normalfont}{\end{shaded}}

\leftmargin=0pt
\itemindent=0pt

\usepackage{courier}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}

\begin{document}

\title{{\Huge \bf FinancePy}}
\author{Dominic O'Kane}

\maketitle 

\cleardoublepage

\cftsetindents{section}{1em}{3em}
\setcounter{tocdepth}{1}
\tableofcontents

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Introduction}
Stuff about FinancePy
\chapter{..//finutils}
\section{Introduction}
# FinUtils

This is a collection of modules used across a wide range of FinancePy functions. Examples include date generation, special mathematical functions.

###FinDate

###FinCalendar

###
\newpage
\section{FinCalendar}

\subsubsection{Enumerated Type: FinDayAdjustTypes}
\begin{itemize}
\item{NONE}
\item{FOLLOWING}
\item{MODIFIED\_FOLLOWING}
\item{PRECEDING}
\item{MODIFIED\_PRECEDING}
\end{itemize}

\subsubsection{Enumerated Type: FinCalendarTypes}
\begin{itemize}
\item{TARGET}
\item{US}
\item{UK}
\item{NONE}
\item{WEEKEND}
\end{itemize}

\subsubsection{Enumerated Type: FinDateGenRuleTypes}
\begin{itemize}
\item{FORWARD}
\item{BACKWARD}
\end{itemize}

\subsection{Class: FinCalendar(object)}
Class to manage designation of payment dates as holidays according to acalendar convention specified by the user. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_type}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, calendarType):
\end{lstlisting}

\subsection{Class Method {\it adjust}}
Adjust a payment date if it falls on a holiday according to thespecified business day convention. 

\begin{lstlisting}
    def adjust(self, dt, busDayConventionType):
\end{lstlisting}

\subsection{Class Method {\it isBusinessDay}}


\begin{lstlisting}
    def isBusinessDay(self, dt):
\end{lstlisting}

\subsection{Class Method {\it easterMonday}}
Get the day in a givenm year that is Easter Monday. This is noteasy to compute so we rely on a pre-calculated array. 

\begin{lstlisting}
    def easterMonday(self, y):
\end{lstlisting}

\subsection{Class Method {\it str}}
def str(self):

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinDate}

\subsection{Class: FinDate()}
Date class that is simple to use and includes a number of usefuldate functions used frequently in Finance. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_y}
\item{self.\_d}
\item{self.\_excelDate}
\item{self.\_m}
\item{self.\_weekday}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create a date given year, month and day of month. The order is not enforced as long as the middle number is the month. The year must be a 4-digit number. 

\begin{lstlisting}
    def __init__(self, y_or_d, m, d_or_y):
\end{lstlisting}

\subsection{Class Method {\it fromDatetime}}


\begin{lstlisting}
    def fromDatetime(dt):
\end{lstlisting}

\subsection{Class Method {\it refresh}}
Update internal representation of date as number of days since the1st Jan 1900. This is same as Excel convention. 

\begin{lstlisting}
    def refresh(self):
\end{lstlisting}

\subsection{Class Method {\it \_\_lt\_\_}}
def \_\_lt\_\_(self, other):

\begin{lstlisting}
    def __lt__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_gt\_\_}}
def \_\_gt\_\_(self, other):

\begin{lstlisting}
    def __gt__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_le\_\_}}
def \_\_le\_\_(self, other):

\begin{lstlisting}
    def __le__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_ge\_\_}}
def \_\_ge\_\_(self, other):

\begin{lstlisting}
    def __ge__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_sub\_\_}}
def \_\_sub\_\_(self, other):

\begin{lstlisting}
    def __sub__(self, other):
\end{lstlisting}

\subsection{Class Method {\it \_\_eq\_\_}}
def \_\_eq\_\_(self, other):

\begin{lstlisting}
    def __eq__(self, other):
\end{lstlisting}

\subsection{Class Method {\it isWeekend}}


\begin{lstlisting}
    def isWeekend(self):
\end{lstlisting}

\subsection{Class Method {\it addDays}}


\begin{lstlisting}
    def addDays(self, numDays):
\end{lstlisting}

\subsection{Class Method {\it addWorkDays}}


\begin{lstlisting}
    def addWorkDays(self, numDays):
\end{lstlisting}

\subsection{Class Method {\it addMonths}}


\begin{lstlisting}
    def addMonths(self, mm):
\end{lstlisting}

\subsection{Class Method {\it nextCDSDate}}


\begin{lstlisting}
    def nextCDSDate(self, mm=0):
\end{lstlisting}

\subsection{Class Method {\it thirdWednesdayOfMonth}}
For a specific month and year this returns the day number of the3rd Wednesday by scanning through dates in the third week 

\begin{lstlisting}
    def thirdWednesdayOfMonth(self, m, y):
\end{lstlisting}

\subsection{Class Method {\it nextIMMDate}}
This function returns the next IMM date after the current dateThis is a 3rd Wednesday of Jun, March, Sep or December 

\begin{lstlisting}
    def nextIMMDate(self):
\end{lstlisting}

\subsection{Class Method {\it addTenor}}


\begin{lstlisting}
    def addTenor(self, tenor):
\end{lstlisting}

\subsection{Class Method {\it datediff}}


\begin{lstlisting}
    def datediff(d1, d2):
\end{lstlisting}

\subsection{Class Method {\it date}}
def date(self):

\begin{lstlisting}
    def date(self):
\end{lstlisting}

\subsection{Class Method {\it \_\_str\_\_}}
def \_\_str\_\_(self):

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\subsection{Function {\it dailyWorkingDaySchedule}}
def dailyWorkingDaySchedule(self, startDate, endDate):

\begin{lstlisting}
def dailyWorkingDaySchedule(self, startDate, endDate):
\end{lstlisting}

\newpage
\section{FinDayCount}

\subsubsection{Enumerated Type: FinDayCountTypes}
\begin{itemize}
\item{THIRTY\_E\_360\_ISDA}
\item{THIRTY\_E\_360\_PLUS\_ISDA}
\item{ACT\_ACT\_ISDA}
\item{ACT\_ACT\_ICMA}
\item{ACT\_365\_ISDA}
\item{THIRTY\_360}
\item{THIRTY\_360\_BOND}
\item{THIRTY\_E\_360}
\item{ACT\_360}
\item{ACT\_365\_FIXED}
\item{ACT\_365\_LEAP}
\end{itemize}

\subsection{Class: FinDayCount(object)}
Calculate the fractional day count between two dates according to aspecified convention. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_type}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, dccType):
\end{lstlisting}

\subsection{Class Method {\it yearFrac}}
Calculate the year fraction between dates dt1 and dt2 using thespecified day count convention. 

\begin{lstlisting}
    def yearFrac(self, dt1, dt2, dt3=None):
\end{lstlisting}

\subsection{Class Method {\it \_\_str\_\_}}
def \_\_str\_\_(self):

\begin{lstlisting}
    def __str__(self):
\end{lstlisting}

\newpage
\section{FinError}

\subsection{Class: FinError(Exception)}
Simple error class specific to FinPy. Need to decide how to handleFinancePy errors. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_message}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, message):

\begin{lstlisting}
    def __init__(self, message):
\end{lstlisting}

\subsection{Class Method {\it printMessage}}
def printMessage(self):

\begin{lstlisting}
    def printMessage(self):
\end{lstlisting}

\subsection{Function {\it func\_name}}
def func\_name():

\begin{lstlisting}
def func_name():
\end{lstlisting}

\subsection{Function {\it isNotEqual}}
def isNotEqual(x, y, tol=1e-6):

\begin{lstlisting}
def isNotEqual(x, y, tol=1e-6):
\end{lstlisting}

\newpage
\section{FinFrequency}

\subsubsection{Enumerated Type: FinFrequencyTypes}
\begin{itemize}
\item{ANNUAL}
\item{SEMI\_ANNUAL}
\item{QUARTERLY}
\item{MONTHLY}
\end{itemize}

\subsection{Function {\it FinFrequency}}
def FinFrequency(frequencyType):

\begin{lstlisting}
def FinFrequency(frequencyType):
\end{lstlisting}

\newpage
\section{FinGlobalVariables}

\newpage
\section{FinHelperFunctions}

\subsection{Function {\it inputFrequency}}
def inputFrequency(f):

\begin{lstlisting}
def inputFrequency(f):
\end{lstlisting}

\subsection{Function {\it inputTime}}
def inputTime(dt, curve):

\begin{lstlisting}
def inputTime(dt, curve):
\end{lstlisting}

\subsection{Function {\it listdiff}}


\begin{lstlisting}
def listdiff(a, b):
\end{lstlisting}

\subsection{Function {\it dotproduct}}
def dotproduct(xVector, yVector):

\begin{lstlisting}
def dotproduct(xVector, yVector):
\end{lstlisting}

\subsection{Function {\it frange}}
def frange(start, stop, step):

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\subsection{Function {\it normaliseWeights}}
def normaliseWeights(wtVector):

\begin{lstlisting}
def normaliseWeights(wtVector):
\end{lstlisting}

\newpage
\section{FinMath}

\subsection{Function {\it isLeapYear}}


\begin{lstlisting}
def isLeapYear(y):
\end{lstlisting}

\subsection{Function {\it scale}}


\begin{lstlisting}
def scale(x, factor):
\end{lstlisting}

\subsection{Function {\it testMonotonicity}}


\begin{lstlisting}
def testMonotonicity(x):
\end{lstlisting}

\subsection{Function {\it testRange}}


\begin{lstlisting}
def testRange(x, lower, upper):
\end{lstlisting}

\subsection{Function {\it maximum}}
Determine the maximum of two values a and b.TODO: Add Numba function signature and test speed versus Numpy. 

\begin{lstlisting}
def maximum(a, b):
\end{lstlisting}

\subsection{Function {\it maxaxis}}
Perform a search for the vector of maximum values over an axis of a2D Numpy Array 

\begin{lstlisting}
def maxaxis(s):
\end{lstlisting}

\subsection{Function {\it minaxis}}
Perform a search for the vector of minimum values over an axis of a2D Numpy Array 

\begin{lstlisting}
def minaxis(s):
\end{lstlisting}

\subsection{Function {\it covar}}
Calculate the Covariance of two arrays of numbers.TODO: check that this works well for Numpy Arrays and add NUMBA functionsignature to code. Do test of timings against Numpy. 

\begin{lstlisting}
def covar(a, b):
\end{lstlisting}

\subsection{Function {\it pairGCD}}
Determine the Greatest Common Divisor of two integers using Euclidsalgorithm. TODO - compare this with math.gcd(a,b) for speed. Also examineto see if I should not be declaring inputs as integers for NUMBA. 

\begin{lstlisting}
def pairGCD(v1, v2):
\end{lstlisting}

\subsection{Function {\it nprime}}
Calculate the first derivative of the Cumulative Normal CDF which issimply the PDF of the Normal Distribution 

\begin{lstlisting}
def nprime(x):
\end{lstlisting}

\subsection{Function {\it heaviside}}


\begin{lstlisting}
def heaviside(x):
\end{lstlisting}

\subsection{Function {\it frange}}
def frange(start, stop, step):

\begin{lstlisting}
def frange(start, stop, step):
\end{lstlisting}

\subsection{Function {\it normpdf}}


\begin{lstlisting}
def normpdf(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_fast}}


\begin{lstlisting}
def normcdf_fast(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_integrate}}
Calculation of Normal Distribution CDF by simple integrationwhich can become exact in the limit of the number of steps tendingtowards infinity. This function is used for checking as it is slowsince the number of integration steps is currently hardcoded to 10,000.

\begin{lstlisting}
def normcdf_integrate(x):
\end{lstlisting}

\subsection{Function {\it normcdf\_slow}}
Calculation of Normal Distribution CDF accurate to 1d-15.This method is faster than integration but slower than other approximations.Reference: J.L. Schonfelder, Math Comp 32(1978), pp 1232-1240. 

\begin{lstlisting}
def normcdf_slow(z):
\end{lstlisting}

\subsection{Function {\it normcdf}}
This is the Normal CDF function which forks to one of three of theimplemented approximations. This is based on the choice of the fast flagvariable. A value of 1 is the fast routine, 2 is the slow and 3 is theeven slower integration scheme. 

\begin{lstlisting}
def normcdf(x, fastFlag):
\end{lstlisting}

\subsection{Function {\it N}}
This is the shortcut to the default Normal CDF function and is currentlyhardcoded to the fastest of the implemented routines. This is the mostwidely used way to access the Normal CDF. 

\begin{lstlisting}
def N(x):
\end{lstlisting}

\subsection{Function {\it phi3}}
Bivariate Normal CDF function to upper limits $b1$ and $b2$ which usesintegration to perform the innermost integral. This may need furtherrefinement to ensure it is optimal as the current range of integration isfrom -7 and the integration steps are dx = 0.001. This may be excessive. 

\begin{lstlisting}
def phi3(b1, b2, b3, r12, r13, r23):
\end{lstlisting}

\subsection{Function {\it norminvcdf}}
This algorithm computes the inverse Normal CDF and is based on thealgorithm found at (http:\#home.online.no/~pjacklam/notes/invnorm/)which is by John Herrero (3-Jan-03) 

\begin{lstlisting}
def norminvcdf(p):
\end{lstlisting}

\subsection{Function {\it M}}
def M(a, b, c):

\begin{lstlisting}
def M(a, b, c):
\end{lstlisting}

\subsection{Function {\it phi2}}


\begin{lstlisting}
def phi2(h1, hk, r):
\end{lstlisting}

\subsection{Function {\it corrMatrixGenerator}}
Utility function to generate a full rank n x n correlation matrix witha flat correlation structure and value rho. 

\begin{lstlisting}
def corrMatrixGenerator(rho, n):
\end{lstlisting}

\newpage
\section{FinRateConverter}

\subsection{Class: FinRateConverter(object)}
class FinRateConverter(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.name}
\item{self.months}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it str}}
def str(self):

\begin{lstlisting}
    def str(self):
\end{lstlisting}

\newpage
\section{FinSchedule}

\subsection{Class: FinSchedule(object)}
A Schedule is a vector of dates generated according to ISDA standardrules which starts on the next date after the start date and runs up toan end date. Dates are adjusted to a provided calendar. The zerothelement is the PCD and the first element is the NCD 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_adjustedDates}
\item{self.\_frequencyType}
\item{self.\_calendarType}
\item{self.\_busDayAdjustType}
\item{self.\_endDate}
\item{self.\_dateGenRuleType}
\item{self.\_startDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType=FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generate}}
Generate schedule of dates according to specified date generationrules and also adjust these dates for holidays according tothe business day convention and the specified calendar. 

\begin{lstlisting}
    def generate(self):
\end{lstlisting}

\subsection{Class Method {\it print}}
Print out the details of the schedule and the actual dates. Thiscan be used for providing transparency on schedule calculations. 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinStatistics}

\subsection{Function {\it mean}}


\begin{lstlisting}
def mean(x):
\end{lstlisting}

\subsection{Function {\it stdev}}


\begin{lstlisting}
def stdev(x):
\end{lstlisting}

\subsection{Function {\it stderr}}


\begin{lstlisting}
def stderr(x):
\end{lstlisting}

\subsection{Function {\it var}}


\begin{lstlisting}
def var(x):
\end{lstlisting}

\subsection{Function {\it moment}}


\begin{lstlisting}
def moment(x, m):
\end{lstlisting}

\subsection{Function {\it correlation}}


\begin{lstlisting}
def correlation(x1, x2):
\end{lstlisting}

\newpage
\section{FinTenor}

\newpage
\section{FinTestCases}

\subsubsection{Enumerated Type: FinTestCaseMode}
\begin{itemize}
\item{SAVE\_TEST\_CASES}
\item{ANALYSE\_TEST\_CASES}
\item{DEBUG\_TEST\_CASES}
\end{itemize}

\subsection{Class: FinTestCases()}
Test case framework for FinancePy.- The basic step is that we generate a GOLDEN folder that creates an outputfile for each testcase which is assumed to be correct. This can be done byrunning the test cases Python file with the globalTestCaseMode flag set toFinTestCaseMode.SAVE\_TEST\_CASES.- The second step is that we change the value of globalTestCaseMode toFinTestCaseMode.ANALYSE\_TEST\_CASES and then run the test scripts. This timethey save a copy of the output to the COMPARE folder.Finally, a function called compareTestCases() is used to compare the newoutput with the GOLDEN output and states whether anything has changed.- The output of a test case has three forms each with its own method:1) print - this outputs comma separated values2) header - this must precede any print statement and labels the outputcolumns3) banner - this is any single string line separatorNote that the header TIME is special as it tells the analysis that thevalue in the corresponding column is a timing and so its value is allowedto change without triggering an error.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_carefulMode}
\item{self.\_headerFields}
\item{self.\_verbose}
\item{self.\_goldenFilename}
\item{self.\_headerFields[colNum]}
\item{self.\_foldersExist}
\item{self.\_mode}
\item{self.\_rootFolder}
\item{self.\_compareFilename}
\item{self.\_compareFolder}
\item{self.\_goldenFolder}
\item{self.\_moduleName}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create the TestCase given the module name and whether we are inGOLDEN or COMPARE mode. 

\begin{lstlisting}
    def __init__(self, moduleName, mode):
\end{lstlisting}

\subsection{Class Method {\it print}}


\begin{lstlisting}
    def print(self, *args):
\end{lstlisting}

\subsection{Class Method {\it banner}}


\begin{lstlisting}
    def banner(self, txt):
\end{lstlisting}

\subsection{Class Method {\it header}}


\begin{lstlisting}
    def header(self, *args):
\end{lstlisting}

\subsection{Class Method {\it compareRows}}


\begin{lstlisting}
    def compareRows(self, goldenRow, compareRow, rowNum):
\end{lstlisting}

\subsection{Class Method {\it compareTestCases}}


\begin{lstlisting}
    def compareTestCases(self):
\end{lstlisting}


\chapter{..//products//equities}
\section{Introduction}
This folder covers a range of equity derivative products. These range from simple Vanilla-style options to more complex payoffs and path-dependent options. 
\newpage
\section{FinAmericanOption}

\subsubsection{Enumerated Type: FinImplementations}
\begin{itemize}
\item{CRR\_TREE}
\item{BARONE\_ADESI\_APPROX}
\end{itemize}

\subsection{Class: FinAmericanOption()}
Class that performs the valuation of an American style option on adividend paying stock. Can easily be extended to price American style FXoptions. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_strikePrice}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
numSteps=100):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model,
              numSteps=100):
\end{lstlisting}

\subsection{Function {\it crrTreeVal}}


\begin{lstlisting}
def crrTreeVal(stockPrice,
               riskFreeRate,
               dividendYield,
               volatility,
               numSteps,
               timeToExpiry,
               optionType,
               strikePrice):
\end{lstlisting}

\newpage
\section{FinAsianOption}

\subsection{Class: FinAsianOption(FinOption)}
class FinAsianOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_strikePrice}
\item{self.\_startAveragingDate}
\item{self.\_optionType}
\item{self.\_expiryDate}
\item{self.\_numObservations}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
numberOfObservations=0):

\begin{lstlisting}
    def __init__(self,
                 startAveragingDate,
                 expiryDate,
                 strikePrice,
                 optionType,
                 numberOfObservations=0):
\end{lstlisting}

\subsection{Class Method {\it value}}
accruedAverage=None):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model,
              valuationMethod,
              accruedAverage=None):
\end{lstlisting}

\subsection{Class Method {\it valueGeometric}}
accruedAverage):

\begin{lstlisting}
    def valueGeometric(self,
                       valueDate,
                       stockPrice,
                       discountCurve,
                       dividendYield,
                       model,
                       accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueCurran}}
accruedAverage):

\begin{lstlisting}
    def valueCurran(self,
                    valueDate,
                    stockPrice,
                    discountCurve,
                    dividendYield,
                    model,
                    accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueTurnbullWakeman}}
accruedAverage):

\begin{lstlisting}
    def valueTurnbullWakeman(self,
                             valueDate,
                             stockPrice,
                             discountCurve,
                             dividendYield,
                             model,
                             accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
accruedAverage):

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths,
                seed,
                accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC\_fast}}
accruedAverage):

\begin{lstlisting}
    def valueMC_fast(self,
                     valueDate,
                     stockPrice,
                     discountCurve,
                     dividendYield,
                     model,
                     numPaths,
                     seed,
                     accruedAverage):
\end{lstlisting}

\subsection{Class Method {\it valueMC\_fast\_CV}}
accruedAverage):

\begin{lstlisting}
    def valueMC_fast_CV(self,
                        valueDate,
                        stockPrice,
                        discountCurve,
                        dividendYield,
                        model,
                        numPaths,
                        seed,
                        accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_NUMBA}}
accruedAverage):

\begin{lstlisting}
def valueMC_NUMBA(t0, t, tau, K, n, optionType,
                  stockPrice,
                  interestRate,
                  dividendYield,
                  volatility,
                  numPaths,
                  seed,
                  accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_fast\_NUMBA}}
accruedAverage):

\begin{lstlisting}
def valueMC_fast_NUMBA(t0, t, tau, K, n, optionType,
                       stockPrice,
                       interestRate,
                       dividendYield,
                       volatility,
                       numPaths,
                       seed,
                       accruedAverage):
\end{lstlisting}

\subsection{Function {\it valueMC\_fast\_CV\_NUMBA}}
v\_g\_exact):

\begin{lstlisting}
def valueMC_fast_CV_NUMBA(t0, t, tau, K, n, optionType,
                          stockPrice,
                          interestRate,
                          dividendYield,
                          volatility,
                          numPaths,
                          seed,
                          accruedAverage,
                          v_g_exact):
\end{lstlisting}

\newpage
\section{FinBarrierOption}

\subsubsection{Enumerated Type: FinBarrierTypes}
\begin{itemize}
\item{DOWN\_AND\_OUT\_CALL}
\item{DOWN\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_CALL}
\item{UP\_AND\_IN\_CALL}
\item{UP\_AND\_OUT\_PUT}
\item{UP\_AND\_IN\_PUT}
\item{DOWN\_AND\_OUT\_PUT}
\item{DOWN\_AND\_IN\_PUT}
\end{itemize}

\subsection{Class: FinBarrierOption(FinOption)}
class FinBarrierOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_strikePrice}
\item{self.\_optionType}
\item{self.\_expiryDate}
\item{self.\_numObservationsPerYear}
\item{self.\_barrierLevel}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
numObservationsPerYear):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType,
                 barrierLevel,
                 numObservationsPerYear):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            processType,
            modelParams,
            numAnnSteps=252,
            numPaths=10000,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinBasketOption}

\subsection{Class: FinBasketOption(FinOption)}
class FinBasketOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_strikePrice}
\item{self.\_optionType}
\item{self.\_numAssets}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
numAssets):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType,
                 numAssets):
\end{lstlisting}

\subsection{Class Method {\it validate}}
betas):

\begin{lstlisting}
    def validate(self,
                 stockPrices,
                 dividendYields,
                 volatilities,
                 betas):
\end{lstlisting}

\subsection{Class Method {\it value}}
betas):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrices,
              discountCurve,
              dividendYields,
              volatilities,
              betas):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinBinomialTree}

\subsubsection{Enumerated Type: FinTreePayoffTypes}
\begin{itemize}
\item{FWD\_CONTRACT}
\item{VANILLA\_OPTION}
\item{DIGITAL\_OPTION}
\item{POWER\_CONTRACT}
\item{POWER\_OPTION}
\item{LOG\_CONTRACT}
\item{LOG\_OPTION}
\end{itemize}

\subsubsection{Enumerated Type: FinTreeExerciseTypes}
\begin{itemize}
\item{EUROPEAN}
\item{AMERICAN}
\end{itemize}

\subsection{Class: FinBinomialTree()}
class FinBinomialTree():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.m\_stockValues}
\item{self.m\_optionValues}
\item{self.m\_numSteps}
\item{self.m\_numNodes}
\item{self.m\_upProbabilities}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it value}}
payoffParams):

\begin{lstlisting}
    def value(self,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              numSteps,
              valueDate,
              payoff,
              expiryDate,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\subsection{Function {\it validatePayoff}}
def validatePayoff(payoffType, payoffParams):

\begin{lstlisting}
def validatePayoff(payoffType, payoffParams):
\end{lstlisting}

\subsection{Function {\it payoffValue}}
def payoffValue(s, payoffType, payoffParams):

\begin{lstlisting}
def payoffValue(s, payoffType, payoffParams):
\end{lstlisting}

\subsection{Function {\it valueOnce}}
payoffParams):

\begin{lstlisting}
def valueOnce(stockPrice,
              r,
              dividendYield,
              volatility,
              numSteps,
              timeToExpiry,
              payoffType,
              exerciseType,
              payoffParams):
\end{lstlisting}

\newpage
\section{FinBlack}

\subsection{Class: BlackModel()}
class BlackModel():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it value}}
callOrPut):

\begin{lstlisting}
    def value(self,
              forwardRate,
              strikeRate,
              timeToExpiry,
              sigma,
              callOrPut):
\end{lstlisting}

\newpage
\section{FinCompoundOption}

\subsection{Class: FinCompoundOption(FinOption)}
class FinCompoundOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate2}
\item{self.\_optionType2}
\item{self.\_strikePrice2}
\item{self.\_expiryDate1}
\item{self.\_strikePrice1}
\item{self.\_optionType1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType2):

\begin{lstlisting}
    def __init__(self,
                 expiryDate1,
                 expiryDate2,
                 strikePrice1,
                 strikePrice2,
                 optionType1,
                 optionType2):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it valueTree}}
numSteps=200):

\begin{lstlisting}
    def valueTree(self,
                  valueDate,
                  stockPrice,
                  discountCurve,
                  dividendYield,
                  model,
                  numSteps=200):
\end{lstlisting}

\subsection{Class Method {\it impliedStockPrice}}
model):

\begin{lstlisting}
    def impliedStockPrice(self,
                          stockPrice,
                          expiryDate1,
                          expiryDate2,
                          strikePrice1,
                          strikePrice2,
                          optionType2,
                          interestRate,
                          dividendYield,
                          model):
\end{lstlisting}

\subsection{Function {\it f}}
def f(s0, *args):

\begin{lstlisting}
def f(s0, *args):
\end{lstlisting}

\subsection{Function {\it valueOnce}}
numSteps):

\begin{lstlisting}
def valueOnce(stockPrice,
              riskFreeRate,
              dividendYield,
              volatility,
              t1,
              t2,
              optionType1,
              optionType2,
              k1,
              k2,
              numSteps):
\end{lstlisting}

\newpage
\section{FinDigitalOption}

\subsection{Class: FinDigitalOption(FinOption)}
class FinDigitalOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_strikePrice}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinEquityModelTypes}

\subsection{Class: FinEquityModel(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class: FinEquityModelBlackScholes(FinEquityModel)}
class FinEquityModelBlackScholes(FinEquityModel):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, volatility):

\begin{lstlisting}
    def __init__(self, volatility):
\end{lstlisting}

\subsection{Class: FinEquityModelHeston(FinEquityModel)}
class FinEquityModelHeston(FinEquityModel):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\item{self.\_meanReversion}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, volatility, meanReversion):

\begin{lstlisting}
    def __init__(self, volatility, meanReversion):
\end{lstlisting}

\newpage
\section{FinFixedLookbackOption}

\subsubsection{Enumerated Type: FinFixedLookbackOptionTypes}
\begin{itemize}
\item{FIXED\_CALL}
\item{FIXED\_PUT}
\end{itemize}

\subsection{Class: FinFixedLookbackOption(FinOption)}
class FinFixedLookbackOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionStrike}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionStrike):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 optionType,
                 optionStrike):
\end{lstlisting}

\subsection{Class Method {\it value}}
stockMinMax):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              stockMinMax):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            volatility,
            stockMinMax,
            numPaths=10000,
            numStepsPerYear=252,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinFloatLookbackOption}

\subsubsection{Enumerated Type: FinFloatLookbackOptionTypes}
\begin{itemize}
\item{FLOATING\_CALL}
\item{FLOATING\_PUT}
\end{itemize}

\subsection{Class: FinFloatLookbackOption(FinOption)}
class FinFloatLookbackOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
stockMinMax):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              volatility,
              stockMinMax):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            volatility,
            stockMinMax,
            numPaths=10000,
            numStepsPerYear=252,
            seed=4242):
\end{lstlisting}

\newpage
\section{FinOption}

\subsubsection{Enumerated Type: FinOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\item{AMERICAN\_CALL}
\item{AMERICAN\_PUT}
\item{DIGITAL\_CALL}
\item{DIGITAL\_PUT}
\item{ASIAN\_CALL}
\item{ASIAN\_PUT}
\item{COMPOUND\_CALL}
\item{COMPOUND\_PUT}
\end{itemize}

\subsubsection{Enumerated Type: FinOptionModelTypes}
\begin{itemize}
\item{BLACKSCHOLES}
\item{ANOTHER}
\end{itemize}

\subsection{Class: FinOption(object)}
class FinOption(object):

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it delta}}
model):

\begin{lstlisting}
    def delta(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsection{Class Method {\it gamma}}
model):

\begin{lstlisting}
    def gamma(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsection{Class Method {\it vega}}
model):

\begin{lstlisting}
    def vega(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsection{Class Method {\it theta}}
model):

\begin{lstlisting}
    def theta(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\subsection{Class Method {\it rho}}
model):

\begin{lstlisting}
    def rho(
            self,
            valueDate,
            stockPrice,
            discountCurve,
            dividendYield,
            model):
\end{lstlisting}

\newpage
\section{FinRainbowOption}

\subsubsection{Enumerated Type: FinRainbowOptionTypes}
\begin{itemize}
\item{CALL\_ON\_MAXIMUM}
\item{PUT\_ON\_MAXIMUM}
\item{CALL\_ON\_MINIMUM}
\item{PUT\_ON\_MINIMUM}
\item{CALL\_ON\_NTH}
\item{PUT\_ON\_NTH}
\end{itemize}

\subsection{Class: FinRainbowOption(FinOption)}
class FinRainbowOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_payoffType}
\item{self.\_expiryDate}
\item{self.\_payoffParams}
\item{self.\_numAssets}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
numAssets):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 payoffType,
                 payoffParams,
                 numAssets):
\end{lstlisting}

\subsection{Class Method {\it validate}}
betas):

\begin{lstlisting}
    def validate(self,
                 stockPrices,
                 dividendYields,
                 volatilities,
                 betas):
\end{lstlisting}

\subsection{Class Method {\it validatePayoff}}
def validatePayoff(self, payoffType, payoffParams, numAssets):

\begin{lstlisting}
    def validatePayoff(self, payoffType, payoffParams, numAssets):
\end{lstlisting}

\subsection{Class Method {\it value}}
betas):

\begin{lstlisting}
    def value(self, 
              valueDate, 
              expiryDate, 
              stockPrices, 
              discountCurve,
              dividendYields, 
              volatilities, 
              betas):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                expiryDate,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\subsection{Function {\it payoffValue}}
def payoffValue(s, payoffTypeValue, payoffParams):

\begin{lstlisting}
def payoffValue(s, payoffTypeValue, payoffParams):
\end{lstlisting}

\subsection{Function {\it valueMCFast}}
seed=4242):

\begin{lstlisting}
def valueMCFast(t,
                stockPrices,
                discountCurve,
                dividendYields,
                volatilities,
                betas,
                numAssets,
                payoffType,
                payoffParams,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\newpage
\section{FinVanillaOption}

\subsection{Class: FinVanillaOption(FinOption)}
class FinVanillaOption(FinOption):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_strikePrice}
\item{self.\_optionType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
optionType):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 strikePrice,
                 optionType):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it delta}}
model):

\begin{lstlisting}
    def delta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it gamma}}
model):

\begin{lstlisting}
    def gamma(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it vega}}
model):

\begin{lstlisting}
    def vega(self,
             valueDate,
             stockPrice,
             discountCurve,
             dividendYield,
             model):
\end{lstlisting}

\subsection{Class Method {\it theta}}
model):

\begin{lstlisting}
    def theta(self,
              valueDate,
              stockPrice,
              discountCurve,
              dividendYield,
              model):
\end{lstlisting}

\subsection{Class Method {\it impliedVolatility}}
price):

\begin{lstlisting}
    def impliedVolatility(self,
                          valueDate,
                          stockPrice,
                          discountCurve,
                          dividendYield,
                          price):
\end{lstlisting}

\subsection{Class Method {\it valueMC}}
seed=4242):

\begin{lstlisting}
    def valueMC(self,
                valueDate,
                stockPrice,
                discountCurve,
                dividendYield,
                model,
                numPaths=10000,
                seed=4242):
\end{lstlisting}

\subsection{Class Method {\it value\_MC\_OLD}}
seed=4242):

\begin{lstlisting}
    def value_MC_OLD(self,
                     valueDate,
                     stockPrice,
                     discountCurve,
                     dividendYield,
                     terminalS,
                     seed=4242):
\end{lstlisting}

\subsection{Function {\it f}}
def f(volatility, *args):

\begin{lstlisting}
def f(volatility, *args):
\end{lstlisting}

\subsection{Function {\it fvega}}
def fvega(volatility, *args):

\begin{lstlisting}
def fvega(volatility, *args):
\end{lstlisting}

\newpage
\section{FinVarianceSwap}

\subsection{Class: FinVarianceSwap(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_payStrike}
\item{self.\_callWts[n]}
\item{self.\_numCallOptions}
\item{self.\_callStrikes}
\item{self.\_putWts[n]}
\item{self.\_putStrikes}
\item{self.\_putWts}
\item{self.\_strikeVariance}
\item{self.\_maturityDate}
\item{self.\_notional}
\item{self.\_callWts}
\item{self.\_numPutOptions}
\item{self.\_startDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDateOrTenor,
                 strikeVariance,
                 notional=ONE_MILLION,
                 payStrikeFlag=True):
\end{lstlisting}

\subsection{Class Method {\it value}}
Calculate the value of the variance swap based on the realisedvolatility to the valuation date, the forward looking impliedvolatility to the maturity date using the libor discount curve. 

\begin{lstlisting}
    def value(self, 
              valuationDate, 
              realisedVar, 
              fairStrikeVar, 
              liborCurve):
\end{lstlisting}

\subsection{Class Method {\it fairStrikeApprox}}
This is an approximation of the fair strike variance by Demeterfiet al. (1999) which assumes that sigma(K) = sigma(F) - b(K-F)/F whereF is the forward stock price and sigma(F) is the ATM forward vol. 

\begin{lstlisting}
    def fairStrikeApprox(self,
                         valuationDate,
                         fwdStockPrice,
                         strikes,
                         volatilities):
\end{lstlisting}

\subsection{Class Method {\it fairStrike}}
Calculate the implied variance according to the volatility surfaceusing a static replication methodology with a specially weightedportfolio of put and call options across a range of strikes using theapproximate method set out by Demeterfi et al. 1999. 

\begin{lstlisting}
    def fairStrike(self,
                   valuationDate,
                   stockPrice,
                   dividendYield,
                   volatilityCurve,
                   numCallOptions,
                   numPutOptions,
                   strikeSpacing,
                   discountCurve,
                   useForward=True):
\end{lstlisting}

\subsection{Class Method {\it f}}
def f(x): return (2.0/tmat)*((x-sstar)/sstar-log(x/sstar))

\begin{lstlisting}
        def f(x): return (2.0/tmat)*((x-sstar)/sstar-log(x/sstar))
\end{lstlisting}

\subsection{Class Method {\it realisedVariance}}
Calculate the realised variance according to market standardcalculations which can either use log or percentage returns.

\begin{lstlisting}
    def realisedVariance(self, closePrices, useLogs=True):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}


\chapter{..//products//credit}
\section{Introduction}
This folder contains a set of credit-related assets ranging from CDS to CDS options, to CDS indices, CDS index options and then to CDS tranches. 
\newpage
\section{FinCDS}

\subsection{Class: FinCDS(object)}
A class which manages Credit Default Swap. It performs schedule generationand the valuation and risk management of CDS. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_adjustedDates[flowNum-1]}
\item{self.\_adjustedDates}
\item{self.\_adjustedDates[i]}
\item{self.\_stepInDate}
\item{self.\_maturityDate}
\item{self.\_longProtection}
\item{self.\_notional}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_frequencyType}
\item{self.\_dateGenRuleType}
\item{self.\_busDayAdjustType}
\item{self.\_accrualFactors}
\item{self.\_flows}
\item{self.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
stepInDate - FinDate that is the date protection starts(usually T+1) runningCoupon - Size of coupon on premium leg 

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 runningCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generateAdjustedCDSPaymentDates}}


\begin{lstlisting}
    def generateAdjustedCDSPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it calcFlows}}


\begin{lstlisting}
    def calcFlows(self):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self,
              valuationDate,
              issuerCurve,
              contractRecovery=standardRecovery,
              pv01Method=0,
              prot_method=0,
              numStepsPerYear=25):
\end{lstlisting}

\subsection{Class Method {\it cashSettlementAmount}}
numStepsPerYear=25):

\begin{lstlisting}
    def cashSettlementAmount(self,
                             valuationDate,
                             settlementDate,
                             issuerCurve,
                             contractRecovery=standardRecovery,
                             pv01Method=0,
                             prot_method=0,
                             numStepsPerYear=25):
\end{lstlisting}

\subsection{Class Method {\it cleanPrice}}
numStepsPerYear=52):

\begin{lstlisting}
    def cleanPrice(self,
                   valuationDate,
                   issuerCurve,
                   contractRecovery=standardRecovery,
                   pv01Method=0,
                   prot_method=0,
                   numStepsPerYear=52):
\end{lstlisting}

\subsection{Class Method {\it riskyPV01\_OLD}}
pv01Method=0):

\begin{lstlisting}
    def riskyPV01_OLD(self,
                      valuationDate,
                      issuerCurve,
                      pv01Method=0):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}
def accruedDays(self):

\begin{lstlisting}
    def accruedDays(self):
\end{lstlisting}

\subsection{Class Method {\it accruedInterest}}
Calculate the amount of accrued interest that has accrued from theprevious coupon date (PCD) to the stepInDate of the CDS contract. 

\begin{lstlisting}
    def accruedInterest(self):
\end{lstlisting}

\subsection{Class Method {\it protectionLegPV}}
Calculates the protection leg PV of the CDS by calling into thefast NUMBA code that has been defined above. 

\begin{lstlisting}
    def protectionLegPV(self,
                        valuationDate,
                        issuerCurve,
                        contractRecovery=standardRecovery,
                        numStepsPerYear=25,
                        protMethod=0):
\end{lstlisting}

\subsection{Class Method {\it riskyPV01}}
pv01Method=0):

\begin{lstlisting}
    def riskyPV01(self,
                  valuationDate,
                  issuerCurve,
                  pv01Method=0):
\end{lstlisting}

\subsection{Class Method {\it premiumLegPV}}
pv01Method=0):

\begin{lstlisting}
    def premiumLegPV(self,
                     valuationDate,
                     issuerCurve,
                     pv01Method=0):
\end{lstlisting}

\subsection{Class Method {\it parSpread}}
protMethod=0):

\begin{lstlisting}
    def parSpread(self,
                  valuationDate,
                  issuerCurve,
                  contractRecovery=standardRecovery,
                  numStepsPerYear=25,
                  pv01Method=0,
                  protMethod=0):
\end{lstlisting}

\subsection{Class Method {\it valueFastApprox}}
Implementation of fast valuation of the CDS contract using anaccurate approximation that avoids curve building. 

\begin{lstlisting}
    def valueFastApprox(self,
                        valuationDate,
                        flatContinuousInterestRate,
                        flatCDSCurveSpread,
                        curveRecovery=standardRecovery,
                        contractRecovery=standardRecovery):
\end{lstlisting}

\subsection{Class Method {\it print}}
print out details of the CDS contract and all of the calculatedcashflows 

\begin{lstlisting}
    def print(self, valuationDate):
\end{lstlisting}

\subsection{Class Method {\it printFlows}}
def printFlows(self, issuerCurve):

\begin{lstlisting}
    def printFlows(self, issuerCurve):
\end{lstlisting}

\subsection{Function {\it riskyPV01\_NUMBA}}
Fast calculation of the risky PV01 of a CDS using NUMBA.The output is a numpy array of the full and clean risky PV01.

\begin{lstlisting}
def riskyPV01_NUMBA(teff,
                    accrualFactorPCDToNow,
                    paymentTimes,
                    yearFracs,
                    npLiborTimes,
                    npLiborValues,
                    npSurvTimes,
                    npSurvValues,
                    pv01Method):
\end{lstlisting}

\subsection{Function {\it protectionLegPV\_NUMBA}}
Fast calculation of the CDS protection leg PV using NUMBA to speed upthe numerical integration over time. 

\begin{lstlisting}
def protectionLegPV_NUMBA(teff,
                          tmat,
                          npLiborTimes,
                          npLiborValues,
                          npSurvTimes,
                          npSurvValues,
                          contractRecovery,
                          numStepsPerYear,
                          protMethod):
\end{lstlisting}

\newpage
\section{FinCDSBasket}

\subsection{Class: FinCDSBasket(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_stepInDate}
\item{self.\_maturityDate}
\item{self.\_notional}
\item{self.\_longProtection}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_frequencyType}
\item{self.\_dateGenRuleType}
\item{self.\_busDayAdjustType}
\item{self.\_cdsContract}
\item{self.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 notional=ONE_MILLION,
                 coupon=0.0,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueLegs\_MC}}
Value the legs of the default basket using Monte Carlo. The defaulttimes are an input so this valuation is not model dependent. 

\begin{lstlisting}
    def valueLegs_MC(self,
                     valuationDate,
                     nToDefault,
                     defaultTimes,
                     issuerCurves,
                     liborCurve):
\end{lstlisting}

\subsection{Class Method {\it valueGaussian\_MC}}


\begin{lstlisting}
    def valueGaussian_MC(self,
                         valuationDate,
                         nToDefault,
                         issuerCurves,
                         correlationMatrix,
                         liborCurve,
                         numTrials,
                         seed):
\end{lstlisting}

\subsection{Class Method {\it valueStudentT\_MC}}


\begin{lstlisting}
    def valueStudentT_MC(self,
                         valuationDate,
                         nToDefault,
                         issuerCurves,
                         correlationMatrix,
                         degreesOfFreedom,
                         liborCurve,
                         numTrials,
                         seed):
\end{lstlisting}

\subsection{Class Method {\it value1FGaussian\_Homo}}
Value default basket using 1 factor Gaussian copula and analyticalapproach which is only exact when all recovery rates are the same. 

\begin{lstlisting}
    def value1FGaussian_Homo(self,
                             valuationDate,
                             nToDefault,
                             issuerCurves,
                             betaVector,
                             liborCurve,
                             numPoints=50):
\end{lstlisting}

\newpage
\section{FinCDSIndexOption}

\subsection{Class: FinCDSIndexOption(object)}
Class to manage the pricing and risk management of an option to enterinto a CDS index. Different pricing algorithms are presented. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_businessDateAdjustType}
\item{self.\_strikeCoupon}
\item{self.\_maturityDate}
\item{self.\_notional}
\item{self.\_expiryDate}
\item{self.\_longProtection}
\item{self.\_dayCountType}
\item{self.\_calendarType}
\item{self.\_frequencyType}
\item{self.\_cdsContract}
\item{self.\_indexCoupon}
\item{self.\_dateGenRuleType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 maturityDate,
                 indexCoupon,
                 strikeCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueAdjustedBlack}}
This approach uses two adjustments to Blacks option pricingmodel to value an option on a CDS index. 

\begin{lstlisting}
    def valueAdjustedBlack(self,
                           valuationDate,
                           indexCurve,
                           indexRecovery,
                           liborCurve,
                           sigma):
\end{lstlisting}

\subsection{Class Method {\it valueAnderson}}
This function values a CDS index option following approach byAnderson (2006). This ensures that the no-arbitrage relationship betweenthe consituent CDS contract and the CDS index is enforced. It modelsthe forward spread as a log-normally distributed quantity and uses thecredit triangle to compute the forward RPV01. 

\begin{lstlisting}
    def valueAnderson(self,
                      valuationDate,
                      issuerCurves,
                      indexRecovery,
                      sigma):
\end{lstlisting}

\subsection{Class Method {\it solveForX}}


\begin{lstlisting}
    def solveForX(self,
                  valuationDate,
                  sigma,
                  indexCoupon,
                  indexRecovery,
                  liborCurve,
                  expH):
\end{lstlisting}

\subsection{Class Method {\it calcObjFunc}}


\begin{lstlisting}
    def calcObjFunc(self,
                    x,
                    valuationDate,
                    sigma,
                    indexCoupon,
                    indexRecovery,
                    liborCurve):
\end{lstlisting}

\subsection{Class Method {\it calcIndexPayerOptionPrice}}
Calculates the intrinsic value of the index payer swap and thevalue of the index payer option which are both returned in an array. 

\begin{lstlisting}
    def calcIndexPayerOptionPrice(self,
                                  valuationDate,
                                  x,
                                  sigma,
                                  indexCoupon,
                                  strikeValue,
                                  liborCurve,
                                  indexRecovery):
\end{lstlisting}

\newpage
\section{FinCDSIndexPortfolio}

\subsection{Class: FinCDSIndexPortfolio()}
This class manages the calculations associated with an equally weightedportfolio of CDS contracts with the same maturity date. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_businessDateAdjustType}
\item{self.\_frequencyType}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_dateGenRuleType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it intrinsicRPV01}}
Calculation of the risky PV01 of the CDS porfolio by taking theaverage of the risky PV01s of each contract. 

\begin{lstlisting}
    def intrinsicRPV01(self,
                       valuationDate,
                       stepInDate,
                       maturityDate,
                       issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it intrinsicProtectionLegPV}}
Calculation of the intrinsic protection leg value of the CDS porfolioby taking the average sum the protection legs of each contract. 

\begin{lstlisting}
    def intrinsicProtectionLegPV(self,
                                 valuationDate,
                                 stepInDate,
                                 maturityDate,
                                 issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it intrinsicSpread}}
Calculation of the intrinsic spread of the CDS portfolio as the onewhich would make the value of the protection legs equal to the value ofthe premium legs if all premium legs paid the same spread. 

\begin{lstlisting}
    def intrinsicSpread(self,
                        valuationDate,
                        stepInDate,
                        maturityDate,
                        issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it averageSpread}}


\begin{lstlisting}
    def averageSpread(self,
                      valuationDate,
                      stepInDate,
                      maturityDate,
                      issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it totalSpread}}
Calculates the total CDS spread of the CDS portfolio.TODO: DO I NEED THIS ? 

\begin{lstlisting}
    def totalSpread(self,
                    valuationDate,
                    stepInDate,
                    maturityDate,
                    issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it minSpread}}


\begin{lstlisting}
    def minSpread(self,
                  valuationDate,
                  stepInDate,
                  maturityDate,
                  issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it maxSpread}}


\begin{lstlisting}
    def maxSpread(self,
                  valuationDate,
                  stepInDate,
                  maturityDate,
                  issuerCurves):
\end{lstlisting}

\subsection{Class Method {\it spreadAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices.This approach uses an iterative scheme but is slow as it has to use aCDS curve bootstrap required when each trial spread adjustment is made.

\begin{lstlisting}
    def spreadAdjustIntrinsic(valuationDate,
                              issuerCurves,
                              indexCoupons,
                              indexUpfronts,
                              indexMaturityDates,
                              indexRecoveryRate,
                              tolerance):
\end{lstlisting}

\subsection{Class Method {\it hazardRateAdjustIntrinsic}}
Adjust individual CDS curves to reprice CDS index prices.This approach adjusts the hazard rates and so avoids the slowishCDS curve bootstrap required when a spread adjustment is made.

\begin{lstlisting}
    def hazardRateAdjustIntrinsic(valuationDate,
                                  issuerCurves,
                                  indexCoupons,
                                  indexUpfronts,
                                  indexMaturityDates,
                                  indexRecoveryRate,
                                  tolerance,
                                  maxIterations=100):
\end{lstlisting}

\newpage
\section{FinCDSOption}

\subsection{Class: FinCDSOption()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_knockoutFlag}
\item{self.\_businessDateAdjustType}
\item{self.\_strikeCoupon}
\item{self.\_maturityDate}
\item{self.\_longProtection}
\item{self.\_expiryDate}
\item{self.\_notional}
\item{self.\_frequencyType}
\item{self.\_dayCountType}
\item{self.\_calendarType}
\item{self.\_dateGenRuleType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 expiryDate,
                 maturityDate,
                 strikeCoupon,
                 notional=ONE_MILLION,
                 longProtection=True,
                 knockoutFlag=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the CDS option using Blacks model with an adjustment for anyFront End Protection.TODO - Should the CDS be created in the init method ? 

\begin{lstlisting}
    def value(self,
              valuationDate,
              issuerCurve,
              volatility):
\end{lstlisting}

\subsection{Class Method {\it impliedVolatility}}


\begin{lstlisting}
    def impliedVolatility(self,
                          valuationDate,
                          issuerCurve,
                          optionValue):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(volatility, *args):
\end{lstlisting}

\newpage
\section{FinCDSTranche}

\subsubsection{Enumerated Type: FinLossDistributionBuilder}
\begin{itemize}
\item{RECURSION}
\item{ADJUSTED\_BINOMIAL}
\item{GAUSSIAN}
\item{LHP}
\end{itemize}

\subsection{Class: FinCDSTranche(object)}
class FinCDSTranche(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_k1}
\item{self.\_k2}
\item{self.\_stepInDate}
\item{self.\_maturityDate}
\item{self.\_notional}
\item{self.\_longProtection}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_frequencyType}
\item{self.\_dateGenRuleType}
\item{self.\_busDayAdjustType}
\item{self.\_cdsContract}
\item{self.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 stepInDate,
                 maturityDate,
                 k1,
                 k2,
                 notional=ONE_MILLION,
                 coupon=0.0,
                 longProtection=True,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.ACT_360,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it valueBC}}
model=FinLossDistributionBuilder.RECURSION):

\begin{lstlisting}
    def valueBC(self,
                valuationDate,
                issuerCurves,
                upfront,
                coupon,
                corr1,
                corr2,
                numPoints=50,
                model=FinLossDistributionBuilder.RECURSION):
\end{lstlisting}


\chapter{..//products//bonds}
\section{Introduction}
This folder contains a suite of bond-related functionality. It includes a basic fixed coupon bond with all of the associated duration and convexity measures. In addition it includes floating rate bonds and credit risky bonds. There will also be coverage for convertible bonds although this has not been implemented as yet.

\newpage
\section{FinAnnuity}

\subsection{Class: FinAnnuity(object)}
An annuity is a vector of dates and flows generated according to ISDA standard rules which starts on the next date after the start date (effective date) and runs up to an end date. Dates are then adjusted according to a specified calendar. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_dayCountConventionType}
\item{self.\_yearFractions}
\item{self.\_schedule}
\item{self.\_frequencyType}
\item{self.\_calendarType}
\item{self.\_busDayAdjustType}
\item{self.\_endDate}
\item{self.\_flows}
\item{self.\_dateGenRuleType}
\item{self.\_startDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dayCountConventionType=FinDayCountTypes.ACT\_360):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 frequencyType=FinFrequencyTypes.ANNUAL,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD,
                 dayCountConventionType=FinDayCountTypes.ACT_360):
\end{lstlisting}

\subsection{Class Method {\it generate}}
def generate(self, startDate):

\begin{lstlisting}
    def generate(self, startDate):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinBond}

\subsubsection{Enumerated Type: FinYieldConventions}
\begin{itemize}
\item{UK\_DMO}
\item{US\_STREET}
\item{US\_TREASURY}
\end{itemize}

\subsection{Class: FinBond(object)}
Class for fixed coupon bonds and performing related analytics. Theseare bullet bonds which means they have regular coupon payments of a knownsize that are paid on known dates plus a payment of par at maturity.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_accrued}
\item{self.\_frequency}
\item{self.\_ncd}
\item{self.\_flowDates}
\item{self.\_accruedDays}
\item{self.\_pcd}
\item{self.\_face}
\item{self.\_maturityDate}
\item{self.\_frequencyType}
\item{self.\_accrualType}
\item{self.\_alpha}
\item{self.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create FinBond object by providing Maturity Date, Frequency,coupon and the accrual convention type. 

\begin{lstlisting}
    def __init__(self,
                 maturityDate,
                 coupon,
                 frequencyType,
                 accrualType,
                 face=100.0):
\end{lstlisting}

\subsection{Class Method {\it calculateFlowDates}}


\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromYield}}


\begin{lstlisting}
    def fullPriceFromYield(self, settlementDate, y,
                           convention=FinYieldConventions.UK_DMO):
\end{lstlisting}

\subsection{Class Method {\it dollarDuration}}


\begin{lstlisting}
    def dollarDuration(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement dategiven its yield to maturity. 

\begin{lstlisting}
    def macauleyDuration(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it modifiedDuration}}
Calculate the modified duration of the bondon a settlement dategiven its yield to maturity. 

\begin{lstlisting}
    def modifiedDuration(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it convexityFromYield}}


\begin{lstlisting}
    def convexityFromYield(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it cleanPriceFromYield}}


\begin{lstlisting}
    def cleanPriceFromYield(self, settlementDate, ytm):
\end{lstlisting}

\subsection{Class Method {\it cleanPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-valuethe bonds cashflows. 

\begin{lstlisting}
    def cleanPriceFromDiscountCurve(self, settlementDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-valuethe bonds cashflows. 

\begin{lstlisting}
    def fullPriceFromDiscountCurve(self, settlementDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it currentYield}}
Calculate the current yield of the bond which is thecoupon divided by the clean price (not the full price)

\begin{lstlisting}
    def currentYield(self, cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it yieldToMaturity}}
Calculate the bonds yield to maturity by solving the priceyield relationship using a one-dimensional root solver. 

\begin{lstlisting}
    def yieldToMaturity(self, settlementDate, cleanPrice,
                        convention=FinYieldConventions.US_TREASURY):
\end{lstlisting}

\subsection{Class Method {\it \_accruedInterest}}
Calculate the amount of coupon that has accrued between theprevious coupon date and the settlement date. 

\begin{lstlisting}
    def _accruedInterest(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it assetSwapSpread}}
Calculate the par asset swap spread of the bond. The discount curveis a Libor curve that is passed in. The price is the clean price.TODO - Check how first coupon on floating leg is sized. 

\begin{lstlisting}
    def assetSwapSpread(
            self,
            settlementDate,
            cleanPrice,
            discountCurve,
            swapFloatDayCountConventionType=FinDayCountTypes.ACT_360,
            swapFloatFrequencyType=FinFrequencyTypes.SEMI_ANNUAL,
            swapFloatCalendarType=FinCalendarTypes.WEEKEND,
            swapFloatBusDayAdjustRuleType=FinDayAdjustTypes.FOLLOWING,
            swapFloatDateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromOAS}}
Calculate the full price of the bond from its OAS given the bondsettlement date, a discount curve and the oas as a number. 

\begin{lstlisting}
    def fullPriceFromOAS(self,
                         settlementDate,
                         discountCurve,
                         oas):
\end{lstlisting}

\subsection{Class Method {\it optionAdjustedSpread}}
Return OAS for bullet bond given settlement date, clean bond priceand the discount relative to which the spread is to be computed. 

\begin{lstlisting}
    def optionAdjustedSpread(self,
                             settlementDate,
                             cleanPrice,
                             discountCurve):
\end{lstlisting}

\subsection{Class Method {\it printFlows}}
Print a list of the unadjusted coupon payment dates used inanalytic calculations for the bond. 

\begin{lstlisting}
    def printFlows(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it priceFromSurvivalCurve}}
Calculate discounted present value of flows assuming default model.This has not been completed. 

\begin{lstlisting}
    def priceFromSurvivalCurve(self,
                               discountCurve,
                               survivalCurve,
                               recoveryRate):
\end{lstlisting}

\subsection{Class Method {\it print}}
Print a list of the unadjusted coupon payment dates used inanalytic calculations for the bond. 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(y, *args):
\end{lstlisting}

\subsection{Function {\it g}}


\begin{lstlisting}
def g(oas, *args):
\end{lstlisting}

\newpage
\section{FinBondCallable}

\newpage
\section{FinBondFuture}

\subsection{Class: FinBondFuture(object)}
Class for managing futures contracts on government bonds that followsCME conventions and related analytics. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_tickerName}
\item{self.\_lastDeliveryDate}
\item{self.\_coupon}
\item{self.\_contractSize}
\item{self.\_firstDeliveryDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
coupon):

\begin{lstlisting}
    def __init__(self,
                 tickerName,
                 firstDeliveryDate,
                 lastDeliveryDate,
                 contractSize,
                 coupon):
\end{lstlisting}

\subsection{Class Method {\it conversionFactor}}
Determine the conversion factor for a specific bond using CMEconvention. To do this we need to know the contract standard coupon andmust round the bond maturity (starting its life on the first deliverydate) to the nearest 3 month multiple and then calculate the bond cleanprice. 

\begin{lstlisting}
    def conversionFactor(self, bond):
\end{lstlisting}

\subsection{Class Method {\it principalInvoicePrice}}


\begin{lstlisting}
    def principalInvoicePrice(self,
                              bond,
                              futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it totalInvoiceAmount}}
futuresPrice):

\begin{lstlisting}
    def totalInvoiceAmount(self,
                           settlementDate,
                           bond,
                           futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it cheapestToDeliver}}
Determination of CTD as deliverable bond with lowest cost to buyversus what is received when the bond is delivered. 

\begin{lstlisting}
    def cheapestToDeliver(self,
                          bonds,
                          bondCleanPrices,
                          futuresPrice):
\end{lstlisting}

\newpage
\section{FinBondMarket}

\subsubsection{Enumerated Type: FinCountry}
\begin{itemize}
\item{AUSTRIA}
\item{BELGIUM}
\item{FINLAND}
\item{FRANCE}
\item{GERMANY}
\item{IRELAND}
\item{ITALY}
\item{LUXEMBOURG}
\item{NETHERLANDS}
\item{PORTUGAL}
\item{SPAIN}
\item{UNITED\_KINGDOM}
\item{UNITED\_STATES}
\end{itemize}

\subsection{Function {\it getBondMarketConventions}}
Returns the day count convention for accrued interest, the frequencyand the number of days from trade date to settlement date. 

\begin{lstlisting}
def getBondMarketConventions(country):
\end{lstlisting}

\newpage
\section{FinBondOption}

\subsubsection{Enumerated Type: FinBondOptionModel}
\begin{itemize}
\item{HO\_LEE}
\item{HULL\_WHITE}
\end{itemize}

\subsubsection{Enumerated Type: FinBondOptionTypes}
\begin{itemize}
\item{EUROPEAN\_CALL}
\item{EUROPEAN\_PUT}
\end{itemize}

\subsection{Class: FinBondOption()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_expiryDate}
\item{self.\_bond}
\item{self.\_strikePrice}
\item{self.\_bond.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
strikePrice):

\begin{lstlisting}
    def __init__(self,
                 maturityDate,
                 coupon,
                 frequencyType,
                 accrualType,
                 expiryDate,
                 strikePrice):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self,
              valueDate,
              discountCurve,
              modelType,
              modelParams,
              optionType):
\end{lstlisting}

\newpage
\section{FinConvertibleBond}

\subsection{Class: FinConvertibleBond(object)}
Class for convertible bonds. These bonds embed rights to call and putthe bond in return for equity. Until then they are bullet bonds whichmeans they have regular coupon payments of a known size that are paid onknown dates plus a payment of par at maturity. As the options are pricebased, the decision to convert to equity depends on the stock price,the credit quality of the issuer and the level of interest rates.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_frequency}
\item{self.\_ncd}
\item{self.\_conversionRatio}
\item{self.\_face}
\item{self.\_alpha}
\item{self.\_accrualType}
\item{self.\_settlementDate}
\item{self.\_accrued}
\item{self.\_flowDates}
\item{self.\_putDates}
\item{self.\_pcd}
\item{self.\_maturityDate}
\item{self.\_callPrices}
\item{self.\_accruedDays}
\item{self.\_frequencyType}
\item{self.\_callDates}
\item{self.\_putPrices}
\item{self.\_startConvertDate}
\item{self.\_coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create FinBond object by providing Maturity Date, Frequency,coupon and the accrual convention type. 

\begin{lstlisting}
    def __init__(self,
                 maturityDate,  # bond maturity date
                 coupon,  # annual coupon
                 frequencyType,  # coupon frequency type
                 startConvertDate,  # date after which conversion is possible
                 conversionRatio,  # number of shares per face of notional
                 callDates,  # list of call dates
                 callPrices,  # list of call prices
                 putDates,  # list of put dates
                 putPrices,  # list of put prices
                 accrualType,  # day count type for accrued interest
                 face=100.0  # face amount
                 ):
\end{lstlisting}

\subsection{Class Method {\it calculateFlowDates}}


\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it value}}
A binomial tree valuation model for a convertible bond that captures the embedded equity option due to the existence of a conversion option which can be invoked after a specific date.The model allows the user to enter a schedule of dividend payment dates but the size of the payments must be in yield terms i.e. a known percentage of currently unknown future stock price is paid. Not a fixed amount. A fixed yield. Following this payment the stock is assumed to drop by the size of the dividend payment.The model also captures the stock dependent credit risk of the cash flows in which the bond price can default at any time with a hazard rate implied by the credit spread and an associated recovery rate. This is the model proposed by Hull (OFODS 6th edition,.page 522).The model captures both the issuers call schedule which is assumed to apply on a list of dates provided by the user, along with a call price. It also captures the embedded owners put schedule of prices.

\begin{lstlisting}
    def value(self,
              settlementDate,
              stockPrice,
              stockVolatility,
              dividendDates,
              dividendYields,
              discountCurve,
              creditSpread,
              recoveryRate,
              numStepsPerYear):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}


\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it \_accruedInterest}}
Calculate the amount of coupon that has accrued between theprevious coupon date and the settlement date. 

\begin{lstlisting}
    def _accruedInterest(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it currentYield}}
Calculate the current yield of the bond which is thecoupon divided by the clean price (not the full price)

\begin{lstlisting}
    def currentYield(self, cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it print}}
Print a list of the unadjusted coupon payment dates used inanalytic calculations for the bond. 

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsection{Function {\it valueConvertible}}
numStepsPerYear):

\begin{lstlisting}
def valueConvertible(tmat,
                     face,
                     couponTimes,
                     couponAmounts,
                     callTimes,
                     callPrices,
                     putTimes,
                     putPrices,
                     convRatio,
                     startConvertTime,
                     # Market inputs
                     stockPrice,
                     discountTimes,
                     discountFactors,
                     dividendTimes,
                     dividendYields,
                     stockVolatility,
                     creditSpread,
                     recRate,
                     # Tree details
                     numStepsPerYear):
\end{lstlisting}

\newpage
\section{FinFloatingRateNote}

\subsection{Class: FinFloatingRateNote(object)}
Class for managing floating rate notes that pay a floating index plus aquoted margin.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_frequency}
\item{self.\_flowDates}
\item{self.\_face}
\item{self.\_quotedMargin}
\item{self.\_maturityDate}
\item{self.\_frequencyType}
\item{self.\_accrualType}
\item{self.\_redemption}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Create FinFloatingRateNote object. if frequencyType not in FinFrequencyTypes:raise FinError("Invalid Frequency:" + str(frequencyType))returnif accrualType not in FinDayCountTypes:raise FinError("Unknown Bond Accrued Convention type " +str(accrualType))self.\_maturityDate = maturityDateself.\_quotedMargin = quotedMarginself.\_frequencyType = frequencyTypeself.\_accrualType = accrualTypeself.\_flowDates = []self.\_frequency = FinFrequency(frequencyType)self.\_face = faceself.\_redemption = redemptionI do not determine cashflow dates as I do not want to require

\begin{lstlisting}
    def __init__(self,
                 maturityDate,
                 quotedMargin,
                 frequencyType,
                 accrualType,
                 face=100.0,
                 redemption=1.0):
\end{lstlisting}

\subsection{Class Method {\it calculateFlowDates}}


\begin{lstlisting}
    def calculateFlowDates(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountMargin}}
Calculate the full price of the bond from its discount margin and \#making assumptions about the future Libor rates. 

\begin{lstlisting}
    def fullPriceFromDiscountMargin(self,
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm):
\end{lstlisting}

\subsection{Class Method {\it dollarDuration}}


\begin{lstlisting}
    def dollarDuration(self,
                       settlementDate,
                       nextCoupon,
                       futureLibor,
                       dm):
\end{lstlisting}

\subsection{Class Method {\it macauleyDuration}}
Calculate the Macauley duration of the bond on a settlement dategiven its yield to maturity. 

\begin{lstlisting}
    def macauleyDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm):
\end{lstlisting}

\subsection{Class Method {\it modifiedDuration}}
Calculate the modified duration of the bondon a settlement dategiven its yield to maturity. 

\begin{lstlisting}
    def modifiedDuration(self,
                         settlementDate,
                         nextCoupon,
                         futureLibor,
                         dm):
\end{lstlisting}

\subsection{Class Method {\it convexityFromDiscountMargin}}


\begin{lstlisting}
    def convexityFromDiscountMargin(self,
                                    settlementDate,
                                    nextCoupon,
                                    futureLibor,
                                    dm):
\end{lstlisting}

\subsection{Class Method {\it cleanPriceFromDiscountMargin}}


\begin{lstlisting}
    def cleanPriceFromDiscountMargin(self,
                                     settlementDate,
                                     nextCoupon,
                                     futureLibor,
                                     dm):
\end{lstlisting}

\subsection{Class Method {\it fullPriceFromDiscountCurve}}
Calculate the bond price using some discount curve to present-valuethe bonds cashflows. THIS IS NOT COMPLETE. 

\begin{lstlisting}
    def fullPriceFromDiscountCurve(self,
                                   settlementDate,
                                   indexCurve,
                                   discountCurve):
\end{lstlisting}

\subsection{Class Method {\it discountMargin}}
Calculate the bonds yield to maturity by solving the priceyield relationship using a one-dimensional root solver. 

\begin{lstlisting}
    def discountMargin(self,
                       settlementDate,
                       nextCoupon,
                       futureLibor,
                       cleanPrice):
\end{lstlisting}

\subsection{Class Method {\it accruedDays}}


\begin{lstlisting}
    def accruedDays(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it pcd}}


\begin{lstlisting}
    def pcd(self, settlementDate):
\end{lstlisting}

\subsection{Class Method {\it accruedInterest}}
Calculate the amount of coupon that has accrued between theprevious coupon date and the settlement date. 

\begin{lstlisting}
    def accruedInterest(self,
                        settlementDate,
                        nextCoupon):
\end{lstlisting}

\subsection{Function {\it f}}


\begin{lstlisting}
def f(dm, *args):
\end{lstlisting}


\chapter{..//products//libor}
\section{Introduction}
This folder contains a set of Libor-related products. It includes:
- Libor deposits
- Interest rate futures
- Overnight index swaps (OIS)
- Forward Rate Agreements (FRAs)
- Interest Rate swaps
- Caps and Floors on Libor
- Swaptions

\newpage
\section{FinInterestRateFuture}

\subsection{Class: FinInterestRateFuture(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_lastSettlementDate}
\item{self.\_lastTradingDate}
\item{self.\_contractSize}
\item{self.\_dayCountType}
\item{self.\_endOfInterestRatePeriod}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 lastTradingDate,
                 dayCountType,
                 contractSize):
\end{lstlisting}

\subsection{Class Method {\it futuresRate}}


\begin{lstlisting}
    def futuresRate(self,
                    settlementDate,
                    futuresPrice):
\end{lstlisting}

\subsection{Class Method {\it convexity}}
Calculation of the convexity adjustment between FRAs and interestrate futures using the Hull-White model as described in technical note. 

\begin{lstlisting}
    def convexity(self,
                  settlementDate,
                  volatility,
                  a):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborCapFloor}

\subsubsection{Enumerated Type: FinLiborCapFloorType}
\begin{itemize}
\item{CAP}
\item{FLOOR}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborCapFloorModelTypes}
\begin{itemize}
\item{BLACK}
\item{SHIFTED\_BLACK}
\item{SABR}
\end{itemize}

\subsection{Class: FinLiborCapFloor()}
class FinLiborCapFloor():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_capFloorDates}
\item{self.\_optionType}
\item{self.\_lastFixing}
\item{self.\_maturityDate}
\item{self.\_frequencyType}
\item{self.\_notional}
\item{self.\_calendarType}
\item{self.\_dayCountType}
\item{self.\_busDayAdjustType}
\item{self.\_dateGenRuleType}
\item{self.\_startDate}
\item{self.\_strikeRate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 optionType,
                 strikeRate,
                 lastFixing=None,
                 frequencyType=FinFrequencyTypes.QUARTERLY,
                 dayCountType=FinDayCountTypes.THIRTY_E_360_ISDA,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(self,
              valuationDate,
              liborCurve,
              model):
\end{lstlisting}

\subsection{Class Method {\it valueCapletFloorlet}}
model):

\begin{lstlisting}
    def valueCapletFloorlet(self,
                            valuationDate,
                            startDate,
                            endDate,
                            liborCurve,
                            model):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborDeposit}

\subsection{Class: FinLiborDeposit(object)}
class FinLiborDeposit(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_depositRate}
\item{self.\_notional}
\item{self.\_calendarType}
\item{self.\_maturityDate}
\item{self.\_dayCountType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 settlementDate,
                 maturityDateOrTenor,
                 depositRate,
                 dayCountType,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsection{Class Method {\it maturityDf}}
Returns the maturity date discount factor that would allow theLibor curve to reprice the contractual market deposit rate. Note thatthis is a forward discount factor that starts on settlement date.

\begin{lstlisting}
    def maturityDf(self):
\end{lstlisting}

\subsection{Class Method {\it value}}


\begin{lstlisting}
    def value(self, valueDate, liborCurve):
\end{lstlisting}

\subsection{Class Method {\it print}}


\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborFRA}

\subsection{Class: FinLiborFRA(object)}
Class for managing LIBOR forward rate agreements. A forward rateagreement is an agreement to exchange a fixed pre-agreed rate for afloating rate linked to LIBOR that is not known until some specifiedfuture fixing date. The FRA payment occurs on or soon after this dateon the FRA settlement date. Typically the timing gap is two days.A FRA is used to hedge a Libor quality loan or lend of some agreednotional amount. This period starts on the settlement date of theFRA and ends on the maturity date of the FRA. For example a 1x4 FRArelates to a Libor starting in 1 month for a loan period ending in 4months. Hence it linkes to 3-month Libor rate.The amount received by a payer of fixed rate at settlement isacc(1,2) * (Libor(1,2) - FRA RATE) / (1 + acc(0,1) x Libor(0,1))So the value at time 0 isacc(1,2) * (FWD Libor(1,2) - FRA RATE) x df(0,2)If the base date of the curve is before the value date then weforward adjust this amount to that value date.For simplicity I have assumed that the fixing date and the settlementdate are the same date. This should be amended later. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_payFixedRate}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_notional}
\item{self.\_dayCountType}
\item{self.\_fraRate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 settlementDate,  # The date on which the floating rate fixes
                 maturityDateOrTenor,  # The end of the Libor rate period
                 fraRate,  # The fixed contractual FRA rate
                 payFixedRate,  # True if the FRA rate is being paid
                 dayCountType,  # For interest period
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.MODIFIED_FOLLOWING):
\end{lstlisting}

\subsection{Class Method {\it value}}
Determine mark to market value of a FRA contract based on themarket FRA rate. The same curve is used for calculating the forwardLibor and for doing discounting on the expected forward payment. 

\begin{lstlisting}
    def value(self, valueDate, liborCurve):
\end{lstlisting}

\subsection{Class Method {\it maturityDf}}
Determine the maturity date discount factor needed to refitthe FRA given the libor curve anbd the contract FRA rate. 

\begin{lstlisting}
    def maturityDf(self, liborCurve):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinLiborModelTypes}

\subsection{Class: FinLiborModel(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class: FinLiborModelBlack(FinLiborModel)}
class FinLiborModelBlack(FinLiborModel):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, volatility):

\begin{lstlisting}
    def __init__(self, volatility):
\end{lstlisting}

\subsection{Class: FinLiborModelShiftedBlack(FinLiborModel)}
class FinLiborModelShiftedBlack(FinLiborModel):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_volatility}
\item{self.\_implementation}
\item{self.\_shift}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, volatility, shift):

\begin{lstlisting}
    def __init__(self, volatility, shift):
\end{lstlisting}

\subsection{Class: FinLiborModelSABR(FinLiborModel)}
class FinLiborModelSABR(FinLiborModel):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_nu}
\item{self.\_parentType}
\item{self.\_rho}
\item{self.\_alpha}
\item{self.\_beta}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, alpha, beta, rho, nu):

\begin{lstlisting}
    def __init__(self, alpha, beta, rho, nu):
\end{lstlisting}

\newpage
\section{FinLiborProducts}

\subsection{Class: FinLiborSwap(object)}
class FinLiborSwap(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.payFixedLeg}
\item{self.fixedLeg}
\item{self.floatLeg}
\item{self.payFixedFlag}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule="BACKWARD"):

\begin{lstlisting}
    def __init__(self, startDate, endDate,
                 fixedCoupon, fixedFreq, fixedBasis,
                 floatSpread, floatFreq, floatBasis,
                 firstFixing=None,
                 payFixedFlag=True,
                 calendarName="WEEKEND",
                 businessDateAdjust="FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve, indexCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection{Class: FinLiborSwapFixedLeg(object)}
class FinLiborSwapFixedLeg(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.freq}
\item{self.basis}
\item{self.maturityDate}
\item{self.flows[numFlows-1].amount+}
\item{self.flows}
\item{self.schedule}
\item{self.startDate}
\item{self.coupon}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule="BACKWARD"):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 coupon,
                 freq,
                 basis,
                 calendarName="WEEKEND",
                 businessDateAdjust="MODIFIED_FOLLOWING",
                 dateGenRule="BACKWARD"):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it generateFlows}}
def generateFlows(self, fixedBasis):

\begin{lstlisting}
    def generateFlows(self, fixedBasis):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\subsection{Class: FinLiborSwapFloatLeg(object)}
class FinLiborSwapFloatLeg(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.freq}
\item{self.basis}
\item{self.flows[numFlows-1].amount+}
\item{self.flows}
\item{self.floatSpread}
\item{self.schedule}
\item{self.endDate}
\item{self.startDate}
\item{self.firstFixing}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRule):

\begin{lstlisting}
    def __init__(self,
                 startDate,
                 endDate,
                 floatSpread,
                 floatFreq,
                 floatBasis,
                 firstFixing,
                 calendarName,
                 businessDateAdjust,
                 dateGenRule):
\end{lstlisting}

\subsection{Class Method {\it value}}
def value(self, valueDate, discountCurve, indexCurve):

\begin{lstlisting}
    def value(self, valueDate, discountCurve, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it generateFlows}}
def generateFlows(self, indexCurve):

\begin{lstlisting}
    def generateFlows(self, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it dump}}
def dump(self):

\begin{lstlisting}
    def dump(self):
\end{lstlisting}

\newpage
\section{FinLiborSwap}

\subsection{Class: FinLiborSwap(object)}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_floatFlowPVs[-1]+}
\item{self.\_adjustedFloatDates}
\item{self.\_fixedFlowPVs[-1]+}
\item{self.\_floatYearFracs}
\item{self.\_payFixedLeg}
\item{self.\_fixedDayCountType}
\item{self.\_fixedYearFracs}
\item{self.\_floatFrequencyType}
\item{self.\_floatDfs}
\item{self.\_notional}
\item{self.\_calendarType}
\item{self.\_fixedStartIndex}
\item{self.\_floatFlows[-1]+}
\item{self.\_payFixedFlag}
\item{self.\_floatSpread}
\item{self.\_fixedFlowPVs}
\item{self.\_maturityDate}
\item{self.\_busDayAdjustType}
\item{self.\_floatStartIndex}
\item{self.\_startDate}
\item{self.\_floatFlowPVs}
\item{self.\_fixedFlows}
\item{self.\_fixedDfs}
\item{self.\_fixedCoupon}
\item{self.\_floatDayCountType}
\item{self.\_adjustedFixedDates}
\item{self.\_fixedFlows[-1]+}
\item{self.\_fixedFrequencyType}
\item{self.\_floatFlows}
\item{self.\_dateGenRuleType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDateOrTenor,
                 fixedCoupon,
                 fixedFreqType,
                 fixedDayCountType,
                 notional=ONE_MILLION,
                 floatSpread=0.0,
                 floatFreqType=FinFrequencyTypes.QUARTERLY,
                 floatDayCountType=FinDayCountTypes.THIRTY_360,
                 payFixedFlag=True,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the interest rate swap on a value date given a single Libordiscount curve. 

\begin{lstlisting}
    def value(self,
              valuationDate,
              discountCurve,
              indexCurve,
              firstFixingRate,
              principal=0.0):
\end{lstlisting}

\subsection{Class Method {\it generateFixedLegPaymentDates}}
Generate the fixed leg payment dates all the way back tothe start date of the swap which may precede the valuation date

\begin{lstlisting}
    def generateFixedLegPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it generateFloatLegPaymentDates}}
Generate the floating leg payment dates all the way back tothe start date of the swap which may precede the valuation date

\begin{lstlisting}
    def generateFloatLegPaymentDates(self):
\end{lstlisting}

\subsection{Class Method {\it pv01}}


\begin{lstlisting}
    def pv01(self, valuationDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it parCoupon}}
Calculate the fixed leg coupon that makes the swap worth zero. If the valuation date is before the swap payments start then this is the forward swap rate as it starts in the future. The swap rate is then a forward swap rate and so we use a forward discount factor. If the swap fixed leg has begun then we have a spot starting swap. 

\begin{lstlisting}
    def parCoupon(self, valuationDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it fixedLegValue}}
The swap may have started in the past but we can only valuepayments that have occurred after the valuation date. 

\begin{lstlisting}
    def fixedLegValue(self, valuationDate, discountCurve, principal=0.0):
\end{lstlisting}

\subsection{Class Method {\it floatLegValue}}
Value the floating leg with payments from an index curve anddiscounting based on a supplied discount curve. 

\begin{lstlisting}
    def floatLegValue(self,
                      valuationDate,
                      discountCurve,
                      indexCurve,
                      firstFixingRate=None,
                      principal=0.0):
\end{lstlisting}

\subsection{Class Method {\it printFixedLeg}}


\begin{lstlisting}
    def printFixedLeg(self, valuationDate):
\end{lstlisting}

\subsection{Class Method {\it printFloatLeg}}


\begin{lstlisting}
    def printFloatLeg(self, valuationDate):
\end{lstlisting}

\newpage
\section{FinLiborSwaption}

\subsubsection{Enumerated Type: FinLiborSwaptionType}
\begin{itemize}
\item{PAYER}
\item{RECEIVER}
\end{itemize}

\subsubsection{Enumerated Type: FinLiborSwaptionModelTypes}
\begin{itemize}
\item{BLACK}
\item{SABR}
\end{itemize}

\subsection{Class: FinLiborSwaption()}
class FinLiborSwaption():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_swapFixedDayCountType}
\item{self.\_forwardDf}
\item{self.\_pv01}
\item{self.\_swapFixedCoupon}
\item{self.\_fwdSwapRate}
\item{self.\_swapNotional}
\item{self.\_maturityDate}
\item{self.\_calendarType}
\item{self.\_swaptionType}
\item{self.\_busDayAdjustType}
\item{self.\_dateGenRuleType}
\item{self.\_exerciseDate}
\item{self.\_swapFixedFrequencyType}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
dateGenRuleType=FinDateGenRuleTypes.BACKWARD):

\begin{lstlisting}
    def __init__(self,
                 exerciseDate,
                 swapMaturityDate,
                 swaptionType,
                 swapFixedCoupon,
                 swapFixedFrequencyType,
                 swapFixedDayCountType,
                 swapNotional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it value}}
model):

\begin{lstlisting}
    def value(self,
              valuationDate,
              liborCurve,
              model):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinOIS}

\subsection{Class: FinOIS(object)}
Class for managing overnight index swaps. This is a swap contract inwhich a fixed payment leg is exchanged for a floating coupon leg. Thereis no exchange of par.The contract lasts from a start date to a specified maturity date. The fixed coupon isthe OIS fixed rate which is set at contract initiation.The floating rate is not known until the end of each payment period. It iscalculated at the end of the period as it is based on daily observationsof the overnight index rate which are compounded according to a specificconvention. Hence the OIS floating rate is determined by the history of theOIS rates.In its simplest form, there is just one fixed rate payment and one floatingrate payment at contract maturity. However when the contract becomes longerthan one year the floating and fixed payments become periodic.The value of the contract is the NPV of the two coupon streams.Discounting is done on a supplied OIS curve which is itself implied bythe term structure of market OIS rates. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_fixedFlows}
\item{self.\_payFixedLeg}
\item{self.\_fixedDayCountType}
\item{self.\_floatDayCountType}
\item{self.\_adjustedFixedDates}
\item{self.\_floatFrequencyType}
\item{self.\_fixedFrequencyType}
\item{self.\_floatFlows}
\item{self.\_maturityDate}
\item{self.\_notional}
\item{self.\_calendarType}
\item{self.\_busDayAdjustType}
\item{self.\_adjustedFloatDates}
\item{self.\_startDate}
\item{self.\_dateGenRuleType}
\item{self.\_fixedRate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self,
                 startDate,
                 maturityDate,
                 fixedRate,
                 fixedFrequencyType,
                 fixedDayCountType,
                 floatFrequencyType=FinFrequencyTypes.ANNUAL,
                 floatDayCountType=FinDayCountTypes.ACT_360,
                 payFixedLeg=True,
                 notional=ONE_MILLION,
                 calendarType=FinCalendarTypes.WEEKEND,
                 busDayAdjustType=FinDayAdjustTypes.FOLLOWING,
                 dateGenRuleType=FinDateGenRuleTypes.BACKWARD):
\end{lstlisting}

\subsection{Class Method {\it generatePaymentDates}}
def generatePaymentDates(self, valueDate):

\begin{lstlisting}
    def generatePaymentDates(self, valueDate):
\end{lstlisting}

\subsection{Class Method {\it generateFixedLegFlows}}
def generateFixedLegFlows(self, valueDate):

\begin{lstlisting}
    def generateFixedLegFlows(self, valueDate):
\end{lstlisting}

\subsection{Class Method {\it generateFloatLegFlows}}


\begin{lstlisting}
    def generateFloatLegFlows(self, valueDate, indexCurve):
\end{lstlisting}

\subsection{Class Method {\it rate}}


\begin{lstlisting}
    def rate(self, oisDates, oisFixings):
\end{lstlisting}

\subsection{Class Method {\it value}}
Value the interest rate swap on a value date given a single Libordiscount curve. 

\begin{lstlisting}
    def value(self, valueDate, discountCurve):
\end{lstlisting}

\subsection{Class Method {\it fixedLegValue}}
def fixedLegValue(self, valueDate, discountCurve, principal=0.0):

\begin{lstlisting}
    def fixedLegValue(self, valueDate, discountCurve, principal=0.0):
\end{lstlisting}

\subsection{Class Method {\it floatLegValue}}
Value the floating leg with payments from an index curve anddiscounting based on a supplied discount curve. 

\begin{lstlisting}
    def floatLegValue(self,
                      valueDate,
                      discountCurve,
                      indexCurve,
                      principal=0.0):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self,
           oisRate,
           startDate,
           endDate):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self, valueDate, indexCurve):

\begin{lstlisting}
    def print(self, valueDate, indexCurve):
\end{lstlisting}


\chapter{..//products//fx}
\section{Introduction}
This is where FX derivatives will be found.

\chapter{..//models}
\section{Introduction}
This folder contains a range of models used in the various derivative prices implemented. These include credit models for valuing portfolio credit products such as CDS Tranches, Monte-Carlo based models of stochastics processes used to value equity, FX and interest rate derivatives, and some generic implementations of models such as a tree based Hull White model. Because the models are useful across a range of products, it is better to factor them out of the product/asset class categorisation as it avoids any unnecessary duplication.

\newpage
\section{FinCIRRateModel}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection{Class: FinCIRRateModel()}
class FinCIRRateModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_b}
\item{self.\_sigma}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, a, b, sigma):

\begin{lstlisting}
    def __init__(self, a, b, sigma):
\end{lstlisting}

\subsection{Function {\it meanr}}


\begin{lstlisting}
def meanr(r0, a, b, t):
\end{lstlisting}

\subsection{Function {\it variancer}}


\begin{lstlisting}
def variancer(r0, a, b, sigma, t):
\end{lstlisting}

\subsection{Function {\it zeroPrice}}


\begin{lstlisting}
def zeroPrice(r0, a, b, sigma, t):
\end{lstlisting}

\subsection{Function {\it draw}}


\begin{lstlisting}
def draw(rt, a, b, sigma, dt):
\end{lstlisting}

\subsection{Function {\it ratePath\_MC}}


\begin{lstlisting}
def ratePath_MC(r0, a, b, sigma, t, dt, seed, scheme):
\end{lstlisting}

\subsection{Function {\it zeroPrice\_MC}}


\begin{lstlisting}
def zeroPrice_MC(r0, a, b, sigma, t, dt, numPaths, seed, scheme):
\end{lstlisting}

\newpage
\section{FinGaussianCopula1FModel}

\subsection{Function {\it lossDbnRecursionGCD}}
Full construction of the loss distribution of a portfolio of creditswhere losses have been calculate as number of units based on the GCD. 

\begin{lstlisting}
def lossDbnRecursionGCD(numCredits,
                        defaultProbs,
                        lossUnits,
                        betaVector,
                        numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it homogeneousBasketLossDbn}}
Calculate the loss distribution of a CDS default basket where theportfolio is equally weighted and the losses in the portfolio are homo-geneous i.e. the credits have the same recovery rates. 

\begin{lstlisting}
def homogeneousBasketLossDbn(survivalProbabilities,
                             recoveryRates,
                             betaVector,
                             numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it trSurvProbRecursion}}
Get the tranche survival probability of a portfolio of credits in theone-factor GC model using a full recursion calculation of the lossdistribution and survival probabilities to some time horizon. 

\begin{lstlisting}
def trSurvProbRecursion(k1,
                        k2,
                        numCredits,
                        survivalProbabilities,
                        recoveryRates,
                        betaVector,
                        numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it gaussApproxTrancheLoss}}
def gaussApproxTrancheLoss(k1, k2, mu, sigma):

\begin{lstlisting}
def gaussApproxTrancheLoss(k1, k2, mu, sigma):
\end{lstlisting}

\subsection{Function {\it trSurvProbGaussian}}
Get the approximated tranche survival probability of a portfolioof credits in the one-factor GC model using a Gaussian fit of theconditional loss distribution and survival probabilities to some timehorizon. Note that the losses in this fit are allowed to be negative. 

\begin{lstlisting}
def trSurvProbGaussian(k1,
                       k2,
                       numCredits,
                       survivalProbabilities,
                       recoveryRates,
                       betaVector,
                       numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it lossDbnHeterogeneousAdjBinomial}}
Get the portfolio loss distribution using the adjusted binomialapproximation to the conditional loss distribution. 

\begin{lstlisting}
def lossDbnHeterogeneousAdjBinomial(numCredits,
                                    defaultProbs,
                                    lossRatio,
                                    betaVector,
                                    numIntegrationSteps):
\end{lstlisting}

\subsection{Function {\it trSurvProbAdjBinomial}}
Get the approximated tranche survival probability of a portfolio ofcredits in the one-factor GC model using the adjusted binomial fit of theconditional loss distribution and survival probabilities to some timehorizon. This approach is both fast and highly accurate. 

\begin{lstlisting}
def trSurvProbAdjBinomial(k1,
                          k2,
                          numCredits,
                          survivalProbabilities,
                          recoveryRates,
                          betaVector,
                          numIntegrationSteps):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaLHPModel}

\subsection{Function {\it trSurvProbLHP}}
Get the approximated tranche survival probability of a portfolio ofcredits in the one-factor GC model using the large portfolio limit whichassumes a homogenous portfolio with an infinite number of credits. Thisapproach is very fast but not so as accurate as the adjusted binomial. 

\begin{lstlisting}
def trSurvProbLHP(k1,
                  k2,
                  numCredits,
                  survivalProbabilities,
                  recoveryRates,
                  beta):
\end{lstlisting}

\subsection{Function {\it portfolioCDF\_LHP}}
def portfolioCDF\_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints):

\begin{lstlisting}
def portfolioCDF_LHP(k, numCredits, qvector, recoveryRates, beta, numPoints):
\end{lstlisting}

\subsection{Function {\it expMinLK}}
def expMinLK(k, p, r, n, beta):

\begin{lstlisting}
def expMinLK(k, p, r, n, beta):
\end{lstlisting}

\subsection{Function {\it LHPDensity}}
def LHPDensity(k, p, r, beta):

\begin{lstlisting}
def LHPDensity(k, p, r, beta):
\end{lstlisting}

\subsection{Function {\it LHPAnalyticalDensityBaseCorr}}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta\_dk):

\begin{lstlisting}
def LHPAnalyticalDensityBaseCorr(k, p, r, beta, dbeta_dk):
\end{lstlisting}

\subsection{Function {\it LHPAnalyticalDensity}}
def LHPAnalyticalDensity(k, p, r, beta):

\begin{lstlisting}
def LHPAnalyticalDensity(k, p, r, beta):
\end{lstlisting}

\subsection{Function {\it ExpMinLK}}
def ExpMinLK(k, p, r, n, beta):

\begin{lstlisting}
def ExpMinLK(k, p, r, n, beta):
\end{lstlisting}

\subsection{Function {\it probLGreaterThanK}}
def probLGreaterThanK(K, P, R, beta):

\begin{lstlisting}
def probLGreaterThanK(K, P, R, beta):
\end{lstlisting}

\newpage
\section{FinGaussianCopulaModel}

\subsection{Function {\it defaultTimesGC}}
seed):

\begin{lstlisting}
def defaultTimesGC(issuerCurves,
                   correlationMatrix,
                   numTrials,
                   seed):
\end{lstlisting}

\newpage
\section{FinGBMProcess}

\subsection{Class: FinGBMProcess()}
class FinGBMProcess():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it getPaths}}
seed):

\begin{lstlisting}
    def getPaths(
            self,
            numPaths,
            numTimeSteps,
            t,
            mu,
            stockPrice,
            volatility,
            seed):
\end{lstlisting}

\subsection{Class Method {\it getPathsAssets}}
t, mus, stockPrices, volatilities, betas, seed):

\begin{lstlisting}
    def getPathsAssets(self, numAssets, numPaths, numTimeSteps,
                       t, mus, stockPrices, volatilities, betas, seed):
\end{lstlisting}

\subsection{Function {\it getPaths}}
seed):

\begin{lstlisting}
def getPaths(numPaths,
             numTimeSteps,
             t,
             mu,
             stockPrice,
             volatility,
             seed):
\end{lstlisting}

\subsection{Function {\it getPathsAssets}}
seed):

\begin{lstlisting}
def getPathsAssets(numAssets,
                   numPaths,
                   numTimeSteps,
                   t,
                   mus,
                   stockPrices,
                   volatilities,
                   betas,
                   seed):
\end{lstlisting}

\subsection{Function {\it getAssets}}
seed):

\begin{lstlisting}
def getAssets(numAssets,
              numPaths,
              t,
              mus,
              stockPrices,
              volatilities,
              betas,
              seed):
\end{lstlisting}

\newpage
\section{FinHestonModel}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection{Class: FinHestonModel()}
class FinHestonModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_v0}
\item{self.\_sigma}
\item{self.\_rho}
\item{self.\_theta}
\item{self.\_kappa}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, v0, kappa, theta, sigma, rho):

\begin{lstlisting}
    def __init__(self, v0, kappa, theta, sigma, rho):
\end{lstlisting}

\subsection{Class Method {\it value\_MC}}
scheme=FinHestonNumericalScheme.EULERLOG):

\begin{lstlisting}
    def value_MC(self,
                 valueDate,
                 option,
                 stockPrice,
                 interestRate,
                 dividendYield,
                 numPaths,
                 numStepsPerYear,
                 seed,
                 scheme=FinHestonNumericalScheme.EULERLOG):
\end{lstlisting}

\subsection{Class Method {\it value\_Lewis}}
dividendYield):

\begin{lstlisting}
    def value_Lewis(self,
                    valueDate,
                    option,
                    stockPrice,
                    interestRate,
                    dividendYield):
\end{lstlisting}

\subsection{Class Method {\it phi}}
def phi(k\_in,):

\begin{lstlisting}
        def phi(k_in,):
\end{lstlisting}

\subsection{Class Method {\it phi\_transform}}
def phi\_transform(x):

\begin{lstlisting}
        def phi_transform(x):
\end{lstlisting}

\subsection{Class Method {\it integrand}}
def integrand(k): return 2.0 * np.real(np.exp(-1j * \

\begin{lstlisting}
            def integrand(k): return 2.0 * np.real(np.exp(-1j * \
\end{lstlisting}

\subsection{Class Method {\it value\_Lewis\_Rouah}}
dividendYield):

\begin{lstlisting}
    def value_Lewis_Rouah(self,
                          valueDate,
                          option,
                          stockPrice,
                          interestRate,
                          dividendYield):
\end{lstlisting}

\subsection{Class Method {\it f}}
def f(k\_in):

\begin{lstlisting}
        def f(k_in):
\end{lstlisting}

\subsection{Class Method {\it value\_Weber}}
dividendYield):

\begin{lstlisting}
    def value_Weber(self,
                    valueDate,
                    option,
                    stockPrice,
                    interestRate,
                    dividendYield):
\end{lstlisting}

\subsection{Class Method {\it F}}
def F(s, b):

\begin{lstlisting}
        def F(s, b):
\end{lstlisting}

\subsection{Class Method {\it integrand}}
def integrand(u):

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsection{Class Method {\it value\_Gatheral}}
dividendYield):

\begin{lstlisting}
    def value_Gatheral(self,
                       valueDate,
                       option,
                       stockPrice,
                       interestRate,
                       dividendYield):
\end{lstlisting}

\subsection{Class Method {\it F}}
def F(j):

\begin{lstlisting}
        def F(j):
\end{lstlisting}

\subsection{Class Method {\it integrand}}
def integrand(u):

\begin{lstlisting}
            def integrand(u):
\end{lstlisting}

\subsection{Function {\it getPaths}}
scheme):

\begin{lstlisting}
def getPaths(
        s0,
        r,
        q,
        v0,
        kappa,
        theta,
        sigma,
        rho,
        t,
        dt,
        numPaths,
        seed,
        scheme):
\end{lstlisting}

\newpage
\section{FinHestonProcess}

\subsubsection{Enumerated Type: FinHestonScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsection{Class: FinHestonProcess(FinProcess)}
class FinHestonProcess(FinProcess):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_numTimeSteps}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it getPathsAssets}}
fast = FinFastNumericalApproach.NUMBA):

\begin{lstlisting}
    def getPathsAssets(self, 
                 t,
                 mus,
                 stockPrices,
                 volatilities,
                 betas,
                 seed, 
                 fast = FinFastNumericalApproach.NUMBA):
\end{lstlisting}

\subsection{Function {\it getPaths}}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):

\begin{lstlisting}
def getPaths(s0,r,q,v0,kappa,theta,sigma,rho,t,dt,numPaths,seed,scheme):
\end{lstlisting}

\newpage
\section{FinHoLeeRateModel}

\subsection{Class: FinHoLeeModel()}
class FinHoLeeModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_discountCurve}
\item{self.\_sigma}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, discountCurve, sigma):

\begin{lstlisting}
    def __init__(self, discountCurve, sigma):
\end{lstlisting}

\subsection{Class Method {\it P}}
t2):  \# forward maturity t2

\begin{lstlisting}
    def P(self,
          r1,  # short rate at time t1
          t1,  # foward start time t1
          t2):  # forward maturity t2
\end{lstlisting}

\newpage
\section{FinHullWhiteRateModel}

\subsection{Class: FinHullWhiteTree()}
class FinHullWhiteTree():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_discountCurve}
\item{self.\_a}
\item{self.\_sigma}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
sigma):

\begin{lstlisting}
    def __init__(self,
                 discountCurve,
                 a,
                 sigma):
\end{lstlisting}

\subsection{Class: FinHullWhiteRateModel()}
class FinHullWhiteRateModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_discountCurve}
\item{self.\_a}
\item{self.\_sigma}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, discountCurve,
                 a,
                 sigma):
\end{lstlisting}

\subsection{Class Method {\it P}}


\begin{lstlisting}
    def P(self,
          r1,  # short rate at time t1
          t1,  # forward start time t1
          t2):  # forward maturity t2
\end{lstlisting}

\newpage
\section{FinLHPlusModel}

\subsection{Class: LHPlusModel()}
class LHPlusModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_H0}
\item{self.\_P}
\item{self.\_P0}
\item{self.\_R0}
\item{self.\_R}
\item{self.\_beta}
\item{self.\_H}
\item{self.\_beta0}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, P, R, H, beta, P0, R0, H0, beta0):

\begin{lstlisting}
    def __init__(self, P, R, H, beta, P0, R0, H0, beta0):
\end{lstlisting}

\subsection{Class Method {\it probLossGreaterThanK}}
def probLossGreaterThanK(self, K):

\begin{lstlisting}
    def probLossGreaterThanK(self, K):
\end{lstlisting}

\subsection{Class Method {\it expMinLKIntegral}}
def expMinLKIntegral(self, K, dK):

\begin{lstlisting}
    def expMinLKIntegral(self, K, dK):
\end{lstlisting}

\subsection{Class Method {\it expMinLK}}
def expMinLK(self, K):

\begin{lstlisting}
    def expMinLK(self, K):
\end{lstlisting}

\subsection{Class Method {\it expMinLK2}}
def expMinLK2(self, K):

\begin{lstlisting}
    def expMinLK2(self, K):
\end{lstlisting}

\subsection{Class Method {\it trancheSurvivalProbability}}
def trancheSurvivalProbability(self, k1, k2):

\begin{lstlisting}
    def trancheSurvivalProbability(self, k1, k2):
\end{lstlisting}

\newpage
\section{FinLossDbnBuilder}

\subsection{Function {\it indepLossDbnHeterogeneousAdjBinomial}}
lossRatio):

\begin{lstlisting}
def indepLossDbnHeterogeneousAdjBinomial(numCredits,
                                         condDefaultProbs,
                                         lossRatio):
\end{lstlisting}

\subsection{Function {\it portfolioGCD}}
def portfolioGCD(actualLosses):

\begin{lstlisting}
def portfolioGCD(actualLosses):
\end{lstlisting}

\subsection{Function {\it indepLossDbnRecursionGCD}}
lossUnits):

\begin{lstlisting}
def indepLossDbnRecursionGCD(numCredits,
                             condDefaultProbs,
                             lossUnits):
\end{lstlisting}

\newpage
\section{FinMertonCreditModel}

\subsection{Function {\it mertonCreditModelValues}}
volatility):

\begin{lstlisting}
def mertonCreditModelValues(assetValue,
                            bondFace,
                            timeToMaturity,
                            riskFreeRate,
                            assetGrowthRate,
                            volatility):
\end{lstlisting}

\newpage
\section{FinProcessSimulator}

\subsubsection{Enumerated Type: FinProcessTypes}
\begin{itemize}
\item{GBM}
\item{CIR}
\item{HESTON}
\item{VASICEK}
\item{CEV}
\item{JUMP\_DIFFUSION}
\end{itemize}

\subsubsection{Enumerated Type: FinHestonNumericalScheme}
\begin{itemize}
\item{EULER}
\item{EULERLOG}
\item{QUADEXP}
\end{itemize}

\subsubsection{Enumerated Type: FinGBMNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinVasicekNumericalScheme}
\begin{itemize}
\item{NORMAL}
\item{ANTITHETIC}
\end{itemize}

\subsubsection{Enumerated Type: FinCIRNumericalScheme}
\begin{itemize}
\item{EULER}
\item{LOGNORMAL}
\item{MILSTEIN}
\item{KAHLJACKEL}
\item{EXACT}
\end{itemize}

\subsection{Class: FinProcessSimulator()}
class FinProcessSimulator():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self):

\begin{lstlisting}
    def __init__(self):
\end{lstlisting}

\subsection{Class Method {\it getProcess}}
seed):

\begin{lstlisting}
    def getProcess(
            self,
            processType,
            t,
            modelParams,
            numAnnSteps,
            numPaths,
            seed):
\end{lstlisting}

\subsection{Function {\it getHestonPaths}}
seed):

\begin{lstlisting}
def getHestonPaths(
        numPaths,
        numAnnSteps,
        t,
        drift,
        s0,
        v0,
        kappa,
        theta,
        sigma,
        rho,
        scheme,
        seed):
\end{lstlisting}

\subsection{Function {\it getGBMPaths}}
def getGBMPaths(numPaths, numAnnSteps, t, mu, stockPrice, sigma, scheme, seed):

\begin{lstlisting}
def getGBMPaths(numPaths, numAnnSteps, t, mu, stockPrice, sigma, scheme, seed):
\end{lstlisting}

\subsection{Function {\it getVasicekPaths}}
seed):

\begin{lstlisting}
def getVasicekPaths(
        numPaths,
        numAnnSteps,
        t,
        r0,
        kappa,
        theta,
        sigma,
        scheme,
        seed):
\end{lstlisting}

\subsection{Function {\it getCIRPaths}}
seed):

\begin{lstlisting}
def getCIRPaths(
        numPaths,
        numAnnSteps,
        t,
        r0,
        kappa,
        theta,
        sigma,
        scheme,
        seed):
\end{lstlisting}

\newpage
\section{FinSABRModel}

\subsection{Function {\it blackVolFromSABR}}
def blackVolFromSABR(alpha, beta, rho, nu, f, k, t):

\begin{lstlisting}
def blackVolFromSABR(alpha, beta, rho, nu, f, k, t):
\end{lstlisting}

\newpage
\section{FinStudentTCopulaModel}

\subsection{Class: FinStudentTCopulaModel()}
class FinStudentTCopulaModel():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it defaultTimes}}
seed):

\begin{lstlisting}
    def defaultTimes(self,
                     issuerCurves,
                     correlationMatrix,
                     degreesOfFreedom,
                     numTrials,
                     seed):
\end{lstlisting}

\newpage
\section{FinVasicekRateModel}

\subsection{Class: FinVasicekModel()}
class FinVasicekModel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_a}
\item{self.\_b}
\item{self.\_sigma}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, a, b, sigma):

\begin{lstlisting}
    def __init__(self, a, b, sigma):
\end{lstlisting}

\subsection{Function {\it meanr}}
def meanr(r0, a, b, t):

\begin{lstlisting}
def meanr(r0, a, b, t):
\end{lstlisting}

\subsection{Function {\it variancer}}
def variancer(a, b, sigma, t):

\begin{lstlisting}
def variancer(a, b, sigma, t):
\end{lstlisting}

\subsection{Function {\it zeroPrice}}
def zeroPrice(r0, a, b, sigma, t):

\begin{lstlisting}
def zeroPrice(r0, a, b, sigma, t):
\end{lstlisting}

\subsection{Function {\it ratePath\_MC}}
def ratePath\_MC(r0, a, b, sigma, t, dt, seed):

\begin{lstlisting}
def ratePath_MC(r0, a, b, sigma, t, dt, seed):
\end{lstlisting}

\subsection{Function {\it zeroPrice\_MC}}
def zeroPrice\_MC(r0, a, b, sigma, t, dt, numPaths, seed):

\begin{lstlisting}
def zeroPrice_MC(r0, a, b, sigma, t, dt, numPaths, seed):
\end{lstlisting}


\chapter{..//portfolio}
\section{Introduction}

\newpage
\section{FinBondPortfolio}

\subsection{Class: FinBondPortfolio(object)}
Class for fixed coupon bonds and performing related analytics. Theseare bullet bonds which means they have regular coupon payments of a knownsize that are paid on known dates plus a payment of par at maturity.

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_numBonds}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, settlementDate, bondList):
\end{lstlisting}

\subsection{Class Method {\it fitYieldCurveToBonds}}
def fitYieldCurveToBonds( curvetype) 

\begin{lstlisting}
    def fitYieldCurveToBonds( curvetype) 


\end{lstlisting}

\subsection{Class Method {\it duration}}
def duration()

\begin{lstlisting}
    def duration()


\end{lstlisting}

\subsection{Class Method {\it convexity}}
def convexity()

\begin{lstlisting}
    def convexity()
    



import pandas as pd
bondDf = pd.read_csv('./data/giltbondprices.txt',sep='\t')\end{lstlisting}

\newpage
\section{FinMeanVariancePortfolio}

\subsection{Class: MeanVariancePortfolio()}
class MeanVariancePortfolio():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_# Let's define some functions we will use later}}
def \_\_\# Lets define some functions we will use later

\begin{lstlisting}
    def __# Let's define some functions we will use later

\end{lstlisting}

\subsection{Class Method {\it portfolioVariance}}
def portfolioVariance(weights):

\begin{lstlisting}
    def portfolioVariance(weights):
\end{lstlisting}

\subsection{Class Method {\it portfolioVolatility}}
def portfolioVolatility(weights):

\begin{lstlisting}
    def portfolioVolatility(weights):
\end{lstlisting}

\subsection{Class Method {\it portfolioReturn}}
def portfolioReturn(weights):

\begin{lstlisting}
    def portfolioReturn(weights):
\end{lstlisting}

\subsection{Class Method {\it portfolioSharpeRatio}}
def portfolioSharpeRatio(weights):

\begin{lstlisting}
    def portfolioSharpeRatio(weights):
\end{lstlisting}


\chapter{..//risk}
\section{Introduction}
# Risk

This folder contains all functionality relating to the calculation of portfolio risk measures. 
\newpage
\section{FinPortfolioCreditDefaultMode}

\subsection{Class: FinPortfolioCreditDefaultMode(object)}
class FinPortfolioCreditDefaultMode(object):

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_recoveryRates}
\item{self.\_weights}
\item{self.\_lossDbn}
\item{self.\_support}
\item{self.\_numCredits}
\item{self.\_betaValues}
\item{self.\_hazardRates}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
weights):

\begin{lstlisting}
    def __init__(self,
                 weights):
\end{lstlisting}

\subsection{Class Method {\it lossDistribution}}
numPoints):

\begin{lstlisting}
    def lossDistribution(self,
                         tmat,
                         hazardRates,
                         recoveryRates,
                         betaValues,
                         numPoints):
\end{lstlisting}

\newpage
\section{FinPortfolioRiskMetrics}

\subsection{Function {\it expectedLoss}}
lossProbabilityVector):

\begin{lstlisting}
def expectedLoss(lossSizeVector,
                 lossProbabilityVector):
\end{lstlisting}

\subsection{Function {\it valueAtRisk}}
confidenceLevel):

\begin{lstlisting}
def valueAtRisk(lossSizeVector,
                lossProbabilityVector,
                confidenceLevel):
\end{lstlisting}

\subsection{Function {\it expectedShortfall}}
confidenceLevel):

\begin{lstlisting}
def expectedShortfall(lossSizeVector,
                      lossProbabilityVector,
                      confidenceLevel):
\end{lstlisting}


\chapter{..//market//curves}
\section{Introduction}
# Curves
### Overview
These modules create a family of curve types related to the term structures of interest rates. There are two basic types of curve:

1) Best fit yield curves fitting to bond prices which are used for interpolation. A range of curve shapes from polynomials to B-Splines is available.

2) Discount curves that can be used to present value a future cash flow. These differ from best fits curves in that they exactly refit the prices of bonds or CDS. The different discount curves are created by calibrating to different instruments. They also differ in terms of the term structure shapes they can have. Different shapes have different impacts in terms of locality on risk management performed using these different curves. There is often a trade-off between smoothness and locality.

## Best Fit Bond Curves

### FinBondYieldCurve
This module describes a curve that is fitted to bond yields calculated from bond market prices supplied by the user. The curve is not guaranteed to fit all of the bond prices exactly and a least squares approach is used. A number of fitting forms are provided which consist of Polynomial, Nelson-Siegel, Nelson-Siegal-Svensson and Cubic B-Splines. This curve cannot be used for pricing as yields assume a flat term structure. It can be used for fitting and interpolating yields off a nicely constructed yield curve interpolation curve.

### FinCurveFitMethod
This module sets out a range of curve forms that can be fitted to the bond yields. These includes a number of parametric curves that can be used to fit yield curves. These include:
+ Polynomials of any degree 
+ Nelson-Siegel functional form. 
+ Nelson-Siegel-Svensson functional form.
+ B-Splines

### FinNelsonSiegelCurve
Implementation of the Nelson-Siegel and the Nelson-Siegel-Svensson curves.

## Discount Curves
These are curves that can be used to discount cashflows.

### FinDiscountCurve
This is a class that holds a Numpy array of times and discount factor values that represents a discount curve. It also requires a specific interpolation scheme. A function is also provided to return a survival probability so that this class can also be used to handle term structures of survival probabilities.

### FinBondZeroCurve
This is a discount curve that is extracted by bootstrapping a zero rate curve such that it exactly reprices the set of bonds provided. The internal representation of the curve are discount factors on each of the bond maturity dates. Between these dates, discount factors are interpolated according to a specified scheme - see below.

### FinLiborCurve
This is a discount curve that is extracted by bootstrapping a set of Libor deposits, Libor FRAs and Libor swap prices. The internal representation of the curve are discount factors on each of the deposit, FRA and swap maturity dates. Between these dates, discount factors are interpolated according to a specified scheme - see below.

### FinCDSCurve
This is a curve that has been calibrated to fit the market term structure of CDS contracts given a recovery rate assumption and a FinLiborCurve discount curve. It also contains a LiborCurve object for discounting. It has methods for fitting the curve and also for extracting survival probabilities.

### FinInterpolate
This module contains the interpolation function used throughout the discount curves when a discount factor needs to be interpolated. There are three interpolation methods
+ PIECEWISE LINEAR - This assumes that a discount factor at a time between two other known discount factors is obtained by linear interpolation. This approach does not guarantee any smoothness but is local. It does not guarantee positive forwards (assuming positive zero rates).
+ PIECEWISE LOG LINEAR - This assumes that the log of the discount factor is interpolated linearly. The log of a discount factor to time T is T x R(T) where R(T) is the zero rate. So this is not linear interpolation of R(T) but of T x R(T).
+ FLAT FORWARDS - This interpolation assumes that the forward rate is constant between discount factor points. It is not smooth but is highly local and also ensures positive forward rates if the zero rates are positive.

\newpage
\section{FinBondYieldCurve}

\subsection{Class: FinBondYieldCurve()}
Class to do fitting of the yield curve and to enable interpolation of yields. Because yields assume a flat term structure for each bond, this class does not allow discounting to be done and so does not inherit from FinDiscountCurve. It should only be used for visualisation and simple interpolation but not for full term-structure-consistent pricing. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_curveFitMethod.\_spline}
\item{self.\_curveFitMethod.\_tau}
\item{self.\_curveFitMethod}
\item{self.\_bonds}
\item{self.\_curveFitMethod.\_tau2}
\item{self.\_curveFitMethod.\_beta2}
\item{self.\_curveFitMethod.\_beta3}
\item{self.\_curveFitMethod.\_beta4}
\item{self.\_curveFitMethod.\_beta1}
\item{self.\_curveFitMethod.\_tau1}
\item{self.\_curveFitMethod.\_coeffs}
\item{self.\_ylds}
\item{self.\_yearsToMaturity}
\item{self.\_bounds}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Fit the curve to a set of bond yields using the type of curve specified. Bounds can be provided if you wish to enforce lower and upper limits on the respective model parameters. 

\begin{lstlisting}
    def __init__(self, settlementDate, bonds, ylds, curveFitMethod,
                 bounds=None):
\end{lstlisting}

\subsection{Class Method {\it interpolatedYield}}
def interpolatedYield(self, maturityDate):

\begin{lstlisting}
    def interpolatedYield(self, maturityDate):
\end{lstlisting}

\subsection{Class Method {\it display}}


\begin{lstlisting}
    def display(self, title):
\end{lstlisting}

\newpage
\section{FinBondYieldCurveModel}

\subsection{Class: FinCurveFitMethod()}
class FinCurveFitMethod():

\subsubsection{Class Data Members}
No data members found.

\subsubsection{Class Functions}

\subsection{Class: FinCurveFitMethodPolynomial()}
class FinCurveFitMethodPolynomial():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_power}
\item{self.\_coeffs}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, power=3):

\begin{lstlisting}
    def __init__(self, power=3):
\end{lstlisting}

\subsection{Class Method {\it interpolateRate}}
def interpolateRate(self, t):

\begin{lstlisting}
    def interpolateRate(self, t):
\end{lstlisting}

\subsection{Class: FinCurveFitMethodNelsonSiegel()}
class FinCurveFitMethodNelsonSiegel():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_beta2}
\item{self.\_parentType}
\item{self.\_beta3}
\item{self.\_tau}
\item{self.\_beta1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, tau=None):

\begin{lstlisting}
    def __init__(self, tau=None):
\end{lstlisting}

\subsection{Class Method {\it interpolateRate}}
def interpolateRate(self, t, beta1=None, beta2=None, beta3=None, tau=None):

\begin{lstlisting}
    def interpolateRate(self, t, beta1=None, beta2=None, beta3=None, tau=None):
\end{lstlisting}

\subsection{Class: FinCurveFitMethodNelsonSiegelSvensson()}
class FinCurveFitMethodNelsonSiegelSvensson():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_beta2}
\item{self.\_tau2}
\item{self.\_beta4}
\item{self.\_parentType}
\item{self.\_tau1}
\item{self.\_beta3}
\item{self.\_beta1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, tau1=None, tau2=None):

\begin{lstlisting}
    def __init__(self, tau1=None, tau2=None):
\end{lstlisting}

\subsection{Class Method {\it interpolateRate}}
beta4=None, tau1=None, tau2=None):

\begin{lstlisting}
    def interpolateRate(self, t, beta1=None, beta2=None, beta3=None,
                        beta4=None, tau1=None, tau2=None):
\end{lstlisting}

\subsection{Class: FinCurveFitMethodBSpline()}
class FinCurveFitMethodBSpline():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_parentType}
\item{self.\_power}
\item{self.\_knots}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, power=3, knots=[1, 3, 5, 10]):

\begin{lstlisting}
    def __init__(self, power=3, knots=[1, 3, 5, 10]):
\end{lstlisting}

\subsection{Class Method {\it interpolateRate}}
def interpolateRate(self, t):

\begin{lstlisting}
    def interpolateRate(self, t):
\end{lstlisting}

\newpage
\section{FinBondZeroCurve}

\subsection{Class: FinBondZeroCurve()}


\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_settlementDate}
\item{self.\_discountCurve}
\item{self.\_interpMethod}
\item{self.\_bonds}
\item{self.\_values}
\item{self.\_times}
\item{self.\_yearsToMaturity}
\item{self.\_curveDate}
\item{self.\_cleanPrices}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Fit a discount curve to a set of bond yields using the type of curve specified. 

\begin{lstlisting}
    def __init__(self, settlementDate, bonds, cleanPrices,
                 interpMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsection{Class Method {\it bootstrapZeroRates}}
def bootstrapZeroRates(self):

\begin{lstlisting}
    def bootstrapZeroRates(self):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}


\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it df}}
def df(self, dt):

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection{Class Method {\it survProb}}
def survProb(self, dt):

\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwdRate}}
Calculate the forward rate according to the specifiedday count convention. 

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsection{Class Method {\it display}}


\begin{lstlisting}
    def display(self, title):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsection{Function {\it f}}
def f(df, *args):

\begin{lstlisting}
def f(df, *args):
\end{lstlisting}

\newpage
\section{FinCDSCurve}

\subsection{Class: FinCDSCurve()}
Generate a survival probability curve implied by the value of CDScontracts given a Libor curve and an assumed recovery rate. A scheme forthe interpolation of the survival probabilities is also required. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_interpolationMethod}
\item{self.\_cdsContracts}
\item{self.\_values}
\item{self.\_recoveryRate}
\item{self.\_liborCurve}
\item{self.\_times}
\item{self.\_builtOK}
\item{self.\_curveDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def __init__(self,
                 curveDate,
                 cdsContracts,
                 liborCurve,
                 recoveryRate=0.40,
                 useCache=False,
                 interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsection{Class Method {\it validate}}


\begin{lstlisting}
    def validate(self, cdsContracts):
\end{lstlisting}

\subsection{Class Method {\it survProb}}


\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, t):
\end{lstlisting}

\subsection{Class Method {\it buildCurve}}
def buildCurve(self):

\begin{lstlisting}
    def buildCurve(self):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwdRate}}
Calculate the forward rate according to the specifiedday count convention. 

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}


\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\subsection{Function {\it uniformToDefaultTime}}
def uniformToDefaultTime(u, t, v):

\begin{lstlisting}
def uniformToDefaultTime(u, t, v):
\end{lstlisting}

\subsection{Function {\it f}}
def f(q, *args):

\begin{lstlisting}
def f(q, *args):
\end{lstlisting}

\newpage
\section{FinCurve}

\subsection{Function {\it inputFrequency}}
def inputFrequency(f):

\begin{lstlisting}
def inputFrequency(f):
\end{lstlisting}

\subsection{Function {\it inputTime}}
def inputTime(dt, curve):

\begin{lstlisting}
def inputTime(dt, curve):
\end{lstlisting}

\newpage
\section{FinDiscountCurve}

\subsection{Class: FinDiscountCurve()}
class FinDiscountCurve():

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_interpMethod}
\item{self.\_curveDate}
\item{self.\_times}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, curveDate, times, values, interpMethod):

\begin{lstlisting}
    def __init__(self, curveDate, times, values, interpMethod):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}


\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it df}}
def df(self, dt):

\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection{Class Method {\it survProb}}
def survProb(self, dt):

\begin{lstlisting}
    def survProb(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwdRate}}
Calculate the forward rate according to the specifiedday count convention. 

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}

\newpage
\section{FinFlatCurve}

\subsection{Class: FinFlatCurve()}
A trivally simple curve based on a single zero rate with its ownspecified compounding method. Hence the curve is assumed to be flat. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_rate}
\item{self.\_curveDate}
\item{self.\_cmpdFreq}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, curveDate, rate, compoundingFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}


\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwdRate}}
Calculate the forward rate according to the specifiedday count convention. 

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\newpage
\section{FinInterpolate}

\subsubsection{Enumerated Type: FinInterpMethods}
\begin{itemize}
\item{LINEAR\_ZERO\_RATES}
\item{FLAT\_FORWARDS}
\item{LINEAR\_FORWARDS}
\end{itemize}

\subsection{Function {\it interpolate}}
method):

\begin{lstlisting}
def interpolate(x,
                times,
                dfs,
                method):
\end{lstlisting}

\subsection{Function {\it uinterpolate}}
Return the interpolated value of y given x and a vector of x and y.The values of x must be monotonic and increasing. The different schemes forinterpolation are linear in y (as a function of x), linear in log(y) andpiecewise flat in the continuously compounded forward y rate. 

\begin{lstlisting}
def uinterpolate(t,
                 times,
                 dfs,
                 method):
\end{lstlisting}

\subsection{Function {\it vinterpolate}}
Return the interpolated values of y given x and a vector of x and y.The values of x must be monotonic and increasing. The different schemes forinterpolation are linear in y (as a function of x), linear in log(y) andpiecewise flat in the continuously compounded forward y rate. 

\begin{lstlisting}
def vinterpolate(xValues,
                 xvector,
                 dfs,
                 method):
\end{lstlisting}

\newpage
\section{FinLiborCurve}

\subsection{Class: FinLiborCurve(FinDiscountCurve)}
Constructs a discount curve as implied by the prices of Libor deposits, FRAs and IRS. The curve date is the date on which weare performing the valuation based on the information available on thecurve date. Typically it is the date on which an amount of $1 paidhas a present value of $1.This class inherits from FinDiscountCurve so has all of the methodsthat class has. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_interpMethod}
\item{self.\_values}
\item{self.\_usedDeposits}
\item{self.\_times}
\item{self.\_name}
\item{self.\_usedFRAs}
\item{self.\_usedSwaps}
\item{self.\_curveDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
interpMethod=FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def __init__(self,
                 name,
                 curveDate,
                 liborDeposits,
                 liborFRAs,
                 liborSwaps,
                 interpMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsection{Class Method {\it validateInputs}}


\begin{lstlisting}
    def validateInputs(self,
                       liborDeposits,
                       liborFRAs,
                       liborSwaps):
\end{lstlisting}

\subsection{Class Method {\it buildCurve}}


\begin{lstlisting}
    def buildCurve(self,
                   liborDeposits,
                   liborFRAs,
                   liborSwaps):
\end{lstlisting}

\subsection{Function {\it f}}
def f(df, *args):

\begin{lstlisting}
def f(df, *args):
\end{lstlisting}

\newpage
\section{FinNelsonSiegelCurve}

\subsection{Class: FinNelsonSiegelCurve()}
Implementation of Nelson-Siegel parametrisation of a rate curve. The default is a continuously compounded rate but you can override this by providing a corresponding compounding frequency. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_beta2}
\item{self.\_beta1}
\item{self.\_beta3}
\item{self.\_tau}
\item{self.\_curveDate}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
Creation of a Nelson-Siegel curve. Parameters are provided as a list or vector of 4 values for beta1, beta2, beta3 and tau. 

\begin{lstlisting}
    def __init__(self, curveDate, params, cmpdFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}
Calculation of zero rates with specified frequency. This function can return a vector of zero rates given a vector of times so must use Numpy functions. 

\begin{lstlisting}
    def zeroRate(self, dt, compoundingFreq=-1):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
Calculation of forward rates. This function can return a vectorof instantaneous forward rates given a vector of times. 

\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection{Class: FinNelsonSiegelSvenssonCurve()}
Implementation of Nelson-Siegel-Svensson parametrisation of thezero rate curve 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_beta2}
\item{self.\_tau2}
\item{self.\_beta1}
\item{self.\_beta4}
\item{self.\_beta3}
\item{self.\_tau1}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}
def \_\_init\_\_(self, beta1, beta2, beta3, beta4, tau1, tau2):

\begin{lstlisting}
    def __init__(self, beta1, beta2, beta3, beta4, tau1, tau2):
\end{lstlisting}

\subsection{Class Method {\it zero}}
Calculation of zero rates. This function can return a vectorof zero rates given a vector of times. 

\begin{lstlisting}
    def zero(self, t):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
Calculation of forward rates. This function uses Numpy so can returna vector of forward rates given a Numpy array vector of times. 

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsection{Class Method {\it df}}
Discount factor for Nelson-Siegel-Svensson curve parametrisation. 

\begin{lstlisting}
    def df(self, t):
\end{lstlisting}

\newpage
\section{FinPiecewiseFlatCurve}

\subsection{Class: FinPiecewiseCurve()}
Curve is made up of a series of zero rates assumed to each have a piecewise flat constant shape OR a piecewise linear shape. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_interpMethod}
\item{self.\_zeroRates}
\item{self.\_cmpdFreq}
\item{self.\_times}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, 
                 curveDate, 
                 times, 
                 zeroRates, 
                 compoundingFreq=-1, 
                 interpolationMethod):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}
def zeroRate(self, t, compoundingFreq):

\begin{lstlisting}
    def zeroRate(self, t, compoundingFreq):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
def fwd(self, t):

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsection{Class Method {\it df}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def df(self,
           t,
           freq=0,  # This corresponds to continuous compounding
           interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\newpage
\section{FinPiecewiseLinearCurve}

\subsection{Class: FinPiecewiseLinearCurve()}
Curve is made up of a series of sections assumed to each have a constantforward rate. This class needs to be checked carefully. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_times}
\item{self.\_values}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, curveDate, times, values):
\end{lstlisting}

\subsection{Class Method {\it zero}}
def zero(self, t, interpolationMethod=FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def zero(self, t, interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\subsection{Class Method {\it fwd}}
def fwd(self, t):

\begin{lstlisting}
    def fwd(self, t):
\end{lstlisting}

\subsection{Class Method {\it df}}
interpolationMethod=FinInterpMethods.FLAT\_FORWARDS):

\begin{lstlisting}
    def df(self,
           t,
           freq=0,  # This corresponds to continuous compounding
           interpolationMethod=FinInterpMethods.FLAT_FORWARDS):
\end{lstlisting}

\newpage
\section{FinPolynomialCurve}

\subsection{Class: FinPolynomialCurve()}
Curve with zero rate of specified frequency parametrised as a cubic polynomial. 

\subsubsection{Class Data Members}
\begin{itemize}
\item{self.\_coefficients}
\item{self.\_curveDate}
\item{self.\_power}
\end{itemize}

\subsubsection{Class Functions}

\subsection{Class Method {\it \_\_init\_\_}}


\begin{lstlisting}
    def __init__(self, curveDate, coefficients,
                 compoundingType=FinCompoundingMethods.CONTINUOUS):
\end{lstlisting}

\subsection{Class Method {\it zeroRate}}


\begin{lstlisting}
    def zeroRate(self, dt):
\end{lstlisting}

\subsection{Class Method {\it df}}


\begin{lstlisting}
    def df(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwd}}


\begin{lstlisting}
    def fwd(self, dt):
\end{lstlisting}

\subsection{Class Method {\it fwdRate}}
Calculate the forward rate according to the specifiedday count convention. 

\begin{lstlisting}
    def fwdRate(self, date1, date2, dayCountType):
\end{lstlisting}

\subsection{Class Method {\it print}}
def print(self):

\begin{lstlisting}
    def print(self):
\end{lstlisting}


\chapter{..//tests}
\section{Introduction}
# Test Suite

This folder contains the logic for performing comparison testing of code to ensure that code does not inadvertently get broken.

The test is based on the prior creation of a Golden version of the file output which is stored in the Golden folder. There is a file for each test file. This is considered to be correct and any output that deviates from this is deemed to be incorrect. Creation of the Golden files is done by setting the value of the global flag as follows:

globalTestCaseMode = FinTestCaseMode.SAVE_TEST_CASES

This can be found under finutils/FinTestCase.py

When you wish to run the tests to check if anything has changed, you need to set the global flag to

globalTestCaseMode = FinTestCaseMode.ANALYSE_TEST_CASES

## RunAllTests.py

This file executes all of the test files which each report on any errors found.


## Output

Any change is registered as an error. No matter what the precision. 

\newpage
\section{TestFinAmericanOption}

\subsection{Function {\it testFinAmericanOption}}
def testFinAmericanOption():

\begin{lstlisting}
def testFinAmericanOption():
\end{lstlisting}


\newpage
\section{TestFinAnnuity}

\subsection{Function {\it test\_FinAnnuity}}
def test\_FinAnnuity():

\begin{lstlisting}
def test_FinAnnuity():
\end{lstlisting}


\newpage
\section{TestFinAsianOption}

\subsection{Function {\it testConvergence}}
def testConvergence():

\begin{lstlisting}
def testConvergence():
\end{lstlisting}

\subsection{Function {\it testTimeEvolution}}
def testTimeEvolution():

\begin{lstlisting}
def testTimeEvolution():
\end{lstlisting}

\subsection{Function {\it testMCTimings}}
def testMCTimings():

\begin{lstlisting}
def testMCTimings():
\end{lstlisting}


\newpage
\section{TestFinBarrierOption}

\subsection{Function {\it test\_FinBarrierOption}}
def test\_FinBarrierOption():

\begin{lstlisting}
def test_FinBarrierOption():
\end{lstlisting}


\newpage
\section{TestFinBasketOption}

\subsection{Function {\it test\_FinBasketOption}}
def test\_FinBasketOption():

\begin{lstlisting}
def test_FinBasketOption():
\end{lstlisting}


\newpage
\section{TestFinBinomialTree}

\subsection{Function {\it test\_FinBinomialTree}}
def test\_FinBinomialTree():

\begin{lstlisting}
def test_FinBinomialTree():
\end{lstlisting}


\newpage
\section{TestFinBond}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(valuationDate):

\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinBond}}
def test\_FinBond():

\begin{lstlisting}
def test_FinBond():
\end{lstlisting}


\newpage
\section{TestFinBondFutures}

\subsection{Function {\it test\_FinBondFuture}}
def test\_FinBondFuture():

\begin{lstlisting}
def test_FinBondFuture():
\end{lstlisting}


\newpage
\section{TestFinBondPortfolio}

\subsection{Function {\it test\_FinBondPortfolio}}
def test\_FinBondPortfolio():

\begin{lstlisting}
def test_FinBondPortfolio():
\end{lstlisting}


\newpage
\section{TestFinBondYieldCurve}

\subsection{Function {\it test\_FinBondYieldCurve}}
def test\_FinBondYieldCurve():

\begin{lstlisting}
def test_FinBondYieldCurve():
\end{lstlisting}


\newpage
\section{TestFinBondZeroCurve}

\subsection{Function {\it test\_FinBondZeroCurve}}
def test\_FinBondZeroCurve():

\begin{lstlisting}
def test_FinBondZeroCurve():
\end{lstlisting}


\newpage
\section{TestFinCDS}

\subsection{Function {\it test\_CDSFastApproximation}}
def test\_CDSFastApproximation():

\begin{lstlisting}
def test_CDSFastApproximation():
\end{lstlisting}

\subsection{Function {\it test\_CDSCurveRepricing}}
def test\_CDSCurveRepricing():

\begin{lstlisting}
def test_CDSCurveRepricing():
\end{lstlisting}

\subsection{Function {\it test\_CDSCurveBuildTiming}}
def test\_CDSCurveBuildTiming():

\begin{lstlisting}
def test_CDSCurveBuildTiming():
\end{lstlisting}

\subsection{Function {\it test\_CurveBuild}}
def test\_CurveBuild():

\begin{lstlisting}
def test_CurveBuild():
\end{lstlisting}

\subsection{Function {\it buildFullIssuerCurve}}
def buildFullIssuerCurve(mktSpreadBump, irBump):

\begin{lstlisting}
def buildFullIssuerCurve(mktSpreadBump, irBump):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDS}}
def test\_fullPriceCDS():

\begin{lstlisting}
def test_fullPriceCDS():
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSConvergence}}
def test\_fullPriceCDSConvergence():

\begin{lstlisting}
def test_fullPriceCDSConvergence():
\end{lstlisting}

\subsection{Function {\it test\_CDSDateGeneration}}
def test\_CDSDateGeneration():

\begin{lstlisting}
def test_CDSDateGeneration():
\end{lstlisting}


\newpage
\section{TestFinCDSBasket}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it loadHomogeneousSpreadCurves}}
numCredits):

\begin{lstlisting}
def loadHomogeneousSpreadCurves(valuationDate,
                                liborCurve,
                                cdsSpread3Y,
                                cdsSpread5Y,
                                cdsSpread7Y,
                                cdsSpread10Y,
                                numCredits):
\end{lstlisting}

\subsection{Function {\it loadHeterogeneousSpreadCurves}}
def loadHeterogeneousSpreadCurves(valuationDate, liborCurve):

\begin{lstlisting}
def loadHeterogeneousSpreadCurves(valuationDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_FinCDSBasket}}
def test\_FinCDSBasket():

\begin{lstlisting}
def test_FinCDSBasket():
\end{lstlisting}


\newpage
\section{TestFinCDSCurve}

\subsection{Function {\it test\_FinCDSCurve}}
def test\_FinCDSCurve():

\begin{lstlisting}
def test_FinCDSCurve():
\end{lstlisting}


\newpage
\section{TestFinCDSIndex}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate, liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_valueCDSIndex}}
def test\_valueCDSIndex():

\begin{lstlisting}
def test_valueCDSIndex():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexAdjustHazards}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate, liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_performCDSIndexHazardRateAdjustment}}
def test\_performCDSIndexHazardRateAdjustment():

\begin{lstlisting}
def test_performCDSIndexHazardRateAdjustment():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexAdjustSpreads}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate, liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_CDSIndexAdjustSpreads}}
def test\_CDSIndexAdjustSpreads():

\begin{lstlisting}
def test_CDSIndexAdjustSpreads():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexOption}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildFlatIssuerCurve}}
def buildFlatIssuerCurve(tradeDate, liborCurve, spread, recoveryRate):

\begin{lstlisting}
def buildFlatIssuerCurve(tradeDate, liborCurve, spread, recoveryRate):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSIndexOption}}
def test\_fullPriceCDSIndexOption():

\begin{lstlisting}
def test_fullPriceCDSIndexOption():
\end{lstlisting}


\newpage
\section{TestFinCDSIndexPortfolio}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it buildIssuerCurve}}
def buildIssuerCurve(tradeDate, liborCurve):

\begin{lstlisting}
def buildIssuerCurve(tradeDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_CDSIndexPortfolio}}
def test\_CDSIndexPortfolio():

\begin{lstlisting}
def test_CDSIndexPortfolio():
\end{lstlisting}


\newpage
\section{TestFinCDSOption}

\subsection{Function {\it buildFullIssuerCurve}}
def buildFullIssuerCurve(tradeDate):

\begin{lstlisting}
def buildFullIssuerCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it test\_fullPriceCDSwaption}}
def test\_fullPriceCDSwaption():

\begin{lstlisting}
def test_fullPriceCDSwaption():
\end{lstlisting}


\newpage
\section{TestFinCDSTranche}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(tradeDate):

\begin{lstlisting}
def buildLiborCurve(tradeDate):
\end{lstlisting}

\subsection{Function {\it loadHomogeneousCDSCurves}}
numCredits):

\begin{lstlisting}
def loadHomogeneousCDSCurves(valuationDate,
                             liborCurve,
                             cdsSpread3Y,
                             cdsSpread5Y,
                             cdsSpread7Y,
                             cdsSpread10Y,
                             numCredits):
\end{lstlisting}

\subsection{Function {\it loadHeterogeneousSpreadCurves}}
def loadHeterogeneousSpreadCurves(valuationDate, liborCurve):

\begin{lstlisting}
def loadHeterogeneousSpreadCurves(valuationDate, liborCurve):
\end{lstlisting}

\subsection{Function {\it test\_FinCDSTranche}}
def test\_FinCDSTranche():

\begin{lstlisting}
def test_FinCDSTranche():
\end{lstlisting}


\newpage
\section{TestFinCIRRateModel}

\subsection{Function {\it test\_FinCIRRateModel}}
def test\_FinCIRRateModel():

\begin{lstlisting}
def test_FinCIRRateModel():
\end{lstlisting}


\newpage
\section{TestFinCompoundOption}

\subsection{Function {\it test\_FinCompoundOption}}
def test\_FinCompoundOption():

\begin{lstlisting}
def test_FinCompoundOption():
\end{lstlisting}


\newpage
\section{TestFinConvertibleBond}

\subsection{Function {\it test\_FinConvertibleBond}}
def test\_FinConvertibleBond():

\begin{lstlisting}
def test_FinConvertibleBond():
\end{lstlisting}


\newpage
\section{TestFinDate}

\subsection{Function {\it test\_FinDate}}
def test\_FinDate():

\begin{lstlisting}
def test_FinDate():
\end{lstlisting}

\subsection{Function {\it test\_FinDateTenors}}
def test\_FinDateTenors():

\begin{lstlisting}
def test_FinDateTenors():
\end{lstlisting}


\newpage
\section{TestFinDayCount}

\subsection{Function {\it test\_FinDayCount}}
def test\_FinDayCount():

\begin{lstlisting}
def test_FinDayCount():
\end{lstlisting}


\newpage
\section{TestFinDigitalOption}

\subsection{Function {\it test\_FinDigitalOption}}
def test\_FinDigitalOption():

\begin{lstlisting}
def test_FinDigitalOption():
\end{lstlisting}


\newpage
\section{TestFinDiscountCurve}

\subsection{Function {\it test\_FinDiscountCurve}}
def test\_FinDiscountCurve():

\begin{lstlisting}
def test_FinDiscountCurve():
\end{lstlisting}


\newpage
\section{TestFinFlatCurve}

\subsection{Function {\it test\_FinFlatCurve}}
def test\_FinFlatCurve():

\begin{lstlisting}
def test_FinFlatCurve():
\end{lstlisting}


\newpage
\section{TestFinFloatingRateNote}

\subsection{Function {\it buildLiborCurve}}
def buildLiborCurve(valuationDate):

\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinFloatingRateNote}}
def test\_FinFloatingRateNote():

\begin{lstlisting}
def test_FinFloatingRateNote():
\end{lstlisting}


\newpage
\section{TestFinHestonModel}

\subsection{Function {\it testAnalyticalModels}}
def testAnalyticalModels():

\begin{lstlisting}
def testAnalyticalModels():
\end{lstlisting}

\subsection{Function {\it testMonteCarlo}}
def testMonteCarlo():

\begin{lstlisting}
def testMonteCarlo():
\end{lstlisting}


\newpage
\section{TestFinInterpolate}

\subsection{Function {\it test\_FinInterpolate}}
def test\_FinInterpolate():

\begin{lstlisting}
def test_FinInterpolate():
\end{lstlisting}


\newpage
\section{TestFinInterpolatedForwards}

\subsection{Function {\it test\_FinInterpolatedForwards}}
def test\_FinInterpolatedForwards():

\begin{lstlisting}
def test_FinInterpolatedForwards():
\end{lstlisting}


\newpage
\section{TestFinLiborCapFloor}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps(valuationDate):

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinLiborCapFloor}}
def test\_FinLiborCapFloor():

\begin{lstlisting}
def test_FinLiborCapFloor():
\end{lstlisting}


\newpage
\section{TestFinLiborOneCurve}

\subsection{Function {\it test\_FinLiborDepositsOnly}}


\begin{lstlisting}
def test_FinLiborDepositsOnly():
\end{lstlisting}

\subsection{Function {\it test\_FinLiborFRAsOnly}}


\begin{lstlisting}
def test_FinLiborFRAsOnly():
\end{lstlisting}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps():

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps():
\end{lstlisting}


\newpage
\section{TestFinLiborSwap}

\subsection{Function {\it buildLiborCurve}}


\begin{lstlisting}
def buildLiborCurve(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_LiborSwap}}
Now perform a valuation after the swap has seasoned but with thesame curve being used for discounting and working out the impliedfuture Libor rates. 

\begin{lstlisting}
def test_LiborSwap():
\end{lstlisting}


\newpage
\section{TestFinLiborSwaption}

\subsection{Function {\it test\_FinLiborDepositsAndSwaps}}
def test\_FinLiborDepositsAndSwaps(valuationDate):

\begin{lstlisting}
def test_FinLiborDepositsAndSwaps(valuationDate):
\end{lstlisting}

\subsection{Function {\it test\_FinLiborSwaption}}
def test\_FinLiborSwaption():

\begin{lstlisting}
def test_FinLiborSwaption():
\end{lstlisting}


\newpage
\section{TestFinLookbackOption}

\subsection{Function {\it test\_FinLookBackOption}}
def test\_FinLookBackOption():

\begin{lstlisting}
def test_FinLookBackOption():
\end{lstlisting}


\newpage
\section{TestFinLossDbnBuilder}

\subsection{Function {\it test\_FinLossDbnBuilder}}
def test\_FinLossDbnBuilder():

\begin{lstlisting}
def test_FinLossDbnBuilder():
\end{lstlisting}


\newpage
\section{TestFinMath}

\subsection{Function {\it test\_FinMath}}
def test\_FinMath():

\begin{lstlisting}
def test_FinMath():
\end{lstlisting}


\newpage
\section{TestFinMeanVariancePortfolio}

\subsection{Function {\it test\_FinMeanVarPortfolio}}
def test\_FinMeanVarPortfolio():

\begin{lstlisting}
def test_FinMeanVarPortfolio():
\end{lstlisting}


\newpage
\section{TestFinNelsonSiegelCurve}

\subsection{Function {\it test\_FinNelsonSiegelCurve}}
def test\_FinNelsonSiegelCurve():

\begin{lstlisting}
def test_FinNelsonSiegelCurve():
\end{lstlisting}


\newpage
\section{TestFinNelsonSiegelSvenssonCurve}

\subsection{Function {\it test\_FinNelsonSiegelSvenssonCurve}}
def test\_FinNelsonSiegelSvenssonCurve():

\begin{lstlisting}
def test_FinNelsonSiegelSvenssonCurve():
\end{lstlisting}


\newpage
\section{TestFinOIS}

\subsection{Function {\it test\_OIS}}
def test\_OIS():

\begin{lstlisting}
def test_OIS():
\end{lstlisting}


\newpage
\section{TestFinPieceCurve}

\subsection{Function {\it test\_FinPieceCurve}}
def test\_FinPieceCurve():

\begin{lstlisting}
def test_FinPieceCurve():
\end{lstlisting}


\newpage
\section{TestFinPolynomialCurve}

\subsection{Function {\it test\_FinPolynomialCurve}}
def test\_FinPolynomialCurve():

\begin{lstlisting}
def test_FinPolynomialCurve():
\end{lstlisting}


\newpage
\section{TestFinPortfolioCreditDefaultMode}

\subsection{Function {\it test\_FinPortfolioCreditDefaultMode}}
def test\_FinPortfolioCreditDefaultMode():

\begin{lstlisting}
def test_FinPortfolioCreditDefaultMode():
\end{lstlisting}


\newpage
\section{TestFinPortfolioRiskMetrics}

\subsection{Function {\it test\_FinPortfolioRiskMetrics}}
def test\_FinPortfolioRiskMetrics():

\begin{lstlisting}
def test_FinPortfolioRiskMetrics():
\end{lstlisting}


\newpage
\section{TestFinProcessSimulator}

\subsection{Function {\it test\_FinProcessSimulator}}
def test\_FinProcessSimulator():

\begin{lstlisting}
def test_FinProcessSimulator():
\end{lstlisting}


\newpage
\section{TestFinRainbowOption}

\subsection{Function {\it test\_FinRainbowOption}}
def test\_FinRainbowOption():

\begin{lstlisting}
def test_FinRainbowOption():
\end{lstlisting}


\newpage
\section{TestFinSABRModel}

\subsection{Function {\it test\_SABR}}
def test\_SABR():

\begin{lstlisting}
def test_SABR():
\end{lstlisting}


\newpage
\section{TestFinSchedule}

\subsection{Function {\it test\_FinSchedule}}
def test\_FinSchedule():

\begin{lstlisting}
def test_FinSchedule():
\end{lstlisting}


\newpage
\section{TestFinStatistics}

\subsection{Function {\it test\_FinStatistics}}
def test\_FinStatistics():

\begin{lstlisting}
def test_FinStatistics():
\end{lstlisting}


\newpage
\section{TestFinVanillaOption}

\subsection{Function {\it test\_FinVanillaOption}}
def test\_FinVanillaOption():

\begin{lstlisting}
def test_FinVanillaOption():
\end{lstlisting}


\newpage
\section{TestFinVarianceSwap}

\subsection{Function {\it volSkew}}
def volSkew(K, atmVol, atmK, skew):

\begin{lstlisting}
def volSkew(K, atmVol, atmK, skew):
\end{lstlisting}

\subsection{Function {\it test\_FinVarianceSwap}}
def test\_FinVarianceSwap():

\begin{lstlisting}
def test_FinVarianceSwap():
\end{lstlisting}


\newpage
\section{TestFinVasicekRateModel}

\subsection{Function {\it test\_FinVasicekRateModel}}
def test\_FinVasicekRateModel():

\begin{lstlisting}
def test_FinVasicekRateModel():
\end{lstlisting}


\newpage
\section{TestFinVolatilityCurve}

\subsection{Function {\it test\_FinVolatilityCurve}}
def test\_FinVolatilityCurve():

\begin{lstlisting}
def test_FinVolatilityCurve():
\end{lstlisting}


\chapter{..//docs}
\section{Introduction}
This folder is where the project documentation is generated. This is done in Latex.
\end{document}
